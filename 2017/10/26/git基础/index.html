<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>git基础 | 田洪亮</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="获取 Git 仓库有两种方式获得git仓库的方法，第一种是现有项目或目录下导入所有文件到git中，第二种是从一个服务器克隆一个现有的git仓库 在现有的目录中初始化仓库如果你打算使用git来对现有的项目进行管理，你只需要进入目录并且输入：1git init 该命令将创建一个名为.git的子目录，这个子目录含有你初始化的git仓库中所有的必须文件，这些文件是git仓库的骨干。当时，这个时候，我们仅仅">
<meta property="og:type" content="article">
<meta property="og:title" content="git基础">
<meta property="og:url" content="http://yoursite.com/2017/10/26/git基础/index.html">
<meta property="og:site_name" content="田洪亮">
<meta property="og:description" content="获取 Git 仓库有两种方式获得git仓库的方法，第一种是现有项目或目录下导入所有文件到git中，第二种是从一个服务器克隆一个现有的git仓库 在现有的目录中初始化仓库如果你打算使用git来对现有的项目进行管理，你只需要进入目录并且输入：1git init 该命令将创建一个名为.git的子目录，这个子目录含有你初始化的git仓库中所有的必须文件，这些文件是git仓库的骨干。当时，这个时候，我们仅仅">
<meta property="og:image" content="http://yoursite.com/2017/10/26/image/gitImage/lifecycle.png">
<meta property="og:updated_time" content="2017-11-02T02:48:41.796Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="git基础">
<meta name="twitter:description" content="获取 Git 仓库有两种方式获得git仓库的方法，第一种是现有项目或目录下导入所有文件到git中，第二种是从一个服务器克隆一个现有的git仓库 在现有的目录中初始化仓库如果你打算使用git来对现有的项目进行管理，你只需要进入目录并且输入：1git init 该命令将创建一个名为.git的子目录，这个子目录含有你初始化的git仓库中所有的必须文件，这些文件是git仓库的骨干。当时，这个时候，我们仅仅">
<meta name="twitter:image" content="http://yoursite.com/2017/10/26/image/gitImage/lifecycle.png">
  
    <link rel="alternate" href="/atom.xml" title="田洪亮" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">田洪亮</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">如果你渴望得到某样东西，你得让它自由，如果它回到你身边，它就是属于你的，如果它不会回来， 你就从未拥有过它.  ——大仲马 《基督山伯爵》</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-git基础" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/10/26/git基础/" class="article-date">
  <time datetime="2017-10-26T11:57:39.000Z" itemprop="datePublished">2017-10-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      git基础
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="获取-Git-仓库"><a href="#获取-Git-仓库" class="headerlink" title="获取 Git 仓库"></a>获取 Git 仓库</h1><p>有两种方式获得git仓库的方法，第一种是现有项目或目录下导入所有文件到git中，第二种是从一个服务器克隆一个现有的git仓库</p>
<h2 id="在现有的目录中初始化仓库"><a href="#在现有的目录中初始化仓库" class="headerlink" title="在现有的目录中初始化仓库"></a>在现有的目录中初始化仓库</h2><p>如果你打算使用git来对现有的项目进行管理，你只需要进入目录并且输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git init</div></pre></td></tr></table></figure></p>
<p>该命令将创建一个名为<code>.git</code>的子目录，这个子目录含有你初始化的git仓库中所有的必须文件，这些文件是git仓库的骨干。当时，这个时候，我们仅仅是做了一个初始化的操作，你的项目里的文件还没没有被跟踪。<br>如果你是在一个已经存在文件的文件夹中初始化git仓库来进行版本控制的话，你应该开始跟踪这些文件并且提交。你可通过<code>git add</code>命令来实现对指定文件的跟踪，然后执行<code>git commit</code>提交：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git add *.*</div><div class="line">git commit -m &quot;提交的的信息&quot;</div></pre></td></tr></table></figure></p>
<h2 id="克隆现有的仓库"><a href="#克隆现有的仓库" class="headerlink" title="克隆现有的仓库"></a>克隆现有的仓库</h2><p>如果你想获得一分已经存在了的git仓库的拷贝，这时就要用到<code>git clone</code>命令。如果你对其他的VCS系统(Subversion)很熟悉,请留心一下你所使用命令是<code>clone</code>而不是<code>checkout</code>。这是git区别于其他版本控制系统的一个重要特性，git克隆的是该git仓库服务器上的几乎所有数据，而不是仅仅复制完成你的工作所需要的文件。当你执行<code>git clone</code>命令的时候，默认配置下远程git仓库中每一个文件的每一个版本都将被拉下来。事实上，如果你的服务器的磁盘坏掉了，你通常可以使用任何一个克隆下来的用户端来重建服务器上的仓库<br>克隆仓库的命令格式<code>git colne [url]</code>,比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/isoot/isoot.github.io.git</div></pre></td></tr></table></figure></p>
<p>这是就会在当前目录下传建一个名为”isoot.github.is”的目录，并在这个目录下初始化一个.git文件夹，从远程仓库拉取下所有的数据放入<code>.git</code>文件夹，然后从中读取最新版本的文件拷贝。如果你进入这个新建的<code>isoot.github.io</code>文件夹，你会发现所有的项目文件已经在里面了，准备就绪等待后续的开发和使用。如果你想在克隆远程仓库的时候，自定义本地仓库名字，你可以使用如下命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/isoot/isoot.github.io.git myFile</div></pre></td></tr></table></figure></p>
<p>这将执行与上一个命令相同的操作，不过早本地创建一个仓库名字变为<code>myFile</code></p>
<p>git支持对中数据传输协议。上面的列子使用的是<code>https://</code>协议，不过你也可以使用<code>git://</code>协议或者使用SSH传输协议，比如<code>user@server:path/to/repo.git</code></p>
<h1 id="记录每次更新到仓库"><a href="#记录每次更新到仓库" class="headerlink" title="记录每次更新到仓库"></a>记录每次更新到仓库</h1><p>现在我们手上有了一个真实项目的git仓库，并从这个仓库中取出所有文件的工作拷贝。接下来，对这些文件做些修改，在完成了一个阶段的目标之后，提交本次跟新到仓库。<br>请记住，你的工作目录下的每一个文件都不外乎两种状态：已跟踪或未跟踪。已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于未修改状态，已修改或已放入暂存区。工作目录中除已跟踪文件以外的所有其他文件都属于未跟踪文件，它们即不存在于上次快照的记录中，也没有放入暂缓区。初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态。<br>编辑过某些文件之后，由于自上次提交后你对对它们作了修改，git将它们标记为已修改文件。我们逐步将这些修改过的文件放入暂缓区，然后提交所有暂缓了的修改，如痴反复。所以使用git时文件的生命周期如下:<br><img src="../image/gitImage/lifecycle.png" alt=""></p>
<h2 id="检查当前文件状态"><a href="#检查当前文件状态" class="headerlink" title="检查当前文件状态"></a>检查当前文件状态</h2><p>要查看哪些文件处于什么状态，可以用命令<code>git status</code>命令。如果在克隆仓库后立即使用此命令，会看到类似这样的输出:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git status</div><div class="line">On branch master</div><div class="line">nothing to commit,working directory clean</div></pre></td></tr></table></figure></p>
<p>这说明你现在的工作目录相当干净。换句话说，所有已跟踪文件在上次提交后都未被改过。此外，上面的信息还表明，当前目录没有出现任何处于跟踪状态的新文件，否则git会在这里列出来。最后，改命令还显示了当前所在的分支，并告诉你这个分支同远程服务器上对应的分支没有偏离。现在，分支名是“master”,这是默认的分支名。<br>现在，让我们在项目下创建一个新的README文件。如果之前并不存在这个文件，请使用<code>git status</code>命令，你将看到一个新的未跟踪文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ echo &apos;My Project&apos; &gt; README</div><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">Untracked files:</div><div class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</div><div class="line"></div><div class="line">    README</div><div class="line"></div><div class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</div></pre></td></tr></table></figure></p>
<p>在状态报告中可以看到新建的README文件出现在<code>Untracked files</code>下面。未跟踪的文件意味着git在之前的快照(提交)中没有这些文件;git不会自动将之纳入跟踪范围，除非你明明白白地告诉它”我需要跟踪改文件”，这样的处理让你不必担心生成二进制文件或其它被跟踪的的文件包含进来。不过现有的列子中，我们确实要跟踪管理README这个文件。</p>
<h2 id="跟踪新文件"><a href="#跟踪新文件" class="headerlink" title="跟踪新文件"></a>跟踪新文件</h2><p>使用命令<code>git add</code>开始跟踪一个文件。所以，要跟踪README文件，运行:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git add README</div></pre></td></tr></table></figure></p>
<p>此时再运行<code>git status</code>命令，会看到README文件已被跟踪，并处于暂存状态:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">Changes to be committed:</div><div class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</div><div class="line"></div><div class="line">    new file:   README</div></pre></td></tr></table></figure></p>
<p>只要在<code>Changes to be committed</code>这一行下面的，就说明是已暂存状态。如果此时提交文件，那么该文件此时此刻的版本将被；留在历史记录中。你可能会想起之前我们使用<code>git init</code>后就运行了<code>git add (files)</code>命令，开始跟踪当前目录下的文件。<code>git add</code>命令使用文件或目录的路径最为参数；如果参数是目录的路径，该命令就递归地跟踪该目录下的所有文件。</p>
<h2 id="暂存已修改文件"><a href="#暂存已修改文件" class="headerlink" title="暂存已修改文件"></a>暂存已修改文件</h2><p>现在我们来修改一个已被跟踪的文件。如果你修改了一个名为<code>CONTRIBUTING.md</code>的已经被跟踪的文件，然后运行<code>git status</code>命令，会看到下面内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">Changes to be committed:</div><div class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</div><div class="line"></div><div class="line">    new file:   README</div><div class="line"></div><div class="line">Changes not staged for commit:</div><div class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</div><div class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</div><div class="line"></div><div class="line">    modified:   CONTRIBUTING.md</div></pre></td></tr></table></figure></p>
<p>文件<code>CONTRIBUTING.md</code>出现在<code>Changes not staged for commit</code>这行下面，说明已跟踪文件的内容发生了变化了，但还没有放到暂存区。要暂存这次跟新，需要运行<code>git add</code>命令。这是一个多功能命令：可以用它开始跟踪新文件，或者吧已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。 将这个命令理解为“添加内容到下一次提交中”而不是“将一个文件添加到项目中”要更加合适。 现在让我们运行 git add 将”CONTRIBUTING.md”放到暂存区，然后再看看 <code>git status</code> 的输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ git add CONTRIBUTING.md</div><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">Changes to be committed:</div><div class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</div><div class="line"></div><div class="line">    new file:   README</div><div class="line">    modified:   CONTRIBUTING.md</div></pre></td></tr></table></figure></p>
<p>现在两个文件都已暂存，下次提交时就会一并记录到仓库。 假设此时，你想要在 <code>CONTRIBUTING.md</code> 里再加条注释， 重新编辑存盘后，准备好提交。 不过且慢，再运行 <code>git status</code> 看看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">$ vim CONTRIBUTING.md</div><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">Changes to be committed:</div><div class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</div><div class="line"></div><div class="line">    new file:   README</div><div class="line">    modified:   CONTRIBUTING.md</div><div class="line"></div><div class="line">Changes not staged for commit:</div><div class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</div><div class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</div><div class="line"></div><div class="line">    modified:   CONTRIBUTING.md</div></pre></td></tr></table></figure></p>
<p>怎么回事？ 现在 <code>CONTRIBUTING.md</code> 文件同时出现在暂存区和非暂存区。 这怎么可能呢？ 好吧，实际上 Git 只不过暂存了你运行 <code>git add</code> 命令时的版本， 如果你现在提交，<code>CONTRIBUTING.md</code> 的版本是你最后一次运行 <code>git add</code> 命令时的那个版本，而不是你运行 <code>git commit</code> 时，在工作目录中的当前版本。 所以，运行了 <code>git add</code> 之后又作了修订的文件，需要重新运行 git add 把最新版本重新暂存起来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ git add CONTRIBUTING.md</div><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">Changes to be committed:</div><div class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</div><div class="line"></div><div class="line">    new file:   README</div><div class="line">    modified:   CONTRIBUTING.md</div></pre></td></tr></table></figure></p>
<h2 id="状态简览"><a href="#状态简览" class="headerlink" title="状态简览"></a>状态简览</h2><p><code>git status</code> 命令的输出十分详细，但其用语有些繁琐。 如果你使用 <code>git status -s</code> 命令或 <code>git status --short</code> 命令，你将得到一种更为紧凑的格式输出。 运行 <code>git status -s</code> ，状态报告输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ git status -s</div><div class="line"> M README</div><div class="line">MM Rakefile</div><div class="line">A  lib/git.rb</div><div class="line">M  lib/simplegit.rb</div><div class="line">?? LICENSE.txt</div></pre></td></tr></table></figure></p>
<p>新添加的未跟踪文件前面有 ?? 标记，新添加到暂存区中的文件前面有 A 标记，修改过的文件前面有 M 标记。 你可能注意到了 M 有两个可以出现的位置，出现在右边的 M 表示该文件被修改了但是还没放入暂存区，出现在靠左边的 M 表示该文件被修改了并放入了暂存区。 例如，上面的状态报告显示： README 文件在工作区被修改了但是还没有将修改后的文件放入暂存区,<code>lib/simplegit.rb</code> 文件被修改了并将修改后的文件放入了暂存区。 而 <code>Rakefile</code> 在工作区被修改并提交到暂存区后又在工作区中被修改了，所以在暂存区和工作区都有该文件被修改了的记录。</p>
<h2 id="lib-simplegit-rb"><a href="#lib-simplegit-rb" class="headerlink" title="lib/simplegit.rb"></a>lib/simplegit.rb</h2><p>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以创建一个名为 <code>.gitignore</code> 的文件，列出要忽略的文件模式。 来看一个实际的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ cat .gitignore</div><div class="line">*.[oa]</div><div class="line">*~</div></pre></td></tr></table></figure></p>
<p>第一行告诉 Git 忽略所有以 <code>.o</code> 或 <code>.a</code> 结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的。 第二行告诉 Git 忽略所有以波浪符（~）结尾的文件，许多文本编辑软件（比如 Emacs）都用这样的文件名保存副本。 此外，你可能还需要忽略 log，tmp 或者 pid 目录，以及自动生成的文档等等。 要养成一开始就设置好 .gitignore 文件的习惯，以免将来误提交这类无用的文件。<br>文件 <code>.gitignore</code> 的格式规范如下：</p>
<ul>
<li>所有空行或者以 <code>＃</code> 开头的行都会被 Git 忽略。</li>
<li>可以使用标准的 glob 模式匹配。</li>
<li>匹配模式可以以（<code>/</code>）开头防止递归。</li>
<li>匹配模式可以以（<code>/</code>）结尾指定目录。</li>
<li><p>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（<code>!</code>）取反。<br>所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。 星号（<code>*</code>）匹配零个或多个任意字符；<code>[abc]</code> 匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；问号（<code>?</code>）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 <code>[0-9]</code> 表示匹配所有 0 到 9 的数字）。 使用两个星号(<code>*</code>) 表示匹配任意中间目录，比如<code>a/**/z</code> 可以匹配 a/z, a/b/z 或 <code>a/b/c/z</code>等。</p>
<p>我们再看一个 .gitignore 文件的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"># no .a files</div><div class="line">*.a</div><div class="line"></div><div class="line"># but do track lib.a, even though you&apos;re ignoring .a files above</div><div class="line">!lib.a</div><div class="line"></div><div class="line"># only ignore the TODO file in the current directory, not subdir/TODO</div><div class="line">/TODO</div><div class="line"></div><div class="line"># ignore all files in the build/ directory</div><div class="line">build/</div><div class="line"></div><div class="line"># ignore doc/notes.txt, but not doc/server/arch.txt</div><div class="line">doc/*.txt</div><div class="line"></div><div class="line"># ignore all .pdf files in the doc/ directory</div><div class="line">doc/**/*.pdf</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="查看已暂存和未暂存的修改"><a href="#查看已暂存和未暂存的修改" class="headerlink" title="查看已暂存和未暂存的修改"></a>查看已暂存和未暂存的修改</h2><p>如果 <code>git status</code> 命令的输出对于你来说过于模糊，你想知道具体修改了什么地方，可以用 <code>git diff</code> 命令。 稍后我们会详细介绍 <code>git diff</code>，你可能通常会用它来回答这两个问题：当前做的哪些更新还没有暂存？ 有哪些更新已经暂存起来准备好了下次提交？ 尽管 <code>git status</code> 已经通过在相应栏下列出文件名的方式回答了这个问题，<code>git diff</code> 将通过文件补丁的格式显示具体哪些行发生了改变。</p>
<p>假如再次修改 <code>README</code> 文件后暂存，然后编辑 <code>CONTRIBUTING.md</code> 文件后先不暂存， 运行 <code>status</code> 命令将会看到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">Changes to be committed:</div><div class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</div><div class="line"></div><div class="line">    modified:   README</div><div class="line"></div><div class="line">Changes not staged for commit:</div><div class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</div><div class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</div><div class="line"></div><div class="line">    modified:   CONTRIBUTING.md</div></pre></td></tr></table></figure></p>
<p>要查看尚未暂存的文件更新了哪些部分，不加参数直接输入 <code>git diff</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">$ git diff</div><div class="line">diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md</div><div class="line">index 8ebb991..643e24f 100644</div><div class="line">--- a/CONTRIBUTING.md</div><div class="line">+++ b/CONTRIBUTING.md</div><div class="line">@@ -65,7 +65,8 @@ branch directly, things can get messy.</div><div class="line"> Please include a nice description of your changes when you submit your PR;</div><div class="line"> if we have to read the whole diff to figure out why you&apos;re contributing</div><div class="line"> in the first place, you&apos;re less likely to get feedback and have your change</div><div class="line">-merged in.</div><div class="line">+merged in. Also, split your changes into comprehensive chunks if your patch is</div><div class="line">+longer than a dozen lines.</div><div class="line"></div><div class="line"> If you are starting to work on a particular area, feel free to submit a PR</div><div class="line"> that highlights your work in progress (and note in the PR title that it&apos;s</div></pre></td></tr></table></figure></p>
<p>此命令比较的是工作目录中当前文件和暂存区域快照之间的差异， 也就是修改之后还没有暂存起来的变化内容。</p>
<p>若要查看已暂存的将要添加到下次提交里的内容，可以用 <code>git diff --cached</code> 命令。（Git 1.6.1 及更高版本还允许使用 <code>git diff --staged</code>，效果是相同的，但更好记些。）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ git diff --staged</div><div class="line">diff --git a/README b/README</div><div class="line">new file mode 100644</div><div class="line">index 0000000..03902a1</div><div class="line">--- /dev/null</div><div class="line">+++ b/README</div><div class="line">@@ -0,0 +1 @@</div><div class="line">+My Project</div></pre></td></tr></table></figure></p>
<p>请注意，<code>git diff</code> 本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动。 所以有时候你一下子暂存了所有更新过的文件后，运行 <code>git diff</code> 后却什么也没有，就是这个原因。</p>
<p>像之前说的，暂存 <code>CONTRIBUTING.md</code> 后再编辑，运行 <code>git status</code> 会看到暂存前后的两个版本。 如果我们的环境（终端输出）看起来如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">$ git add CONTRIBUTING.md</div><div class="line">$ echo &apos;# test line&apos; &gt;&gt; CONTRIBUTING.md</div><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">Changes to be committed:</div><div class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</div><div class="line"></div><div class="line">    modified:   CONTRIBUTING.md</div><div class="line"></div><div class="line">Changes not staged for commit:</div><div class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</div><div class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</div><div class="line"></div><div class="line">    modified:   CONTRIBUTING.md</div></pre></td></tr></table></figure></p>
<p>现在运行 <code>git diff</code> 看暂存前后的变化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ git diff</div><div class="line">diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md</div><div class="line">index 643e24f..87f08c8 100644</div><div class="line">--- a/CONTRIBUTING.md</div><div class="line">+++ b/CONTRIBUTING.md</div><div class="line">@@ -119,3 +119,4 @@ at the</div><div class="line"> ## Starter Projects</div><div class="line"></div><div class="line"> See our [projects list](https://github.com/libgit2/libgit2/blob/development/PROJECTS.md).</div><div class="line">+# test line</div></pre></td></tr></table></figure></p>
<p>然后用 <code>git diff --cached</code> 查看已经暂存起来的变化：（–staged 和 –cached 是同义词）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">$ git diff --cached</div><div class="line">diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md</div><div class="line">index 8ebb991..643e24f 100644</div><div class="line">--- a/CONTRIBUTING.md</div><div class="line">+++ b/CONTRIBUTING.md</div><div class="line">@@ -65,7 +65,8 @@ branch directly, things can get messy.</div><div class="line"> Please include a nice description of your changes when you submit your PR;</div><div class="line"> if we have to read the whole diff to figure out why you&apos;re contributing</div><div class="line"> in the first place, you&apos;re less likely to get feedback and have your change</div><div class="line">-merged in.</div><div class="line">+merged in. Also, split your changes into comprehensive chunks if your patch is</div><div class="line">+longer than a dozen lines.</div><div class="line"></div><div class="line"> If you are starting to work on a particular area, feel free to submit a PR</div><div class="line"> that highlights your work in progress (and note in the PR title that it&apos;s</div></pre></td></tr></table></figure></p>
<h2 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h2><p>现在的暂存区域已经准备妥当可以提交了。 在此之前，请一定要确认还有什么修改过的或新建的文件还没有 <code>git add</code> 过，否则提交的时候不会记录这些还没暂存起来的变化。 这些修改过的文件只保留在本地磁盘。 所以，每次准备提交前，先用 <code>git status</code> 看下，是不是都已暂存起来了， 然后再运行提交命令 <code>git commit：</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git commit</div></pre></td></tr></table></figure></p>
<p>这种方式会启动文本编辑器以便输入本次提交的说明。 (默认会启用 shell 的环境变量 <code>$EDITOR</code> 所指定的软件，一般都是 vim 或 emacs。当然也可以按照 起步 介绍的方式，使用 <code>git config --global core.editor</code> 命令设定你喜欢的编辑软件。）<br>编辑器会显示类似下面的文本信息（本例选用 Vim 的屏显方式展示）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># Please enter the commit message for your changes. Lines starting</div><div class="line"># with &apos;#&apos; will be ignored, and an empty message aborts the commit.</div><div class="line"># On branch master</div><div class="line"># Changes to be committed:</div><div class="line">#	new file:   README</div><div class="line">#	modified:   CONTRIBUTING.md</div><div class="line">#</div><div class="line">~</div><div class="line">~</div><div class="line">~</div><div class="line">&quot;.git/COMMIT_EDITMSG&quot; 9L, 283C</div></pre></td></tr></table></figure></p>
<p>可以看到，默认的提交消息包含最后一次运行 <code>git status</code> 的输出，放在注释行里，另外开头还有一空行，供你输入提交说明。 你完全可以去掉这些注释行，不过留着也没关系，多少能帮你回想起这次更新的内容有哪些。 (如果想要更详细的对修改了哪些内容的提示，可以用 <code>-v</code> 选项，这会将你所做的改变的 diff 输出放到编辑器中从而使你知道本次提交具体做了哪些修改。） 退出编辑器时，Git 会丢掉注释行，用你输入提交附带信息生成一次提交。</p>
<p>另外，你也可以在 <code>commit</code> 命令后添加 <code>-m</code> 选项，将提交信息与命令放在同一行，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git commit -m &quot;Story 182: Fix benchmarks for speed&quot;</div><div class="line">[master 463dc4f] Story 182: Fix benchmarks for speed</div><div class="line"> 2 files changed, 2 insertions(+)</div><div class="line"> create mode 100644 README</div></pre></td></tr></table></figure></p>
<p>好，现在你已经创建了第一个提交！可以看到，提交之后他会告诉，当前在那个分支(master)提交的，本次提交的完整SHA-1校验值是什么(<code>463dc4f</code>),以及本次提交中，对少文件修订过，多少行添加和删除过。<br>请记住，提交是记录的放在暂存区域的快照。任何还未暂存的仍然保持已修改状态，可在下次提交时纳入版本管理。每一次运行提交操作，都是对你项目做一次快照，以后可以回到这个状态，或者进行比较。</p>
<h2 id="跳过使用暂存区域"><a href="#跳过使用暂存区域" class="headerlink" title="跳过使用暂存区域"></a>跳过使用暂存区域</h2><p>尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。git提供了一个跳过使用暂存区域的方式，只要在提交的时候，给<code>git commit</code>加上<code>-a</code>选项，git就会自动把所有已经跟踪过得文件咱存起来一并提交，从而跳过<code>git add</code>步骤：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">Changes not staged for commit:</div><div class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</div><div class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</div><div class="line"></div><div class="line">    modified:   CONTRIBUTING.md</div><div class="line"></div><div class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</div><div class="line">$ git commit -a -m &apos;added new benchmarks&apos;</div><div class="line">[master 83e38c7] added new benchmarks</div><div class="line"> 1 file changed, 5 insertions(+), 0 deletions(-)</div></pre></td></tr></table></figure></p>
<p>看到了吗？提交之前不再需要<code>git add</code>文件</p>
<h2 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h2><p>要从git中移除某个文件，就必须要从已跟踪文件清单中移除(确切滴说，是从暂存区域移除)，然后提交。可以用<code>git rm</code>命令完成此项工作，并连带从工作目录删除指定文件，这昂以后就不会出现在未跟踪文件清单中了，</p>
<p>如果只是简单地从工作目录中手工删除文件，运行<code>git status</code>时就会在<code>Changes not staged for commit</code>部分(也就是 未暂存清单)看到:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ rm PROJECTS.md</div><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">Your branch is up-to-date with &apos;origin/master&apos;.</div><div class="line">Changes not staged for commit:</div><div class="line">  (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)</div><div class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</div><div class="line"></div><div class="line">        deleted:    PROJECTS.md</div><div class="line"></div><div class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</div></pre></td></tr></table></figure></p>
<p>然后在运行<code>git rm</code>记录此次移除文件的操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ git rm PROJECTS.md</div><div class="line">rm &apos;PROJECTS.md&apos;</div><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">Changes to be committed:</div><div class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</div><div class="line"></div><div class="line">    deleted:    PROJECTS.md</div></pre></td></tr></table></figure></p>
<p>下一次提交时，该文件就不再纳入版本管理了。如果删除之前修改过并且已经放在暂存区域的话，则必须要用强制删除选项<code>-f</code>(译注:即force的首字母).这是一种安全特性，用于防止误删还没有添加到快照的数据，这样的数据不能被git恢复。<br>另外一种情况，我们想要把文件从git仓库中删除(亦即从暂存区域移除)，但仍然希望保留在当前工作目录中。换句话说，你想让文件保留在磁盘，danshibingbuxiangranggit继续跟踪。当你忘记添加<code>.gitignore</code>文件，不小心吧一个很大的日志文件或一对<code>.a</code>这样的编译生成文件添加到暂存区时，这一做法尤其有用。未到达这一目的，使用<code>--cached</code>选项：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git rm --cached README</div></pre></td></tr></table></figure></p>
<p><code>git rm</code>命令后面可以列出文件或者目录的名字，也可以使用<code>glob</code>模式。比方说:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git rm log/\*.log</div></pre></td></tr></table></figure></p>
<p>主意到星号<code>*</code>之前的反斜杠<code>\</code>，因为git有他自己的文件模式扩展匹配方式，说以我们不用shell来帮忙暂开。此命令删除<code>log/</code>目录下扩展名为<code>.log</code>的所有文件。<br>类似的比如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git rm \*~</div></pre></td></tr></table></figure></p>
<p>该命令为删除以<code>~</code>结尾的所所有文件.</p>
<h2 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h2><p>不想其他的VCS系统，git并不显示跟踪文件移动操作。如果在git中重命名了某个文件，仓库中暂存的元数据并不会体现出这是一次改名操作。不过git非常聪明，他会推断出究竟发生了什么，至于具体是如何做到的，我们稍后再谈。<br>既然如此，当你看到git的<code>mv</code>命令时一定会困惑不已。要在git中对文件改名，可以这么做:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git mv file_from file_to</div></pre></td></tr></table></figure></p>
<p>他会恰如预期般正常工作。实际上，即便如此查看状态信息，也会明白无误地拉姆岛关于重命名操作的说明:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ git mv README.md README</div><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">Changes to be committed:</div><div class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</div><div class="line"></div><div class="line">    renamed:    README.md -&gt; README</div></pre></td></tr></table></figure></p>
<p>其实，运行<code>git mv</code>就相当于运行了下面三条命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ mv README.md README</div><div class="line">$ git rm README.md</div><div class="line">$ git add README</div></pre></td></tr></table></figure></p>
<p>如此分开操作，git也会意识到这是一次改名，所有不管任何方式结果都市一样。两种唯区别是，<code>mv</code>是一条命令而另外一种方式需要三条命令，直接用<code>git mv</code>轻便很多。不过有时候其他工具批处理改名的话，要记得在提交前删除老的文件名，再添加新的文件名。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/10/26/git基础/" data-id="cj9hvgx3j0008l4lfjgeqxsfm" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/11/01/git-查看提交历史/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          git 查看提交历史
        
      </div>
    </a>
  
  
    <a href="/2017/10/25/title/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">title</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/11/02/git-分支简介/">git 分支简介</a>
          </li>
        
          <li>
            <a href="/2017/11/02/git-别名/">git 别名</a>
          </li>
        
          <li>
            <a href="/2017/11/02/git-打标签/">git 打标签</a>
          </li>
        
          <li>
            <a href="/2017/11/02/git-远程创库的使用/">git 远程创库的使用</a>
          </li>
        
          <li>
            <a href="/2017/11/02/git-撤销操作/">git 撤销操作</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>