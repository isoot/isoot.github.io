<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[git 工具 - 子模块]]></title>
    <url>%2F2017%2F11%2F06%2Fgit-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[有种情况我们经常会遇到：某个工作中的项目需要包含并使用另一个项目。 也许是第三方库，或者你独立开发的，用于多个父项目的库。 现在问题来了：你想要把它们当做两个独立的项目，同时又想在一个项目中使用另一个。 我们举一个例子。 假设你正在开发一个网站然后创建了 Atom 订阅。 你决定使用一个库，而不是写自己的 Atom 生成代码。 你可能不得不通过 CPAN 安装或 Ruby gem 来包含共享库中的代码，或者将源代码直接拷贝到自己的项目中。 如果将这个库包含进来，那么无论用何种方式都很难定制它，部署则更加困难，因为你必须确保每一个客户端都包含该库。 如果将代码复制到自己的项目中，那么你做的任何自定义修改都会使合并上游的改动变得困难。 Git 通过子模块来解决这个问题。 子模块允许你将一个 Git 仓库作为另一个 Git 仓库的子目录。 它能让你将另一个仓库克隆到自己的项目中，同时还保持提交的独立。 开始使用子模块我们将要演示如何在一个被分成一个主项目与几个子项目的项目上开发。 我们首先将一个已存在的 Git 仓库添加为正在工作的仓库的子模块。 你可以通过在 git submodule add 命令后面加上想要跟踪的项目 URL 来添加新的子模块。 在本例中，我们将会添加一个名为 “DbConnector” 的库。1234567$ git submodule add https://github.com/chaconinc/DbConnectorCloning into &apos;DbConnector&apos;...remote: Counting objects: 11, done.remote: Compressing objects: 100% (10/10), done.remote: Total 11 (delta 0), reused 11 (delta 0)Unpacking objects: 100% (11/11), done.Checking connectivity... done. 默认情况下，子模块会将子项目放到一个与仓库同名的目录中，本例中是 “DbConnector”。 如果你想要放到其他地方，那么可以在命令结尾添加一个不同的路径。 如果这时运行 git status，你会注意到几件事。123456789$ git statusOn branch masterYour branch is up-to-date with &apos;origin/master&apos;.Changes to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: .gitmodules new file: DbConnector 首先应当注意到新的 .gitmodules 文件。 该配置文件保存了项目 URL 与已经拉取的本地目录之间的映射：1234$ cat .gitmodules[submodule &quot;DbConnector&quot;] path = DbConnector url = https://github.com/chaconinc/DbConnector 如果有多个子模块，该文件中就会有多条记录。 要重点注意的是，该文件也像 .gitignore 文件一样受到（通过）版本控制。 它会和该项目的其他部分一同被拉取推送。 这就是克隆该项目的人知道去哪获得子模块的原因 由于 .gitmodules 文件中的 URL 是人们首先尝试克隆/拉取的地方，因此请尽可能确保你使用的URL 大家都能访问。 例如，若你要使用的推送 URL 与他人的拉取 URL 不同，那么请使用他人能访问到的 URL。 你也可以根据自己的需要，通过在本地执行git config submodule.DbConnector.url &lt;私有URL&gt; 来覆盖这个选项的值。 如果可行的话，一个相对路径会很有帮助。在 git status 输出中列出的另一个是项目文件夹记录。 如果你运行 git diff，会看到类似下面的信息：12345678$ git diff --cached DbConnectordiff --git a/DbConnector b/DbConnectornew file mode 160000index 0000000..c3f01dc--- /dev/null+++ b/DbConnector@@ -0,0 +1 @@+Subproject commit c3f01dc8862123d317dd46284b05b6892c7b29bc 虽然 DbConnector 是工作目录中的一个子目录，但 Git 还是会将它视作一个子模块。当你不在那个目录中时，Git 并不会跟踪它的内容， 而是将它看作该仓库中的一个特殊提交。 如果你想看到更漂亮的差异输出，可以给 git diff 传递 --submodule 选项。1234567891011$ git diff --cached --submodulediff --git a/.gitmodules b/.gitmodulesnew file mode 100644index 0000000..71fc376--- /dev/null+++ b/.gitmodules@@ -0,0 +1,3 @@+[submodule &quot;DbConnector&quot;]+ path = DbConnector+ url = https://github.com/chaconinc/DbConnectorSubmodule DbConnector 0000000...c3f01dc (new submodule) 当你提交时，会看到类似下面的信息：12345$ git commit -am &apos;added DbConnector module&apos;[master fb9093c] added DbConnector module 2 files changed, 4 insertions(+) create mode 100644 .gitmodules create mode 160000 DbConnector 注意 DbConnector 记录的 160000 模式。 这是 Git 中的一种特殊模式，它本质上意味着你是将一次提交记作一项目录记录的，而非将它记录成一个子目录或者一个文件。 克隆含有子模块的项目接下来我们将会克隆一个含有子模块的项目。 当你在克隆这样的项目时，默认会包含该子模块目录，但其中还没有任何文件：12345678910111213141516171819202122$ git clone https://github.com/chaconinc/MainProjectCloning into &apos;MainProject&apos;...remote: Counting objects: 14, done.remote: Compressing objects: 100% (13/13), done.remote: Total 14 (delta 1), reused 13 (delta 0)Unpacking objects: 100% (14/14), done.Checking connectivity... done.$ cd MainProject$ ls -latotal 16drwxr-xr-x 9 schacon staff 306 Sep 17 15:21 .drwxr-xr-x 7 schacon staff 238 Sep 17 15:21 ..drwxr-xr-x 13 schacon staff 442 Sep 17 15:21 .git-rw-r--r-- 1 schacon staff 92 Sep 17 15:21 .gitmodulesdrwxr-xr-x 2 schacon staff 68 Sep 17 15:21 DbConnector-rw-r--r-- 1 schacon staff 756 Sep 17 15:21 Makefiledrwxr-xr-x 3 schacon staff 102 Sep 17 15:21 includesdrwxr-xr-x 4 schacon staff 136 Sep 17 15:21 scriptsdrwxr-xr-x 4 schacon staff 136 Sep 17 15:21 src$ cd DbConnector/$ ls$ 其中有 DbConnector 目录，不过是空的。 你必须运行两个命令：git submodule init 用来初始化本地配置文件，而 git submodule update 则从该项目中抓取所有数据并检出父项目中列出的合适的提交。12345678910$ git submodule initSubmodule &apos;DbConnector&apos; (https://github.com/chaconinc/DbConnector) registered for path &apos;DbConnector&apos;$ git submodule updateCloning into &apos;DbConnector&apos;...remote: Counting objects: 11, done.remote: Compressing objects: 100% (10/10), done.remote: Total 11 (delta 0), reused 11 (delta 0)Unpacking objects: 100% (11/11), done.Checking connectivity... done.Submodule path &apos;DbConnector&apos;: checked out &apos;c3f01dc8862123d317dd46284b05b6892c7b29bc&apos; 现在 DbConnector 子目录是处在和之前提交时相同的状态了。 不过还有更简单一点的方式。 如果给 git clone 命令传递 --recursive 选项，它就会自动初始化并更新仓库中的每一个子模块。123456789101112131415$ git clone --recursive https://github.com/chaconinc/MainProjectCloning into &apos;MainProject&apos;...remote: Counting objects: 14, done.remote: Compressing objects: 100% (13/13), done.remote: Total 14 (delta 1), reused 13 (delta 0)Unpacking objects: 100% (14/14), done.Checking connectivity... done.Submodule &apos;DbConnector&apos; (https://github.com/chaconinc/DbConnector) registered for path &apos;DbConnector&apos;Cloning into &apos;DbConnector&apos;...remote: Counting objects: 11, done.remote: Compressing objects: 100% (10/10), done.remote: Total 11 (delta 0), reused 11 (delta 0)Unpacking objects: 100% (11/11), done.Checking connectivity... done.Submodule path &apos;DbConnector&apos;: checked out &apos;c3f01dc8862123d317dd46284b05b6892c7b29bc&apos; 在包含子模块的项目上工作现在我们有一份包含子模块的项目副本，我们将会同时在主项目和子模块项目上与队员协作。 拉取上游修改在项目中使用子模块的最简模型，就是只使用子项目并不时地获取更新，而并不在你的检出中进行任何更改。 我们来看一个简单的例子。 如果想要在子模块中查看新工作，可以进入到目录中运行 git fetch 与 git merge，合并上游分支来更新本地代码。123456789$ git fetchFrom https://github.com/chaconinc/DbConnector c3f01dc..d0354fc master -&gt; origin/master$ git merge origin/masterUpdating c3f01dc..d0354fcFast-forward scripts/connect.sh | 1 + src/db.c | 1 + 2 files changed, 2 insertions(+) 如果你现在返回到主项目并运行 git diff --submodule，就会看到子模块被更新的同时获得了一个包含新添加提交的列表。 如果你不想每次运行 git diff 时都输入 --submodle，那么可以将 diff.submodule 设置为 “log” 来将其作为默认行为。12345$ git config --global diff.submodule log$ git diffSubmodule DbConnector c3f01dc..d0354fc: &gt; more efficient db routine &gt; better connection routine 如果在此时提交，那么你会将子模块锁定为其他人更新时的新代码。 如果你不想在子目录中手动抓取与合并，那么还有种更容易的方式。 运行 git submodule update --remote，Git 将会进入子模块然后抓取并更新。12345678$ git submodule update --remote DbConnectorremote: Counting objects: 4, done.remote: Compressing objects: 100% (2/2), done.remote: Total 4 (delta 2), reused 4 (delta 2)Unpacking objects: 100% (4/4), done.From https://github.com/chaconinc/DbConnector 3f19983..d0354fc master -&gt; origin/masterSubmodule path &apos;DbConnector&apos;: checked out &apos;d0354fc054692d3906c85c3af05ddce39a1c0644&apos; 此命令默认会假定你想要更新并检出子模块仓库的 master 分支。 不过你也可以设置为想要的其他分支。 例如，你想要 DbConnector 子模块跟踪仓库的 “stable” 分支，那么既可以在 .gitmodules 文件中设置（这样其他人也可以跟踪它），也可以只在本地的 .git/config 文件中设置。 让我们在 .gitmodules 文件中设置它：12345678910$ git config -f .gitmodules submodule.DbConnector.branch stable$ git submodule update --remoteremote: Counting objects: 4, done.remote: Compressing objects: 100% (2/2), done.remote: Total 4 (delta 2), reused 4 (delta 2)Unpacking objects: 100% (4/4), done.From https://github.com/chaconinc/DbConnector 27cf5d3..c87d55d stable -&gt; origin/stableSubmodule path &apos;DbConnector&apos;: checked out &apos;c87d55d4c6d4b05ee34fbc8cb6f7bf4585ae6687&apos; 如果不用 -f .gitmodules 选项，那么它只会为你做修改。但是在仓库中保留跟踪信息更有意义一些，因为其他人也可以得到同样的效果。 这时我们运行 git status，Git 会显示子模块中有 “新提交”。123456789101112$ git statusOn branch masterYour branch is up-to-date with &apos;origin/master&apos;.Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: .gitmodules modified: DbConnector (new commits)no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 如果你设置了配置选项 status.submodulesummary，Git 也会显示你的子模块的更改摘要：1234567891011121314151617$ git config status.submodulesummary 1$ git statusOn branch masterYour branch is up-to-date with &apos;origin/master&apos;.Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: .gitmodules modified: DbConnector (new commits)Submodules changed but not updated:* DbConnector c3f01dc...c87d55d (4): &gt; catch non-null terminated lines 这时如果运行 git diff，可以看到我们修改了 .gitmodules 文件，同时还有几个已拉取的提交需要提交到我们自己的子模块项目中。123456789101112131415$ git diffdiff --git a/.gitmodules b/.gitmodulesindex 6fc0b3d..fd1cc29 100644--- a/.gitmodules+++ b/.gitmodules@@ -1,3 +1,4 @@ [submodule &quot;DbConnector&quot;] path = DbConnector url = https://github.com/chaconinc/DbConnector+ branch = stable Submodule DbConnector c3f01dc..c87d55d: &gt; catch non-null terminated lines &gt; more robust error handling &gt; more efficient db routine &gt; better connection routine 这非常有趣，因为我们可以直接看到将要提交到子模块中的提交日志。 提交之后，你也可以运行 git log -p 查看这个信息。123456789101112131415161718192021$ git log -p --submodulecommit 0a24cfc121a8a3c118e0105ae4ae4c00281cf7aeAuthor: Scott Chacon &lt;schacon@gmail.com&gt;Date: Wed Sep 17 16:37:02 2014 +0200 updating DbConnector for bug fixesdiff --git a/.gitmodules b/.gitmodulesindex 6fc0b3d..fd1cc29 100644--- a/.gitmodules+++ b/.gitmodules@@ -1,3 +1,4 @@ [submodule &quot;DbConnector&quot;] path = DbConnector url = https://github.com/chaconinc/DbConnector+ branch = stableSubmodule DbConnector c3f01dc..c87d55d: &gt; catch non-null terminated lines &gt; more robust error handling &gt; more efficient db routine &gt; better connection routine 当运行 git submodule update --remote 时，Git 默认会尝试更新所有子模块，所以如果有很多子模块的话，你可以传递想要更新的子模块的名字。 在子模块上工作你很有可能正在使用子模块，因为你确实想在子模块中编写代码的同时，还想在主项目上编写代码（或者跨子模块工作）。 否则你大概只能用简单的依赖管理系统（如 Maven 或 Rubygems）来替代了。 现在我们将通过一个例子来演示如何在子模块与主项目中同时做修改，以及如何同时提交与发布那些修改。 到目前为止，当我们运行 git submodule update 从子模块仓库中抓取修改时，Git 将会获得这些改动并更新子目录中的文件，但是会将子仓库留在一个称作 “游离的 HEAD” 的状态。 这意味着没有本地工作分支（例如 “master”）跟踪改动。 所以你做的任何改动都不会被跟踪。 为了将子模块设置得更容易进入并修改，你需要做两件事。 首先，进入每个子模块并检出其相应的工作分支。 接着，若你做了更改就需要告诉 Git 它该做什么，然后运行 git submodule update --remote 来从上游拉取新工作。 你可以选择将它们合并到你的本地工作中，也可以尝试将你的工作变基到新的更改上。 首先，让我们进入子模块目录然后检出一个分支。 $ git checkout stableSwitched to branch ‘stable’然后尝试用 “merge” 选项。 为了手动指定它，我们只需给 update 添加 --merge 选项即可。 这时我们将会看到服务器上的这个子模块有一个改动并且它被合并了进来。123456789101112$ git submodule update --remote --mergeremote: Counting objects: 4, done.remote: Compressing objects: 100% (2/2), done.remote: Total 4 (delta 2), reused 4 (delta 2)Unpacking objects: 100% (4/4), done.From https://github.com/chaconinc/DbConnector c87d55d..92c7337 stable -&gt; origin/stableUpdating c87d55d..92c7337Fast-forward src/main.c | 1 + 1 file changed, 1 insertion(+)Submodule path &apos;DbConnector&apos;: merged in &apos;92c7337b30ef9e0893e758dac2459d07362ab5ea&apos; 如果我们进入 DbConnector 目录，可以发现新的改动已经合并入本地 stable 分支。 现在让我们看看当我们对库做一些本地的改动而同时其他人推送另外一个修改到上游时会发生什么。12345$ cd DbConnector/$ vim src/db.c$ git commit -am &apos;unicode support&apos;[stable f906e16] unicode support 1 file changed, 1 insertion(+) 如果我们现在更新子模块，就会看到当我们在本地做了更改时上游也有一个改动，我们需要将它并入本地。1234$ git submodule update --remote --rebaseFirst, rewinding head to replay your work on top of it...Applying: unicode supportSubmodule path &apos;DbConnector&apos;: rebased into &apos;5d60ef9bbebf5a0c1c1050f242ceeb54ad58da94&apos; 如果你忘记 --rebase 或 --merge，Git 会将子模块更新为服务器上的状态。并且会将项目重置为一个游离的 HEAD 状态。 $ git submodule update –remoteSubmodule path ‘DbConnector’: checked out ‘5d60ef9bbebf5a0c1c1050f242ceeb54ad58da94’即便这真的发生了也不要紧，你只需回到目录中再次检出你的分支（即还包含着你的工作的分支）然后手动地合并或变基 origin/stable（或任何一个你想要的远程分支）就行了。 如果你没有提交子模块的改动，那么运行一个子模块更新也不会出现问题，此时 Git 会只抓取更改而并不会覆盖子模块目录中未保存的工作。123456789101112$ git submodule update --remoteremote: Counting objects: 4, done.remote: Compressing objects: 100% (3/3), done.remote: Total 4 (delta 0), reused 4 (delta 0)Unpacking objects: 100% (4/4), done.From https://github.com/chaconinc/DbConnector 5d60ef9..c75e92a stable -&gt; origin/stableerror: Your local changes to the following files would be overwritten by checkout: scripts/setup.shPlease, commit your changes or stash them before you can switch branches.AbortingUnable to checkout &apos;c75e92a2b3855c9e5b66f915308390d9db204aca&apos; in submodule path &apos;DbConnector&apos; 如果你做了一些与上游改动冲突的改动，当运行更新时 Git 会让你知道。123456$ git submodule update --remote --mergeAuto-merging scripts/setup.shCONFLICT (content): Merge conflict in scripts/setup.shRecorded preimage for &apos;scripts/setup.sh&apos;Automatic merge failed; fix conflicts and then commit the result.Unable to merge &apos;c75e92a2b3855c9e5b66f915308390d9db204aca&apos; in submodule path &apos;DbConnector&apos; 你可以进入子模块目录中然后就像平时那样修复冲突。 发布子模块改动现在我们的子模块目录中有一些改动。 其中有一些是我们通过更新从上游引入的，而另一些是本地生成的，由于我们还没有推送它们，所以对任何其他人都不可用。1234567$ git diffSubmodule DbConnector c87d55d..82d2ad3: &gt; Merge from origin/stable &gt; updated setup script &gt; unicode support &gt; remove unnecessary method &gt; add new option for conn pooling 如果我们在主项目中提交并推送但并不推送子模块上的改动，其他尝试检出我们修改的人会遇到麻烦，因为他们无法得到依赖的子模块改动。 那些改动只存在于我们本地的拷贝中。 为了确保这不会发生，你可以让 Git 在推送到主项目前检查所有子模块是否已推送。 git push 命令接受可以设置为 “check” 或 “on-demand” 的 --recurse-submodules 参数。 如果任何提交的子模块改动没有推送那么 “check” 选项会直接使 push 操作失败。1234567891011121314$ git push --recurse-submodules=checkThe following submodule paths contain changes that cannot be found on any remote: DbConnectorPlease try git push --recurse-submodules=on-demandor cd to the path and use git pushto push them to a remote. 如你所见，它也给我们了一些有用的建议，指导接下来该如何做。 最简单的选项是进入每一个子模块中然后手动推送到远程仓库，确保它们能被外部访问到，之后再次尝试这次推送。 另一个选项是使用 “on-demand” 值，它会尝试为你这样做。12345678910111213141516$ git push --recurse-submodules=on-demandPushing submodule &apos;DbConnector&apos;Counting objects: 9, done.Delta compression using up to 8 threads.Compressing objects: 100% (8/8), done.Writing objects: 100% (9/9), 917 bytes | 0 bytes/s, done.Total 9 (delta 3), reused 0 (delta 0)To https://github.com/chaconinc/DbConnector c75e92a..82d2ad3 stable -&gt; stableCounting objects: 2, done.Delta compression using up to 8 threads.Compressing objects: 100% (2/2), done.Writing objects: 100% (2/2), 266 bytes | 0 bytes/s, done.Total 2 (delta 1), reused 0 (delta 0)To https://github.com/chaconinc/MainProject 3d6d338..9a377d1 master -&gt; master 如你所见，Git 进入到 DbConnector 模块中然后在推送主项目前推送了它。 如果那个子模块因为某些原因推送失败，主项目也会推送失败。 合并子模块改动如果你其他人同时改动了一个子模块引用，那么可能会遇到一些问题。 也就是说，如果子模块的历史已经分叉并且在父项目中分别提交到了分叉的分支上，那么你需要做一些工作来修复它。 如果一个提交是另一个的直接祖先（一个快进式合并），那么 Git 会简单地选择之后的提交来合并，这样没什么问题。 不过，Git 甚至不会尝试去进行一次简单的合并。 如果子模块提交已经分叉且需要合并，那你会得到类似下面的信息：123456789101112$ git pullremote: Counting objects: 2, done.remote: Compressing objects: 100% (1/1), done.remote: Total 2 (delta 1), reused 2 (delta 1)Unpacking objects: 100% (2/2), done.From https://github.com/chaconinc/MainProject 9a377d1..eb974f8 master -&gt; origin/masterFetching submodule DbConnectorwarning: Failed to merge submodule DbConnector (merge following commits not found)Auto-merging DbConnectorCONFLICT (submodule): Merge conflict in DbConnectorAutomatic merge failed; fix conflicts and then commit the result. 所以本质上 Git 在这里指出了子模块历史中的两个分支记录点已经分叉并且需要合并。 它将其解释为 “merge following commits not found”（未找到接下来需要合并的提交），虽然这有点令人困惑，不过之后我们会解释为什么是这样。 为了解决这个问题，你需要弄清楚子模块应该处于哪种状态。 奇怪的是，Git 并不会给你多少能帮你摆脱困境的信息，甚至连两边提交历史中的 SHA-1 值都没有。 幸运的是，这很容易解决。 如果你运行 git diff，就会得到试图合并的两个分支中记录的提交的 SHA-1 值。12345$ git diffdiff --cc DbConnectorindex eb41d76,c771610..0000000--- a/DbConnector+++ b/DbConnector 所以，在本例中，eb41d76 是我们的子模块中大家共有的提交，而 c771610 是上游拥有的提交。 如果我们进入子模块目录中，它应该已经在 eb41d76 上了，因为合并没有动过它。 如果不是的话，无论什么原因，你都可以简单地创建并检出一个指向它的分支。 来自另一边的提交的 SHA-1 值比较重要。 它是需要你来合并解决的。 你可以尝试直接通过 SHA-1 合并，也可以为它创建一个分支然后尝试合并。 我们建议后者，哪怕只是为了一个更漂亮的合并提交信息。 所以，我们将会进入子模块目录，基于 git diff 的第二个 SHA 创建一个分支然后手动合并。1234567891011$ cd DbConnector$ git rev-parse HEADeb41d764bccf88be77aced643c13a7fa86714135$ git branch try-merge c771610(DbConnector) $ git merge try-mergeAuto-merging src/main.cCONFLICT (content): Merge conflict in src/main.cRecorded preimage for &apos;src/main.c&apos;Automatic merge failed; fix conflicts and then commit the result. 我们在这儿得到了一个真正的合并冲突，所以如果想要解决并提交它，那么只需简单地通过结果来更新主项目。1234567891011121314151617181920$ vim src/main.c (1)$ git add src/main.c$ git commit -am &apos;merged our changes&apos;Recorded resolution for &apos;src/main.c&apos;.[master 9fd905e] merged our changes$ cd .. (2)$ git diff (3)diff --cc DbConnectorindex eb41d76,c771610..0000000--- a/DbConnector+++ b/DbConnector@@@ -1,1 -1,1 +1,1 @@@- Subproject commit eb41d764bccf88be77aced643c13a7fa86714135 -Subproject commit c77161012afbbe1f58b5053316ead08f4b7e6d1d++Subproject commit 9fd905e5d7f45a0d4cbc43d1ee550f16a30e825a$ git add DbConnector (4)$ git commit -m &quot;Merge Tom&apos;s Changes&quot; (5)[master 10d2c60] Merge Tom&apos;s Changes 首先解决冲突 然后返回到主项目目录中 再次检查 SHA-1 值 解决冲突的子模块记录 提交我们的合并 有趣的是，Git 还能处理另一种情况。 如果子模块目录中存在着这样一个合并提交，它的历史中包含了的两边的提交，那么 Git 会建议你将它作为一个可行的解决方案。 它看到有人在子模块项目的某一点上合并了包含这两次提交的分支，所以你可能想要那个。 这就是为什么前面的错误信息是 “merge following commits not found”，因为它不能 这样 做。 它让人困惑是因为谁能想到它会尝试这样做？ 如果它找到了一个可以接受的合并提交，你会看到类似下面的信息：12345678910111213$ git merge origin/masterwarning: Failed to merge submodule DbConnector (not fast-forward)Found a possible merge resolution for the submodule: 9fd905e5d7f45a0d4cbc43d1ee550f16a30e825a: &gt; merged our changesIf this is correct simply add it to the index for exampleby using: git update-index --cacheinfo 160000 9fd905e5d7f45a0d4cbc43d1ee550f16a30e825a &quot;DbConnector&quot;which will accept this suggestion.Auto-merging DbConnectorCONFLICT (submodule): Merge conflict in DbConnectorAutomatic merge failed; fix conflicts and then commit the result. 它会建议你更新索引，就像你运行了 git add 那样，这样会清除冲突然后提交。不过你可能不应该这样做。你可以轻松地进入子模块目录，查看差异是什么，快进到这次提交，恰当地测试，然后提交它。12345678$ cd DbConnector/$ git merge 9fd905eUpdating eb41d76..9fd905eFast-forward$ cd ..$ git add DbConnector$ git commit -am &apos;Fast forwarded to a common submodule child&apos; 这些命令完成了同一件事，但是通过这种方式你至少可以验证工作是否有效，以及当你在完成时可以确保子模块目录中有你的代码。 子模块技巧你可以做几件事情来让用子模块工作轻松一点儿。 子模块遍历有一个 foreach 子模块命令，它能在每一个子模块中运行任意命令。 如果项目中包含了大量子模块，这会非常有用。 例如，假设我们想要开始开发一项新功能或者修复一些错误，并且需要在几个子模块内工作。 我们可以轻松地保存所有子模块的工作进度。123456$ git submodule foreach &apos;git stash&apos;Entering &apos;CryptoLibrary&apos;No local changes to saveEntering &apos;DbConnector&apos;Saved working directory and index state WIP on stable: 82d2ad3 Merge from origin/stableHEAD is now at 82d2ad3 Merge from origin/stable 然后我们可以创建一个新分支，并将所有子模块都切换过去。12345$ git submodule foreach &apos;git checkout -b featureA&apos;Entering &apos;CryptoLibrary&apos;Switched to a new branch &apos;featureA&apos;Entering &apos;DbConnector&apos;Switched to a new branch &apos;featureA&apos; 你应该明白。 能够生成一个主项目与所有子项目的改动的统一差异是非常有用的。1234567891011121314151617181920212223242526272829303132$ git diff; git submodule foreach &apos;git diff&apos;Submodule DbConnector contains modified contentdiff --git a/src/main.c b/src/main.cindex 210f1ae..1f0acdc 100644--- a/src/main.c+++ b/src/main.c@@ -245,6 +245,8 @@ static int handle_alias(int *argcp, const char ***argv) commit_pager_choice();+ url = url_decode(url_orig);+ /* build alias_argv */ alias_argv = xmalloc(sizeof(*alias_argv) * (argc + 1)); alias_argv[0] = alias_string + 1;Entering &apos;DbConnector&apos;diff --git a/src/db.c b/src/db.cindex 1aaefb6..5297645 100644--- a/src/db.c+++ b/src/db.c@@ -93,6 +93,11 @@ char *url_decode_mem(const char *url, int len) return url_decode_internal(&amp;url, len, NULL, &amp;out, 0); &#125;+char *url_decode(const char *url)+&#123;+ return url_decode_mem(url, strlen(url));+&#125;+ char *url_decode_parameter_name(const char **query) &#123; struct strbuf out = STRBUF_INIT; 在这里，我们看到子模块中定义了一个函数并在主项目中调用了它。 这明显是个简化了的例子，但是希望它能让你明白这种方法的用处。 有用的别名你可能想为其中一些命令设置别名，因为它们可能会非常长而你又不能设置选项作为它们的默认选项。 我们在 Git 别名 介绍了设置 Git 别名，但是如果你计划在 Git 中大量使用子模块的话，这里有一些例子。123$ git config alias.sdiff &apos;!&apos;&quot;git diff &amp;&amp; git submodule foreach &apos;git diff&apos;&quot;$ git config alias.spush &apos;push --recurse-submodules=on-demand&apos;$ git config alias.supdate &apos;submodule update --remote --merge&apos; 这样当你想要更新子模块时可以简单地运行 git supdate，或 git spush 检查子模块依赖后推送。 子模块的问题然而使用子模块还是有一些小问题。 例如在有子模块的项目中切换分支可能会造成麻烦。 如果你创建一个新分支，在其中添加一个子模块，之后切换到没有该子模块的分支上时，你仍然会有一个还未跟踪的子模块目录。123456789101112131415161718192021222324252627$ git checkout -b add-cryptoSwitched to a new branch &apos;add-crypto&apos;$ git submodule add https://github.com/chaconinc/CryptoLibraryCloning into &apos;CryptoLibrary&apos;......$ git commit -am &apos;adding crypto library&apos;[add-crypto 4445836] adding crypto library 2 files changed, 4 insertions(+) create mode 160000 CryptoLibrary$ git checkout masterwarning: unable to rmdir CryptoLibrary: Directory not emptySwitched to branch &apos;master&apos;Your branch is up-to-date with &apos;origin/master&apos;.$ git statusOn branch masterYour branch is up-to-date with &apos;origin/master&apos;.Untracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) CryptoLibrary/nothing added to commit but untracked files present (use &quot;git add&quot; to track) 移除那个目录并不困难，但是有一个目录在那儿会让人有一点困惑。 如果你移除它然后切换回有那个子模块的分支，需要运行 submodule update --init 来重新建立和填充。12345678910111213$ git clean -fdxRemoving CryptoLibrary/$ git checkout add-cryptoSwitched to branch &apos;add-crypto&apos;$ ls CryptoLibrary/$ git submodule update --initSubmodule path &apos;CryptoLibrary&apos;: checked out &apos;b8dda6aa182ea4464f3f3264b11e0268545172af&apos;$ ls CryptoLibrary/Makefile includes scripts src 再说一遍，这真的不难，只是会让人有点儿困惑。 另一个主要的告诫是许多人遇到了将子目录转换为子模块的问题。 如果你在项目中已经跟踪了一些文件，然后想要将它们移动到一个子模块中，那么请务必小心，否则 Git 会对你发脾气。 假设项目内有一些文件在子目录中，你想要将其转换为一个子模块。 如果删除子目录然后运行 submodule add，Git 会朝你大喊：123$ rm -Rf CryptoLibrary/$ git submodule add https://github.com/chaconinc/CryptoLibrary&apos;CryptoLibrary&apos; already exists in the index 你必须要先取消暂存 CryptoLibrary 目录。 然后才可以添加子模块：12345678$ git rm -r CryptoLibrary$ git submodule add https://github.com/chaconinc/CryptoLibraryCloning into &apos;CryptoLibrary&apos;...remote: Counting objects: 11, done.remote: Compressing objects: 100% (10/10), done.remote: Total 11 (delta 0), reused 11 (delta 0)Unpacking objects: 100% (11/11), done.Checking connectivity... done. 现在假设你在一个分支下做了这样的工作。 如果尝试切换回的分支中那些文件还在子目录而非子模块中时 - 你会得到这个错误：1234567$ git checkout mastererror: The following untracked working tree files would be overwritten by checkout: CryptoLibrary/Makefile CryptoLibrary/includes/crypto.h ...Please move or remove them before you can switch branches.Aborting 你可以通过 check -f 来强制切换，但是要小心，如果其中还有未保存的修改，这个命令会把它们覆盖掉。123$ git checkout -f masterwarning: unable to rmdir CryptoLibrary: Directory not emptySwitched to branch &apos;master&apos; 当你切换回来之后，因为某些原因你得到了一个空的 CryptoLibrary 目录，并且 git submodule update 也无法修复它。 你需要进入到子模块目录中运行 git checkout . 来找回所有的文件。 你也可以通过 submodule foreach 脚本来为多个子模块运行它。 要特别注意的是，近来子模块会将它们的所有 Git 数据保存在顶级项目的 .git 目录中，所以不像旧版本的 Git，摧毁一个子模块目录并不会丢失任何提交或分支。 拥有了这些工具，使用子模块会成为可以在几个相关但却分离的项目上同时开发的相当简单有效的方法。]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown 语法]]></title>
    <url>%2F2017%2F11%2F06%2Fmarkdown-%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在开发或者生活中我们常常会用到blog来表达我们的观点和记录，现在有很多网站和论坛都支持markdown的语法来编写bolog，如我们熟悉的CSDN，间书…其实markdown很简洁没有过多的赘述，它的title不想html还要用一组标签来表示，表格也很简单。下面我们就来说说markdown的语法是怎么起做的 title 标题分多种，想什么一级二级三级，这里边表示这些标题很简单和粗暴12345# title 一级标题## title 二级标题### title 三级#### title 四级....... 当然你还可以用内嵌的html来表示你的标题例如 &lt;h1&gt;title&lt;/h1&gt; 加粗markdown里面可以使用** 加粗的内容**两组**来对你想要加粗的字段进行加粗 列表列表分为两种，一种是有序列表还有无序列表。 有序列表有序列表用数字后面跟上一个.再加上空格即可 例如1. 列表一 无序列表无序列表* 列表或者- 列表 分割线------------------------------ 区域块儿的引用&gt;区域块儿在前面加上&gt;来表示这是一个区域 代码块儿的使用用两组,支持的语言有12```1c, abnf, accesslog, actionscript, ada, apache, applescript, arduino, armasm, asciidoc, aspectj, autohotkey, autoit, avrasm, awk, axapta, bash, basic, bnf, brainfuck, cal, capnproto, ceylon, clean, clojure, clojure-repl, cmake, coffeescript, coq, cos, cpp, crmsh, crystal, cs, csp, css, d, dart, delphi, diff, django, dns, dockerfile, dos, dsconfig, dts, dust, ebnf, elixir, elm, erb, erlang, erlang-repl, excel, fix, flix, fortran, fsharp, gams, gauss, gcode, gherkin, glsl, go, golo, gradle, groovy, haml, handlebars, haskell, haxe, hsp, htmlbars, http, hy, inform7, ini, irpf90, java, javascript, json, julia, kotlin, lasso, ldif, leaf, less, lisp, livecodeserver, livescript, llvm, lsl, lua, makefile, markdown, mathematica, matlab, maxima, mel, mercury, mipsasm, mizar, mojolicious, monkey, moonscript, n1ql, nginx, nimrod, nix, nsis, objectivec, ocaml, openscad, oxygene, parser3, perl, pf, php, pony, powershell, processing, profile, prolog, protobuf, puppet, purebasic, python, q, qml, r, rib, roboconf, rsl, ruby, ruleslanguage, rust, scala, scheme, scilab, scss, smali, smalltalk, sml, sqf, sql, stan, stata, step21, stylus, subunit, swift, taggerscript, tap, tcl, tex, thrift, tp, twig, typescript, vala, vbnet, vbscript, vbscript-html, verilog, vhdl, vim, x86asm, xl, xml, xquery, yaml, zephir 列表 Item Value Qty Computer 1600 USD 5 Phone 12 USD 12 Pipe 1 USD 234 图片的引用 ![](图片路径) *地址的引用 [描述](地址) 你好]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 工具 - 使用 Git 调试]]></title>
    <url>%2F2017%2F11%2F06%2Fgit-%E5%B7%A5%E5%85%B7-%E4%BD%BF%E7%94%A8-Git-%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[使用 Git 调试Git 也提供了两个工具来辅助你调试项目中的问题。 由于 Git 被设计成适用于几乎所有类型的项目，这些工具是比较通用的，但它们可以在出现问题的时候帮助你找到 bug 或者错误。 文件标注如果你在追踪代码中的一个 bug，并且想知道是什么时候以及为何会引入，文件标注通常是最好用的工具。 它展示了文件中每一行最后一次修改的提交。 所以，如果你在代码中看到一个有问题的方法，你可以使用 git blame 标注这个文件，查看这个方法每一行的最后修改时间以及是被谁修改的。 这个例子使用 -L 选项来限制输出范围在第12至22行：123456789101112$ git blame -L 12,22 simplegit.rb^4832fe2 (Scott Chacon 2008-03-15 10:31:28 -0700 12) def show(tree = &apos;master&apos;)^4832fe2 (Scott Chacon 2008-03-15 10:31:28 -0700 13) command(&quot;git show #&#123;tree&#125;&quot;)^4832fe2 (Scott Chacon 2008-03-15 10:31:28 -0700 14) end^4832fe2 (Scott Chacon 2008-03-15 10:31:28 -0700 15)9f6560e4 (Scott Chacon 2008-03-17 21:52:20 -0700 16) def log(tree = &apos;master&apos;)79eaf55d (Scott Chacon 2008-04-06 10:15:08 -0700 17) command(&quot;git log #&#123;tree&#125;&quot;)9f6560e4 (Scott Chacon 2008-03-17 21:52:20 -0700 18) end9f6560e4 (Scott Chacon 2008-03-17 21:52:20 -0700 19)42cf2861 (Magnus Chacon 2008-04-13 10:45:01 -0700 20) def blame(path)42cf2861 (Magnus Chacon 2008-04-13 10:45:01 -0700 21) command(&quot;git blame #&#123;path&#125;&quot;)42cf2861 (Magnus Chacon 2008-04-13 10:45:01 -0700 22) end 请注意，第一个字段是最后一次修改该行的提交的部分 SHA-1 值。 接下来两个字段的值是从提交中提取出来的——作者的名字以及提交的时间——所以你就可以很轻易地找到是谁在什么时候修改了那一行。 接下来就是行号和文件内容。 注意一下 ^4832fe2 这个提交的那些行，这些指的是这个文件第一次提交的那些行。 这个提交是这个文件第一次加入到这个项目时的提交，并且这些行从未被修改过。 这会带来小小的困惑，因为你已经至少看到三种 Git 使用 ^ 来修饰一个提交的 SHA-1 值的不同含义，但这里确实就是这个意思。 另一件比较酷的事情是 Git 不会显式地记录文件的重命名。 它会记录快照，然后在事后尝试计算出重命名的动作。 这其中有一个很有意思的特性就是你可以让 Git 找出所有的代码移动。 如果你在 git blame 后面加上一个 -C，Git 会分析你正在标注的文件，并且尝试找出文件中从别的地方复制过来的代码片段的原始出处。 比如，你将 GITServerHandler.m 这个文件拆分为数个文件，其中一个文件是 GITPackUpload.m。 对 GITPackUpload.m 执行带 -C 参数的blame命令，你就可以看到代码块的原始出处：1234567891011121314$ git blame -C -L 141,153 GITPackUpload.mf344f58d GITServerHandler.m (Scott 2009-01-04 141)f344f58d GITServerHandler.m (Scott 2009-01-04 142) - (void) gatherObjectShasFromCf344f58d GITServerHandler.m (Scott 2009-01-04 143) &#123;70befddd GITServerHandler.m (Scott 2009-03-22 144) //NSLog(@&quot;GATHER COMMIad11ac80 GITPackUpload.m (Scott 2009-03-24 145)ad11ac80 GITPackUpload.m (Scott 2009-03-24 146) NSString *parentSha;ad11ac80 GITPackUpload.m (Scott 2009-03-24 147) GITCommit *commit = [gad11ac80 GITPackUpload.m (Scott 2009-03-24 148)ad11ac80 GITPackUpload.m (Scott 2009-03-24 149) //NSLog(@&quot;GATHER COMMIad11ac80 GITPackUpload.m (Scott 2009-03-24 150)56ef2caf GITServerHandler.m (Scott 2009-01-05 151) if(commit) &#123;56ef2caf GITServerHandler.m (Scott 2009-01-05 152) [refDict setOb56ef2caf GITServerHandler.m (Scott 2009-01-05 153) 这个功能很有用。 通常来说，你会认为复制代码过来的那个提交是最原始的提交，因为那是你第一次在这个文件中修改了这几行。 但 Git 会告诉你，你第一次写这几行代码的那个提交才是原始提交，即使这是在另外一个文件里写的。 二分查找当你知道问题是在哪里引入的情况下文件标注可以帮助你查找问题。 如果你不知道哪里出了问题，并且自从上次可以正常运行到现在已经有数十个或者上百个提交，这个时候你可以使用 git bisect 来帮助查找。 bisect 命令会对你的提交历史进行二分查找来帮助你尽快找到是哪一个提交引入了问题。 假设你刚刚在线上环境部署了你的代码，接着收到一些 bug 反馈，但这些 bug 在你之前的开发环境里没有出现过，这让你百思不得其解。 你重新查看了你的代码，发现这个问题是可以被重现的，但是你不知道哪里出了问题。 你可以用二分法来找到这个问题。 首先执行 git bisect start 来启动，接着执行 git bisect bad 来告诉系统当前你所在的提交是有问题的。 然后你必须告诉 bisect 已知的最后一次正常状态是哪次提交，使用 git bisect good [good_commit]：12345$ git bisect start$ git bisect bad$ git bisect good v1.0Bisecting: 6 revisions left to test after this[ecb6e1bc347ccecc5f9350d878ce677feb13d3b2] error handling on repo Git 发现在你标记为正常的提交(v1.0)和当前的错误版本之间有大约12次提交，于是 Git 检出中间的那个提交。 现在你可以执行测试，看看在这个提交下问题是不是还是存在。 如果还存在，说明问题是在这个提交之前引入的；如果问题不存在，说明问题是在这个提交之后引入的。 假设测试结果是没有问题的，你可以通过 git bisect good 来告诉 Git，然后继续寻找。123$ git bisect goodBisecting: 3 revisions left to test after this[b047b02ea83310a70fd603dc8cd7a6cd13d15c04] secure this thing 现在你在另一个提交上了，这个提交是刚刚那个测试通过的提交和有问题的提交的中点。 你再一次执行测试，发现这个提交下是有问题的，因此你可以通过 git bisect bad 告诉 Git：123$ git bisect badBisecting: 1 revisions left to test after this[f71ce38690acf49c1f3c9bea38e09d82a5ce6014] drop exceptions table 这个提交是正常的，现在 Git 拥有的信息已经可以确定引入问题的位置在哪里。 它会告诉你第一个错误提交的 SHA-1 值并显示一些提交说明，以及哪些文件在那次提交里修改过，这样你可以找出引入 bug 的根源：12345678910$ git bisect goodb047b02ea83310a70fd603dc8cd7a6cd13d15c04 is first bad commitcommit b047b02ea83310a70fd603dc8cd7a6cd13d15c04Author: PJ Hyett &lt;pjhyett@example.com&gt;Date: Tue Jan 27 14:48:32 2009 -0800 secure this thing:040000 040000 40ee3e7821b895e52c1695092db9bdc4c61d1730f24d3c6ebcfc639b1a3814550e62d60b8e68a8e4 M config 当你完成这些操作之后，你应该执行 git bisect reset 重置你的 HEAD 指针到最开始的位置，否则你会停留在一个很奇怪的状态： $ git bisect reset这是一个可以帮助你在几分钟内从数百个提交中找到 bug 的强大工具。 事实上，如果你有一个脚本在项目是正常的情况下返回 0，在不正常的情况下返回非 0，你可以使 git bisect 自动化这些操作。 首先，你设定好项目正常以及不正常所在提交的二分查找范围。 你可以通过 bisect start 命令的参数来设定这两个提交，第一个参数是项目不正常的提交，第二个参数是项目正常的提交：$ git bisect start HEAD v1.0$ git bisect run test-error.shGit 会自动在每个被检出的提交里执行 test-error.sh 直到找到第一个项目不正常的提交。 你也可以执行 make 或者 make tests 或者其他东西来进行自动化测试。]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 工具 - Rerere]]></title>
    <url>%2F2017%2F11%2F06%2Fgit-%E5%B7%A5%E5%85%B7-Rerere%2F</url>
    <content type="text"><![CDATA[Rereregit rerere 功能是一个隐藏的功能。 正如它的名字 “reuse recorded resolution” 所指，它允许你让 Git 记住解决一个块冲突的方法，这样在下一次看到相同冲突时，Git 可以为你自动地解决它。 有几种情形下这个功能会非常有用。 在文档中提到的一个例子是如果你想要保证一个长期分支会干净地合并，但是又不想要一串中间的合并提交。 将 rerere 功能打开后偶尔合并，解决冲突，然后返回到合并前。 如果你持续这样做，那么最终的合并会很容易，因为 rerere 可以为你自动做所有的事情。 可以将同样的策略用在维持一个变基的分支时，这样就不用每次解决同样的变基冲突了。 或者你将一个分支合并并修复了一堆冲突后想要用变基来替代合并 - 你可能并不想要再次解决相同的冲突。 另一个情形是当你偶尔将一堆正在改进的特性分支合并到一个可测试的头时，就像 Git 项目自身经常做的。 如果测试失败，你可以倒回合并之前然后在去除导致测试失败的那个特性分支后重做合并，而不用再次重新解决所有的冲突。为了启用 rerere 功能，仅仅需要运行这个配置选项： $ git config –global rerere.enabled true也通过在特定的仓库中创建 .git/rr-cache 目录来开启它，但是设置选项更干净并且可以应用到全局。 现在我们看一个简单的例子，类似之前的那个。 假设有一个像这样的文件：12345#! /usr/bin/env rubydef hello puts &apos;hello world&apos;end 在一个分支中修改单词 “hello” 为 “hola”，然后在另一个分支中修改 “world” 为 “mundo”，就像之前一样。当合并两个分支到一起时，我们将会得到一个合并冲突：12345$ git merge i18n-worldAuto-merging hello.rbCONFLICT (content): Merge conflict in hello.rbRecorded preimage for &apos;hello.rb&apos;Automatic merge failed; fix conflicts and then commit the result. 你会注意到那个新行 Recorded preimage for FILE。 除此之外它应该看起来就像一个普通的合并冲突。 在这个时候，rerere 可以告诉我们几件事。 和往常一样，在这个时候你可以运行 git status 来查看所有冲突的内容：12345678$ git status# On branch master# Unmerged paths:# (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)# (use &quot;git add &lt;file&gt;...&quot; to mark resolution)## both modified: hello.rb# 然而，git rerere 也会通过 git rerere status 告诉你它记录的合并前状态。 $ git rerere statushello.rb并且 git rerere diff 将会显示解决方案的当前状态 - 开始解决前与解决后的样子。1234567891011121314151617$ git rerere diff--- a/hello.rb+++ b/hello.rb@@ -1,11 +1,11 @@ #! /usr/bin/env ruby def hello-&lt;&lt;&lt;&lt;&lt;&lt;&lt;- puts &apos;hello mundo&apos;-=======+&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD puts &apos;hola world&apos;-&gt;&gt;&gt;&gt;&gt;&gt;&gt;+=======+ puts &apos;hello mundo&apos;+&gt;&gt;&gt;&gt;&gt;&gt;&gt; i18n-world end 同样（这并不是真的与 rerere 有关系），可以使用 ls-files -u 来查看冲突文件的之前、左边与右边版本：1234$ git ls-files -u100644 39804c942a9c1f2c03dc7c5ebcd7f3e3a6b97519 1 hello.rb100644 a440db6e8d1fd76ad438a49025a9ad9ce746f581 2 hello.rb100644 54336ba847c3758ab604876419607e9443848474 3 hello.rb 现在可以通过改为 puts &#39;hola mundo&#39; 来解决它，可以再次运行 rerere diff 命令来查看 rerere 将会记住的内容：1234567891011121314$ git rerere diff--- a/hello.rb+++ b/hello.rb@@ -1,11 +1,7 @@ #! /usr/bin/env ruby def hello-&lt;&lt;&lt;&lt;&lt;&lt;&lt;- puts &apos;hello mundo&apos;-=======- puts &apos;hola world&apos;-&gt;&gt;&gt;&gt;&gt;&gt;&gt;+ puts &apos;hola mundo&apos; end 所以从本质上说，当 Git 看到一个 hello.rb 文件的一个块冲突中有 “hello mundo” 在一边与 “hola world” 在另一边，它会将其解决为 “hola mundo”。 现在我们可以将它标记为已解决并提交它：1234$ git add hello.rb$ git commitRecorded resolution for &apos;hello.rb&apos;.[master 68e16e5] Merge branch &apos;i18n&apos; 可以看到它 “Recorded resolution for FILE”。现在，让我们撤消那个合并然后将它变基到 master 分支顶部来替代它。可以通过使用之前在 重置揭密 看到的 reset 来回滚分支。 $ git reset –hard HEAD^HEAD is now at ad63f15 i18n the hello我们的合并被撤消了。 现在让我们变基特性分支。12345678910111213$ git checkout i18n-worldSwitched to branch &apos;i18n-world&apos;$ git rebase masterFirst, rewinding head to replay your work on top of it...Applying: i18n one wordUsing index info to reconstruct a base tree...Falling back to patching base and 3-way merge...Auto-merging hello.rbCONFLICT (content): Merge conflict in hello.rbResolved &apos;hello.rb&apos; using previous resolution.Failed to merge in the changes.Patch failed at 0001 i18n one word 现在，正像我们期望的一样，得到了相同的合并冲突，但是看一下 Resolved FILE using previous resolution 这行。 如果我们看这个文件，会发现它已经被解决了，而且在它里面没有合并冲突标记。123456$ cat hello.rb#! /usr/bin/env rubydef hello puts &apos;hola mundo&apos;end 同样，git diff 将会显示出它是如何自动地重新解决的：12345678910111213$ git diffdiff --cc hello.rbindex a440db6,54336ba..0000000--- a/hello.rb+++ b/hello.rb@@@ -1,7 -1,7 +1,7 @@@ #! /usr/bin/env ruby def hello- puts &apos;hola world&apos; - puts &apos;hello mundo&apos;++ puts &apos;hola mundo&apos; end 也可以通过 checkout 命令重新恢复到冲突时候的文件状态：1234567891011$ git checkout --conflict=merge hello.rb$ cat hello.rb#! /usr/bin/env rubydef hello&lt;&lt;&lt;&lt;&lt;&lt;&lt; ours puts &apos;hola world&apos;======= puts &apos;hello mundo&apos;&gt;&gt;&gt;&gt;&gt;&gt;&gt; theirsend 我们将会在 高级合并 中看到这个的一个例子。 然而现在，让我们通过运行 rerere 来重新解决它：12345678$ git rerereResolved &apos;hello.rb&apos; using previous resolution.$ cat hello.rb#! /usr/bin/env rubydef hello puts &apos;hola mundo&apos;end 我们通过 rerere 缓存的解决方案来自动重新解决了文件冲突。 现在可以添加并继续变基来完成它。123$ git add hello.rb$ git rebase --continueApplying: i18n one word 所以，如果做了很多次重新合并，或者想要一个特性分支始终与你的 master 分支保持最新但却不想要一大堆合并，或者经常变基，打开 rerere 功能可以帮助你的生活变得更美好。]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 工具 - 高级合并]]></title>
    <url>%2F2017%2F11%2F06%2Fgit-%E5%B7%A5%E5%85%B7-%E9%AB%98%E7%BA%A7%E5%90%88%E5%B9%B6%2F</url>
    <content type="text"><![CDATA[高级合并在 Git 中合并是相当容易的。 因为 Git 使多次合并另一个分支变得很容易，这意味着你可以有一个始终保持最新的长期分支，经常解决小的冲突，比在一系列提交后解决一个巨大的冲突要好。 然而，有时也会有棘手的冲突。 不像其他的版本控制系统，Git 并不会尝试过于聪明的合并冲突解决方案。 Git 的哲学是聪明地决定无歧义的合并方案，但是如果有冲突，它不会尝试智能地自动解决它。 因此，如果很久之后才合并两个分叉的分支，你可能会撞上一些问题。 在本节中，我们将会仔细查看那些问题是什么以及 Git 给了我们什么工具来帮助我们处理这些更难办的情形。我们也会了解你可以做的不同的、非标准类型的合并，也会看到如何后退到合并之前。 合并冲突我们在 遇到冲突时的分支合并 介绍了解决合并冲突的一些基础知识，对于更复杂的冲突，Git 提供了几个工具来帮助你指出将会发生什么以及如何更好地处理冲突。 首先，在做一次可能有冲突的合并前尽可能保证工作目录是干净的。 如果你有正在做的工作，要么提交到一个临时分支要么储藏它。 这使你可以撤消在这里尝试做的任何事情。 如果在你尝试一次合并时工作目录中有未保存的改动，下面的这些技巧可能会使你丢失那些工作。 让我们通过一个非常简单的例子来了解一下。 我们有一个超级简单的打印 hello world 的 Ruby 文件。1234567#! /usr/bin/env rubydef hello puts &apos;hello world&apos;endhello() 在我们的仓库中，创建一个名为 whitespace 的新分支并将所有 Unix 换行符修改为 DOS 换行符，实质上虽然改变了文件的每一行，但改变的都只是空白字符。 然后我们修改行 “hello world” 为 “hello mundo”。12345678910111213141516171819202122232425262728$ git checkout -b whitespaceSwitched to a new branch &apos;whitespace&apos;$ unix2dos hello.rbunix2dos: converting file hello.rb to DOS format ...$ git commit -am &apos;converted hello.rb to DOS&apos;[whitespace 3270f76] converted hello.rb to DOS 1 file changed, 7 insertions(+), 7 deletions(-)$ vim hello.rb$ git diff -bdiff --git a/hello.rb b/hello.rbindex ac51efd..e85207e 100755--- a/hello.rb+++ b/hello.rb@@ -1,7 +1,7 @@ #! /usr/bin/env ruby def hello- puts &apos;hello world&apos;+ puts &apos;hello mundo&apos;^M end hello()$ git commit -am &apos;hello mundo change&apos;[whitespace 6d338d2] hello mundo change 1 file changed, 1 insertion(+), 1 deletion(-) 现在我们切换回我们的 master 分支并为函数增加一些注释。1234567891011121314151617181920$ git checkout masterSwitched to branch &apos;master&apos;$ vim hello.rb$ git diffdiff --git a/hello.rb b/hello.rbindex ac51efd..36c06c8 100755--- a/hello.rb+++ b/hello.rb@@ -1,5 +1,6 @@ #! /usr/bin/env ruby+# prints out a greeting def hello puts &apos;hello world&apos; end$ git commit -am &apos;document the function&apos;[master bec6336] document the function 1 file changed, 1 insertion(+) 现在我们尝试合并入我们的 whitespace 分支，因为修改了空白字符，所以合并会出现冲突。1234$ git merge whitespaceAuto-merging hello.rbCONFLICT (content): Merge conflict in hello.rbAutomatic merge failed; fix conflicts and then commit the result. 中断一次合并我们现在有几个选项。 首先，让我们介绍如何摆脱这个情况。 你可能不想处理冲突这种情况，完全可以通过 git merge --abort 来简单地退出合并。12345678$ git status -sb## masterUU hello.rb$ git merge --abort$ git status -sb## master git merge --abort 选项会尝试恢复到你运行合并前的状态。 但当运行命令前，在工作目录中有未储藏、未提交的修改时它不能完美处理，除此之外它都工作地很好。 如果因为某些原因你发现自己处在一个混乱的状态中然后只是想要重来一次，也可以运行 git reset --hard HEAD 回到之前的状态或其他你想要恢复的状态。 请牢记这会将清除工作目录中的所有内容，所以确保你不需要保存这里的任意改动。 忽略空白在这个特定的例子中，冲突与空白有关。 我们知道这点是因为这个例子很简单，但是在实际的例子中发现这样的冲突也很容易，因为每一行都被移除而在另一边每一行又被加回来了。 默认情况下，Git 认为所有这些行都改动了，所以它不会合并文件。 默认合并策略可以带有参数，其中的几个正好是关于忽略空白改动的。 如果你看到在一次合并中有大量的空白问题，你可以简单地中止它并重做一次，这次使用 -Xignore-all-space 或 -Xignore-space-change 选项。 第一个选项忽略任意 数量 的已有空白的修改，第二个选项忽略所有空白修改。12345$ git merge -Xignore-space-change whitespaceAuto-merging hello.rbMerge made by the &apos;recursive&apos; strategy. hello.rb | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-) 因为在本例中，实际上文件修改并没有冲突，一旦我们忽略空白修改，每一行都能被很好地合并。 如果你的团队中的某个人可能不小心重新格式化空格为制表符或者相反的操作，这会是一个救命稻草 手动文件再合并虽然 Git 对空白的预处理做得很好，还有很多其他类型的修改，Git 也许无法自动处理，但是脚本可以处理它们。 例如，假设 Git 无法处理空白修改因此我们需要手动处理。 我们真正想要做的是对将要合并入的文件在真正合并前运行 dos2unix 程序。 所以如果那样的话，我们该如何做？ 首先，我们进入到了合并冲突状态。 然后我们想要我的版本的文件，他们的版本的文件（从我们将要合并入的分支）和共同的版本的文件（从分支叉开时的位置）的拷贝。 然后我们想要修复任何一边的文件，并且为这个单独的文件重试一次合并。 获得这三个文件版本实际上相当容易。 Git 在索引中存储了所有这些版本，在 “stages” 下每一个都有一个数字与它们关联。 Stage 1 是它们共同的祖先版本，stage 2 是你的版本，stage 3 来自于 MERGE_HEAD，即你将要合并入的版本（“theirs”）。 通过 git show 命令与一个特别的语法，你可以将冲突文件的这些版本释放出一份拷贝。123$ git show :1:hello.rb &gt; hello.common.rb$ git show :2:hello.rb &gt; hello.ours.rb$ git show :3:hello.rb &gt; hello.theirs.rb 如果你想要更专业一点，也可以使用 ls-files -u 底层命令来得到这些文件的 Git blob 对象的实际 SHA-1 值。1234$ git ls-files -u100755 ac51efdc3df4f4fd328d1a02ad05331d8e2c9111 1 hello.rb100755 36c06c8752c78d2aff89571132f3bf7841a7b5c3 2 hello.rb100755 e85207e04dfdd5eb0a1e9febbc67fd837c44a1cd 3 hello.rb :1:hello.rb 只是查找那个 blob 对象 SHA-1 值的简写。既然在我们的工作目录中已经有这所有三个阶段的内容，我们可以手工修复它们来修复空白问题，然后使用鲜为人知的 git merge-file 命令来重新合并那个文件。123456789101112131415161718192021$ dos2unix hello.theirs.rbdos2unix: converting file hello.theirs.rb to Unix format ...$ git merge-file -p \ hello.ours.rb hello.common.rb hello.theirs.rb &gt; hello.rb$ git diff -bdiff --cc hello.rbindex 36c06c8,e85207e..0000000--- a/hello.rb+++ b/hello.rb@@@ -1,8 -1,7 +1,8 @@@ #! /usr/bin/env ruby +# prints out a greeting def hello- puts &apos;hello world&apos;+ puts &apos;hello mundo&apos; end hello() 在这时我们已经漂亮地合并了那个文件。 实际上，这比使用 ignore-space-change 选项要更好，因为在合并前真正地修复了空白修改而不是简单地忽略它们。 在使用 ignore-space-change 进行合并操作后，我们最终得到了有几行是 DOS 行尾的文件，从而使提交内容混乱了。 如果你想要在最终提交前看一下我们这边与另一边之间实际的修改，你可以使用 git diff 来比较将要提交作为合并结果的工作目录与其中任意一个阶段的文件差异。 让我们看看它们。 要在合并前比较结果与在你的分支上的内容，换一句话说，看看合并引入了什么，可以运行 git diff --ours123456789101112131415$ git diff --ours* Unmerged path hello.rbdiff --git a/hello.rb b/hello.rbindex 36c06c8..44d0a25 100755--- a/hello.rb+++ b/hello.rb@@ -2,7 +2,7 @@ # prints out a greeting def hello- puts &apos;hello world&apos;+ puts &apos;hello mundo&apos; end hello() 这里我们可以很容易地看到在我们的分支上发生了什么，在这次合并中我们实际引入到这个文件的改动，是修改了其中一行。 如果我们想要查看合并的结果与他们那边有什么不同，可以运行 git diff --theirs。 在本例及后续的例子中，我们会使用 -b 来去除空白，因为我们将它与 Git 中的，而不是我们清理过的 hello.theirs.rb 文件比较。12345678910111213$ git diff --theirs -b* Unmerged path hello.rbdiff --git a/hello.rb b/hello.rbindex e85207e..44d0a25 100755--- a/hello.rb+++ b/hello.rb@@ -1,5 +1,6 @@ #! /usr/bin/env ruby+# prints out a greeting def hello puts &apos;hello mundo&apos; end 最终，你可以通过 git diff --base 来查看文件在两边是如何改动的。12345678910111213141516$ git diff --base -b* Unmerged path hello.rbdiff --git a/hello.rb b/hello.rbindex ac51efd..44d0a25 100755--- a/hello.rb+++ b/hello.rb@@ -1,7 +1,8 @@ #! /usr/bin/env ruby+# prints out a greeting def hello- puts &apos;hello world&apos;+ puts &apos;hello mundo&apos; end hello() 在这时我们可以使用 git clean 命令来清理我们为手动合并而创建但不再有用的额外文件。1234$ git clean -fRemoving hello.common.rbRemoving hello.ours.rbRemoving hello.theirs.rb 检出冲突也许有时我们并不满意这样的解决方案，或许有时还要手动编辑一边或者两边的冲突，但还是依旧无法正常工作，这时我们需要更多的上下文关联来解决这些冲突。 让我们来稍微改动下例子。 对于本例，我们有两个长期分支，每一个分支都有几个提交，但是在合并时却创建了一个合理的冲突。123456789$ git log --graph --oneline --decorate --all* f1270f7 (HEAD, master) update README* 9af9d3b add a README* 694971d update phrase to hola world| * e3eb223 (mundo) add more tests| * 7cff591 add testing script| * c3ffff1 changed text to hello mundo|/* b7dcc89 initial hello world code 现在有只在 master 分支上的三次单独提交，还有其他三次提交在 mundo 分支上。 如果我们尝试将 mundo 分支合并入 master 分支，我们得到一个冲突。1234$ git merge mundoAuto-merging hello.rbCONFLICT (content): Merge conflict in hello.rbAutomatic merge failed; fix conflicts and then commit the result. 我们想要看一下合并冲突是什么。 如果我们打开这个文件，我们将会看到类似下面的内容：1234567891011#! /usr/bin/env rubydef hello&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD puts &apos;hola world&apos;======= puts &apos;hello mundo&apos;&gt;&gt;&gt;&gt;&gt;&gt;&gt; mundoendhello() 合并的两边都向这个文件增加了内容，但是导致冲突的原因是其中一些提交修改了文件的同一个地方。 让我们探索一下现在你手边可用来查明这个冲突是如何产生的工具。 应该如何修复这个冲突看起来或许并不明显。 这时你需要更多上下文。 一个很有用的工具是带 --conflict 选项的 git checkout。 这会重新检出文件并替换合并冲突标记。 如果想要重置标记并尝试再次解决它们的话这会很有用。 可以传递给 --conflict 参数 diff3 或 merge（默认选项）。 如果传给它 diff3，Git 会使用一个略微不同版本的冲突标记：不仅仅只给你 “ours” 和 “theirs” 版本，同时也会有 “base” 版本在中间来给你更多的上下文。 $ git checkout –conflict=diff3 hello.rb一旦我们运行它，文件看起来会像下面这样：12345678910111213#! /usr/bin/env rubydef hello&lt;&lt;&lt;&lt;&lt;&lt;&lt; ours puts &apos;hola world&apos;||||||| base puts &apos;hello world&apos;======= puts &apos;hello mundo&apos;&gt;&gt;&gt;&gt;&gt;&gt;&gt; theirsendhello() 如果你喜欢这种格式，可以通过设置 merge.conflictstyle 选项为 diff3 来做为以后合并冲突的默认选项。 $ git config –global merge.conflictstyle diff3git checkout 命令也可以使用 --ours 和 --theirs 选项，这是一种无需合并的快速方式，你可以选择留下一边的修改而丢弃掉另一边修改。 当有二进制文件冲突时这可能会特别有用，因为可以简单地选择一边，或者可以只合并另一个分支的特定文件 - 可以做一次合并然后在提交前检出一边或另一边的特定文件。 合并日志另一个解决合并冲突有用的工具是 git log。 这可以帮助你得到那些对冲突有影响的上下文。 回顾一点历史来记起为什么两条线上的开发会触碰同一片代码有时会很有用。 为了得到此次合并中包含的每一个分支的所有独立提交的列表，我们可以使用之前在 三点 学习的 “三点” 语法。1234567$ git log --oneline --left-right HEAD...MERGE_HEAD&lt; f1270f7 update README&lt; 9af9d3b add a README&lt; 694971d update phrase to hola world&gt; e3eb223 add more tests&gt; 7cff591 add testing script&gt; c3ffff1 changed text to hello mundo 这个漂亮的列表包含 6 个提交和每一个提交所在的不同开发路径。 我们可以通过更加特定的上下文来进一步简化这个列表。 如果我们添加 --merge 选项到 git log 中，它会只显示任何一边接触了合并冲突文件的提交。123$ git log --oneline --left-right --merge&lt; 694971d update phrase to hola world&gt; c3ffff1 changed text to hello mundo 如果你运行命令时用 -p 选项代替，你会得到所有冲突文件的区别。 快速获得你需要帮助理解为什么发生冲突的上下文，以及如何聪明地解决它，这会 非常 有用。 组合式差异格式因为 Git 暂存合并成功的结果，当你在合并冲突状态下运行 git diff 时，只会得到现在还在冲突状态的区别。 当需要查看你还需要解决哪些冲突时这很有用。 在合并冲突后直接运行的 git diff 会给你一个相当独特的输出格式。1234567891011121314151617$ git diffdiff --cc hello.rbindex 0399cd5,59727f0..0000000--- a/hello.rb+++ b/hello.rb@@@ -1,7 -1,7 +1,11 @@@ #! /usr/bin/env ruby def hello++&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD + puts &apos;hola world&apos;++=======+ puts &apos;hello mundo&apos;++&gt;&gt;&gt;&gt;&gt;&gt;&gt; mundo end hello() 这种叫作 “组合式差异” 的格式会在每一行给你两列数据。 第一列为你显示 “ours” 分支与工作目录的文件区别（添加或删除），第二列显示 “theirs” 分支与工作目录的拷贝区别。 所以在上面的例子中可以看到 &lt;&lt;&lt;&lt;&lt;&lt;&lt; 与 &gt;&gt;&gt;&gt;&gt;&gt;&gt; 行在工作拷贝中但是并不在合并的任意一边中。 这很有意义，合并工具因为我们的上下文被困住了，它期望我们去移除它们。 如果我们解决冲突再次运行 git diff，我们将会看到同样的事情，但是它有一点帮助。12345678910111213141516$ vim hello.rb$ git diffdiff --cc hello.rbindex 0399cd5,59727f0..0000000--- a/hello.rb+++ b/hello.rb@@@ -1,7 -1,7 +1,7 @@@ #! /usr/bin/env ruby def hello- puts &apos;hola world&apos; - puts &apos;hello mundo&apos;++ puts &apos;hola mundo&apos; end hello() 这里显示出 “hola world” 在我们这边但不在工作拷贝中，那个 “hello mundo” 在他们那边但不在工作拷贝中，最终 “hola mundo” 不在任何一边但是现在在工作拷贝中。 在提交解决方案前这对审核很有用。 也可以在合并后通过 git log 来获取相同信息，并查看冲突是如何解决的。 如果你对一个合并提交运行 git show 命令 Git 将会输出这种格式，或者你也可以在 git log -p（默认情况下该命令只会展示还没有合并的补丁）命令之后加上 --cc 选项。12345678910111213141516171819202122232425$ git log --cc -p -1commit 14f41939956d80b9e17bb8721354c33f8d5b5a79Merge: f1270f7 e3eb223Author: Scott Chacon &lt;schacon@gmail.com&gt;Date: Fri Sep 19 18:14:49 2014 +0200 Merge branch &apos;mundo&apos; Conflicts: hello.rbdiff --cc hello.rbindex 0399cd5,59727f0..e1d0799--- a/hello.rb+++ b/hello.rb@@@ -1,7 -1,7 +1,7 @@@ #! /usr/bin/env ruby def hello- puts &apos;hola world&apos; - puts &apos;hello mundo&apos;++ puts &apos;hola mundo&apos; end hello() 撤消合并虽然你已经知道如何创建一个合并提交，但有时出错是在所难免的。 使用 Git 最棒的一件事情是犯错是可以的，因为有可能（大多数情况下都很容易）修复它们。 合并提交并无不同。 假设现在在一个特性分支上工作，不小心将其合并到 master 中，现在提交历史看起来是这样：Figure 138. 意外的合并提交有两种方法来解决这个问题，这取决于你想要的结果是什么。 修复引用如果这个不想要的合并提交只存在于你的本地仓库中，最简单且最好的解决方案是移动分支到你想要它指向的地方。 大多数情况下，如果你在错误的 git merge 后运行 git reset --hard HEAD~，这会重置分支指向所以它们看起来像这样：Figure 139. 在 git reset --hard HEAD~ 之后的历史我们之前在 重置揭密 已经介绍了 reset，所以现在指出这里发生了什么并不是很困难。 让我们快速复习下：reset --hard 通常会经历三步： 移动 HEAD 指向的分支。 在本例中，我们想要移动 master 到合并提交（C6）之前所在的位置。 使索引看起来像 HEAD。 使工作目录看起来像索引。 这个方法的缺点是它会重写历史，在一个共享的仓库中这会造成问题的。 查阅 变基的风险 来了解更多可能发生的事情；用简单的话说就是如果其他人已经有你将要重写的提交，你应当避免使用 reset。 如果有任何其他提交在合并之后创建了，那么这个方法也会无效；移动引用实际上会丢失那些改动。 还原提交如果移动分支指针并不适合你，Git 给你一个生成一个新提交的选项，提交将会撤消一个已存在提交的所有修改。 Git 称这个操作为 “还原”，在这个特定的场景下，你可以像这样调用它：12$ git revert -m 1 HEAD[master b1d8379] Revert &quot;Merge branch &apos;topic&apos;&quot; -m 1 标记指出 “mainline” 需要被保留下来的父结点。 当你引入一个合并到 HEAD（git merge topic），新提交有两个父结点：第一个是 HEAD（C6），第二个是将要合并入分支的最新提交（C4）。 在本例中，我们想要撤消所有由父结点 #2（C4）合并引入的修改，同时保留从父结点 #1（C4）开始的所有内容。 有还原提交的历史看起来像这样：Figure 140. 在 git revert -m 1 后的历史新的提交 ^M 与 C6 有完全一样的内容，所以从这儿开始就像合并从未发生过，除了“现在还没合并”的提交依然在 HEAD 的历史中。 如果你尝试再次合并 topic 到 master Git 会感到困惑：12$ git merge topicAlready up-to-date. topic 中并没有东西不能从 master 中追踪到达。 更糟的是，如果你在 topic 中增加工作然后再次合并，Git 只会引入被还原的合并 之后 的修改。Figure 141. 含有坏掉合并的历史解决这个最好的方式是撤消还原原始的合并，因为现在你想要引入被还原出去的修改，然后 创建一个新的合并提交：123$ git revert ^M[master 09f0126] Revert &quot;Revert &quot;Merge branch &apos;topic&apos;&quot;&quot;$ git merge topic Figure 142. 在重新合并一个还原合并后的历史在本例中，M 与 ^M 抵消了。 ^^M 事实上合并入了 C3 与 C4 的修改，C8 合并了 C7 的修改，所以现在 topic 已经完全被合并了 其他类型的合并到目前为止我们介绍的都是通过一个叫作 “recursive” 的合并策略来正常处理的两个分支的正常合并。 然而还有其他方式来合并两个分支到一起。 让我们来快速介绍其中的几个。 我们的或他们的偏好首先，有另一种我们可以通过 “recursive” 合并模式做的有用工作。 我们之前已经看到传递给 -X 的 ignore-all-space 与 ignore-space-change 选项，但是我们也可以告诉 Git 当它看见一个冲突时直接选择一边。 默认情况下，当 Git 看到两个分支合并中的冲突时，它会将合并冲突标记添加到你的代码中并标记文件为冲突状态来让你解决。 如果你希望 Git 简单地选择特定的一边并忽略另外一边而不是让你手动合并冲突，你可以传递给 merge 命令一个 -Xours 或 -Xtheirs 参数。 如果 Git 看到这个，它并不会增加冲突标记。 任何可以合并的区别，它会直接合并。 任何有冲突的区别，它会简单地选择你全局指定的一边，包括二进制文件。 如果我们回到之前我们使用的 “hello world” 例子中，我们可以看到合并入我们的分支时引发了冲突。12345$ git merge mundoAuto-merging hello.rbCONFLICT (content): Merge conflict in hello.rbResolved &apos;hello.rb&apos; using previous resolution.Automatic merge failed; fix conflicts and then commit the result. 然而如果我们运行时增加 -Xours 或 -Xtheirs 参数就不会有冲突。1234567$ git merge -Xours mundoAuto-merging hello.rbMerge made by the &apos;recursive&apos; strategy. hello.rb | 2 +- test.sh | 2 ++ 2 files changed, 3 insertions(+), 1 deletion(-) create mode 100644 test.sh 在上例中，它并不会为 “hello mundo” 与 “hola world” 标记合并冲突，它只会简单地选取 “hola world”。 然而，在那个分支上所有其他非冲突的改动都可以被成功地合并入。 这个选项也可以传递给我们之前看到的 git merge-file 命令，通过运行类似 git merge-file --ours 的命令来合并单个文件。 如果想要做类似的事情但是甚至并不想让 Git 尝试合并另外一边的修改，有一个更严格的选项，它是 “ours” 合并 策略。 这与 “ours” recursive 合并 选项 不同。 这本质上会做一次假的合并。 它会记录一个以两边分支作为父结点的新合并提交，但是它甚至根本不关注你正合并入的分支。 它只会简单地把当前分支的代码当作合并结果记录下来。1234$ git merge -s ours mundoMerge made by the &apos;ours&apos; strategy.$ git diff HEAD HEAD~$ 你可以看到合并后与合并前我们的分支并没有任何区别。 当再次合并时从本质上欺骗 Git 认为那个分支已经合并过经常是很有用的。 例如，假设你有一个分叉的 release 分支并且在上面做了一些你想要在未来某个时候合并回 master 的工作。 与此同时 master 分支上的某些 bugfix 需要向后移植回 release 分支。 你可以合并 bugfix 分支进入 release 分支同时也 merge -s ours 合并进入你的 master 分支（即使那个修复已经在那儿了）这样当你之后再次合并 release 分支时，就不会有来自 bugfix 的冲突。 子树合并子树合并的思想是你有两个项目，并且其中一个映射到另一个项目的一个子目录，或者反过来也行。 当你执行一个子树合并时，Git 通常可以自动计算出其中一个是另外一个的子树从而实现正确的合并。 我们来看一个例子如何将一个项目加入到一个已存在的项目中，然后将第二个项目的代码合并到第一个项目的子目录中。 首先，我们将 Rack 应用添加到你的项目里。 我们把 Rack 项目作为一个远程的引用添加到我们的项目里，然后检出到它自己的分支。12345678910111213141516$ git remote add rack_remote https://github.com/rack/rack$ git fetch rack_remotewarning: no common commitsremote: Counting objects: 3184, done.remote: Compressing objects: 100% (1465/1465), done.remote: Total 3184 (delta 1952), reused 2770 (delta 1675)Receiving objects: 100% (3184/3184), 677.42 KiB | 4 KiB/s, done.Resolving deltas: 100% (1952/1952), done.From https://github.com/rack/rack * [new branch] build -&gt; rack_remote/build * [new branch] master -&gt; rack_remote/master * [new branch] rack-0.4 -&gt; rack_remote/rack-0.4 * [new branch] rack-0.9 -&gt; rack_remote/rack-0.9$ git checkout -b rack_branch rack_remote/masterBranch rack_branch set up to track remote branch refs/remotes/rack_remote/master.Switched to a new branch &quot;rack_branch&quot; 现在在我们的 rack_branch 分支里就有 Rack 项目的根目录，而我们的项目则在 master 分支里。 如果你从一个分支切换到另一个分支，你可以看到它们的项目根目录是不同的：1234567$ lsAUTHORS KNOWN-ISSUES Rakefile contrib libCOPYING README bin example test$ git checkout masterSwitched to branch &quot;master&quot;$ lsREADME 这个是一个比较奇怪的概念。 并不是仓库中的所有分支都是必须属于同一个项目的分支. 这并不常见，因为没啥用，但是却是在不同分支里包含两条完全不同提交历史的最简单的方法。 在这个例子中，我们希望将 Rack 项目拉到 master 项目中作为一个子目录。 我们可以在 Git 中执行 git read-tree 来实现。 你可以在 Git 内部原理 中查看更多 read-tree 的相关信息，现在你只需要知道它会读取一个分支的根目录树到当前的暂存区和工作目录里。 先切回你的 master 分支，将 rack_back 分支拉取到我们项目的 master 分支中的 rack 子目录。 $ git read-tree –prefix=rack/ -u rack_branch当我们提交时，那个子目录中拥有所有 Rack 项目的文件 —— 就像我们直接从压缩包里复制出来的一样。 有趣的是你可以很容易地将一个分支的变更合并到另一个分支里。 所以，当 Rack 项目有更新时，我们可以切换到那个分支来拉取上游的变更。$ git checkout rack_branch$ git pull接着，我们可以将这些变更合并回我们的 master 分支。 使用 --squash 选项和使用 -Xsubtree 选项（它采用递归合并策略），都可以用来可以拉取变更并且预填充提交信息。 （递归策略在这里是默认的，提到它是为了让读者有个清晰的概念。）1234$ git checkout master$ git merge --squash -s recursive -Xsubtree=rack rack_branchSquash commit -- not updating HEADAutomatic merge went well; stopped before committing as requested Rack 项目中所有的改动都被合并了，等待被提交到本地。 你也可以用相反的方法——在 master 分支上的 rack 子目录中做改动然后将它们合并入你的 rack_branch 分支中，之后你可能将其提交给项目维护着或者将它们推送到上游。 这给我们提供了一种类似子模块工作流的工作方式，但是它并不需要用到子模块（有关子模块的内容我们会在 子模块 中介绍）。 我们可以在自己的仓库中保持一些和其他项目相关的分支，偶尔使用子树合并将它们合并到我们的项目中。 某些时候这种方式很有用，例如当所有的代码都提交到一个地方的时候。 然而，它同时也有缺点，它更加复杂且更容易让人犯错，例如重复合并改动或者不小心将分支提交到一个无关的仓库上去。 另外一个有点奇怪的地方是，当你想查看 rack 子目录和 rack_branch 分支的差异——来确定你是否需要合并它们——你不能使用普通的 diff 命令。 取而代之的是，你必须使用 git diff-tree 来和你的目标分支做比较： $ git diff-tree -p rack_branch或者，将你的 rack 子目和最近一次从服务器上抓取的 master 分支进行比较，你可以运行：$ git diff-tree -p rack_remote/master]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 工具 - 重置揭密]]></title>
    <url>%2F2017%2F11%2F06%2Fgit-%E5%B7%A5%E5%85%B7-%E9%87%8D%E7%BD%AE%E6%8F%AD%E5%AF%86%2F</url>
    <content type="text"><![CDATA[重置揭密在继续了解更专业的工具前，我们先讨论一下 reset 与 checkout。 在你初次遇到的 Git 命令中，这两个是最让人困惑的。 它们能做很多事情，所以看起来我们很难真正地理解并恰当地运用它们。 针对这一点，我们先来做一个简单的比喻。 三棵树理解 reset 和 checkout 的最简方法，就是以 Git 的思维框架（将其作为内容管理器）来管理三棵不同的树。 “树” 在我们这里的实际意思是 “文件的集合”，而不是指特定的数据结构。 （在某些情况下索引看起来并不像一棵树，不过我们现在的目的是用简单的方式思考它。）Git 作为一个系统，是以它的一般操作来管理并操纵这三棵树的：| 树 | 用途 || :——– | :——–|| HEAD | 上一次提交的快照，下一次提交的父结点 || Index | 预期的下一次提交的快照 || Working Directory | 沙盒 | HEADHEAD 是当前分支引用的指针，它总是指向该分支上的最后一次提交。 这表示 HEAD 将是下一次提交的父结点。 通常，理解 HEAD 的最简方式，就是将它看做 你的上一次提交 的快照。 其实，查看快照的样子很容易。 下例就显示了 HEAD 快照实际的目录列表，以及其中每个文件的 SHA-1 校验和：1234567891011$ git cat-file -p HEADtree cfda3bf379e4f8dba8717dee55aab78aef7f4dafauthor Scott Chacon 1301511835 -0700committer Scott Chacon 1301511835 -0700initial commit$ git ls-tree -r HEAD100644 blob a906cb2a4a904a152... README100644 blob 8f94139338f9404f2... Rakefile040000 tree 99f1a6d12cb4b6f19... lib cat-file 与 ls-tree 是底层命令，它们一般用于底层工作，在日常工作中并不使用。不过它们能帮助我们了解到底发生了什么。 索引索引是你的 预期的下一次提交。 我们也会将这个概念引用为 Git 的 “暂存区域”，这就是当你运行 git commit 时 Git 看起来的样子。 Git 将上一次检出到工作目录中的所有文件填充到索引区，它们看起来就像最初被检出时的样子。 之后你会将其中一些文件替换为新版本，接着通过 git commit 将它们转换为树来用作新的提交。1234$ git ls-files -s100644 a906cb2a4a904a152e80877d4088654daad0c859 0 README100644 8f94139338f9404f26296befa88755fc2598c289 0 Rakefile100644 47c6340d6459e05787f644c2447d2595f5d3a54b 0 lib/simplegit.rb 再说一次，我们在这里又用到了 ls-files 这个幕后的命令，它会显示出索引当前的样子。 确切来说，索引并非技术上的树结构，它其实是以扁平的清单实现的。不过对我们而言，把它当做树就够了。 工作目录最后，你就有了自己的工作目录。 另外两棵树以一种高效但并不直观的方式，将它们的内容存储在 .git 文件夹中。 工作目录会将它们解包为实际的文件以便编辑。 你可以把工作目录当做 沙盒。在你将修改提交到暂存区并记录到历史之前，可以随意更改。12345678$ tree.├── README├── Rakefile└── lib └── simplegit.rb1 directory, 3 files 工作流程Git 主要的目的是通过操纵这三棵树来以更加连续的状态记录项目的快照。让我们来可视化这个过程：假设我们进入到一个新目录，其中有一个文件。 我们称其为该文件的 v1 版本，将它标记为蓝色。 现在运行 git init，这会创建一个 Git 仓库，其中的 HEAD 引用指向未创建的分支（master 还不存在）。此时，只有工作目录有内容。 现在我们想要提交这个文件，所以用 git add 来获取工作目录中的内容，并将其复制到索引中。接着运行 git commit，它首先会移除索引中的内容并将它保存为一个永久的快照，然后创建一个指向该快照的提交对象，最后更新 master 来指向本次提交。此时如果我们运行 git status，会发现没有任何改动，因为现在三棵树完全相同。 现在我们想要对文件进行修改然后提交它。 我们将会经历同样的过程；首先在工作目录中修改文件。 我们称其为该文件的 v2 版本，并将它标记为红色。如果现在运行 git status，我们会看到文件显示在 “Changes not staged for commit,” 下面并被标记为红色，因为该条目在索引与工作目录之间存在不同。 接着我们运行 git add 来将它暂存到索引中。此时，由于索引和 HEAD 不同，若运行 git status 的话就会看到 “Changes to be committed” 下的该文件变为绿色 ——也就是说，现在预期的下一次提交与上一次提交不同。 最后，我们运行 git commit 来完成提交。现在运行 git status 会没有输出，因为三棵树又变得相同了。 切换分支或克隆的过程也类似。 当检出一个分支时，它会修改 HEAD 指向新的分支引用，将 索引 填充为该次提交的快照，然后将 索引 的内容复制到 工作目录 中。 重置的作用在以下情景中观察 reset 命令会更有意义。 为了演示这些例子，假设我们再次修改了 file.txt 文件并第三次提交它。 现在的历史看起来是这样的：让我们跟着 reset 看看它都做了什么。 它以一种简单可预见的方式直接操纵这三棵树。 它做了三个基本操作。 第 1 步：移动 HEADreset 做的第一件事是移动 HEAD 的指向。 这与改变 HEAD 自身不同（checkout 所做的）；reset 移动 HEAD 指向的分支。 这意味着如果 HEAD 设置为 master 分支（例如，你正在 master 分支上），运行 git reset 9e5e64a 将会使 master 指向 9e5e64a。无论你调用了何种形式的带有一个提交的 reset，它首先都会尝试这样做。 使用 reset --soft，它将仅仅停在那儿。 现在看一眼上图，理解一下发生的事情：它本质上是撤销了上一次 git commit 命令。 当你在运行 git commit 时，Git 会创建一个新的提交，并移动 HEAD 所指向的分支来使其指向该提交。 当你将它 reset 回 HEAD~（HEAD 的父结点）时，其实就是把该分支移动回原来的位置，而不会改变索引和工作目录。 现在你可以更新索引并再次运行 git commit 来完成 git commit --amend 所要做的事情了（见 修改最后一次提交）。 第 2 步：更新索引（–mixed）注意，如果你现在运行 git status 的话，就会看到新的 HEAD 和以绿色标出的它和索引之间的区别。 接下来，reset 会用 HEAD 指向的当前快照的内容来更新索引。如果指定 --mixed 选项，reset 将会在这时停止。 这也是默认行为，所以如果没有指定任何选项（在本例中只是 git reset HEAD~），这就是命令将会停止的地方。 现在再看一眼上图，理解一下发生的事情：它依然会撤销一上次 提交，但还会 取消暂存 所有的东西。 于是，我们回滚到了所有 git add 和 git commit 的命令执行之前。 第 3 步：更新工作目录（–hard）reset 要做的的第三件事情就是让工作目录看起来像索引。 如果使用 --hard 选项，它将会继续这一步。现在让我们回想一下刚才发生的事情。 你撤销了最后的提交、git add 和 git commit 命令以及工作目录中的所有工作。 必须注意，--hard 标记是 reset 命令唯一的危险用法，它也是 Git 会真正地销毁数据的仅有的几个操作之一。 其他任何形式的 reset 调用都可以轻松撤消，但是 --hard 选项不能，因为它强制覆盖了工作目录中的文件。 在这种特殊情况下，我们的 Git 数据库中的一个提交内还留有该文件的 v3 版本，我们可以通过 reflog 来找回它。但是若该文件还未提交，Git 仍会覆盖它从而导致无法恢复。 回顾reset 命令会以特定的顺序重写这三棵树，在你指定以下选项时停止： 移动 HEAD 分支的指向 （若指定了 --soft，则到此停止） 使索引看起来像 HEAD （若未指定 --hard，则到此停止） 使工作目录看起来像索引 通过路径来重置前面讲述了 reset 基本形式的行为，不过你还可以给它提供一个作用路径。 若指定了一个路径，reset 将会跳过第 1 步，并且将它的作用范围限定为指定的文件或文件集合。 这样做自然有它的道理，因为 HEAD 只是一个指针，你无法让它同时指向两个提交中各自的一部分。 不过索引和工作目录 可以部分更新，所以重置会继续进行第 2、3 步。 现在，假如我们运行 git reset file.txt （这其实是 git reset --mixed HEAD file.txt 的简写形式，因为你既没有指定一个提交的 SHA-1 或分支，也没有指定 --soft 或 --hard），它会： 移动 HEAD 分支的指向 （已跳过） 让索引看起来像 HEAD （到此处停止） 所以它本质上只是将 file.txt 从 HEAD 复制到索引中。它还有 取消暂存文件 的实际效果。 如果我们查看该命令的示意图，然后再想想 git add 所做的事，就会发现它们正好相反。这就是为什么 git status 命令的输出会建议运行此命令来取消暂存一个文件。 （查看 取消暂存的文件 来了解更多。） 我们可以不让 Git 从 HEAD 拉取数据，而是通过具体指定一个提交来拉取该文件的对应版本。 我们只需运行类似于 git reset eb43bf file.txt 的命令即可。它其实做了同样的事情，也就是把工作目录中的文件恢复到 v1 版本，运行 git add 添加它，然后再将它恢复到 v3 版本（只是不用真的过一遍这些步骤）。 如果我们现在运行 git commit，它就会记录一条“将该文件恢复到 v1 版本”的更改，尽管我们并未在工作目录中真正地再次拥有它。 还有一点同 git add 一样，就是 reset 命令也可以接受一个 --patch 选项来一块一块地取消暂存的内容。 这样你就可以根据选择来取消暂存或恢复内容了。 压缩我们来看看如何利用这种新的功能来做一些有趣的事情 - 压缩提交。 假设你的一系列提交信息中有 “oops.”、“WIP” 和 “forgot this file”， 聪明的你就能使用 reset 来轻松快速地将它们压缩成单个提交，也显出你的聪明。 （压缩提交 展示了另一种方式，不过在本例中用 reset 更简单。） 假设你有一个项目，第一次提交中有一个文件，第二次提交增加了一个新的文件并修改了第一个文件，第三次提交再次修改了第一个文件。 由于第二次提交是一个未完成的工作，因此你想要压缩它。那么可以运行 git reset --soft HEAD~2 来将 HEAD 分支移动到一个旧一点的提交上（即你想要保留的第一个提交）：然后只需再次运行 git commit：现在你可以查看可到达的历史，即将会推送的历史，现在看起来有个 v1 版 file-a.txt 的提交，接着第二个提交将 file-a.txt 修改成了 v3 版并增加了 file-b.txt。 包含 v2 版本的文件已经不在历史中了。 检出最后，你大概还想知道 checkout 和 reset 之间的区别。 和 reset 一样，checkout 也操纵三棵树，不过它有一点不同，这取决于你是否传给该命令一个文件路径。 不带路径运行 git checkout [branch] 与运行 git reset --hard [branch] 非常相似，它会更新所有三棵树使其看起来像 [branch]，不过有两点重要的区别。 首先不同于 reset --hard，checkout 对工作目录是安全的，它会通过检查来确保不会将已更改的文件弄丢。 其实它还更聪明一些。它会在工作目录中先试着简单合并一下，这样所有还未修改过的文件都会被更新。 而 reset --hard 则会不做检查就全面地替换所有东西。 第二个重要的区别是如何更新 HEAD。 reset 会移动 HEAD 分支的指向，而 checkout 只会移动 HEAD 自身来指向另一个分支。 例如，假设我们有 master 和 develop 分支，它们分别指向不同的提交；我们现在在 develop 上（所以 HEAD 指向它）。 如果我们运行 git reset master，那么 develop 自身现在会和 master 指向同一个提交。 而如果我们运行 git checkout master 的话，develop 不会移动，HEAD 自身会移动。 现在 HEAD 将会指向 master。 所以，虽然在这两种情况下我们都移动 HEAD 使其指向了提交 A，但做法是非常不同的。 reset 会移动 HEAD 分支的指向，而 checkout 则移动 HEAD 自身。 带路径运行 checkout 的另一种方式就是指定一个文件路径，这会像 reset 一样不会移动 HEAD。 它就像 git reset [branch] file 那样用该次提交中的那个文件来更新索引，但是它也会覆盖工作目录中对应的文件。 它就像是 git reset --hard [branch] file（如果 reset 允许你这样运行的话）- 这样对工作目录并不安全，它也不会移动 HEAD。 此外，同 git reset 和 git add 一样，checkout 也接受一个 --patch 选项，允许你根据选择一块一块地恢复文件内容。 总结希望你现在熟悉并理解了 reset 命令，不过关于它和 checkout 之间的区别，你可能还是会有点困惑，毕竟不太可能记住不同调用的所有规则。 下面的速查表列出了命令对树的影响。 “HEAD” 一列中的 “REF” 表示该命令移动了 HEAD 指向的分支引用，而‘HEAD’&#39; 则表示只移动了 HEAD 自身。 特别注意 WD Safe? 一列 - 如果它标记为 NO，那么运行该命令之前请考虑一下。 | | HEAD | Index | Workdir | WD Safe? | | :-------- | :--------| :------ |:------ |:------ | | Commit Level | | | |reset –soft [commit]| REF | NO | NO | YES | |reset [commit]| REF | YES | NO | YES | |reset –hard [commit]| REF | YES | YES | NO | |checkout [commit]| HEAD | YES | YES | YES | | File Level | |reset (commit) [file]| NO | YES | NO | YES | |checkout (commit) [file]` | NO | YES | YES | NO |]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 工具 - 重写历史]]></title>
    <url>%2F2017%2F11%2F06%2Fgit-%E5%B7%A5%E5%85%B7-%E9%87%8D%E5%86%99%E5%8E%86%E5%8F%B2%2F</url>
    <content type="text"><![CDATA[重写历史许多时候，在使用 Git 时，可能会因为某些原因想要修正提交历史。 Git 很棒的一点是它允许你在最后时刻做决定。 你可以在将暂存区内容提交前决定哪些文件进入提交，可以通过 stash 命令来决定不与某些内容工作，也可以重写已经发生的提交就像它们以另一种方式发生的一样。 这可能涉及改变提交的顺序，改变提交中的信息或修改文件，将提交压缩或是拆分，或完全地移除提交 - 在将你的工作成果与他人共享之前。 在本节中，你可以学到如何完成这些非常有用的工作，这样在与他人分享你的工作成果时你的提交历史将如你所愿地展示出来。 修改最后一次提交修改你最近一次提交可能是所有修改历史提交的操作中最常见的一个。 对于你的最近一次提交，你往往想做两件事情：修改提交信息，或者修改你添加、修改和移除的文件的快照。 如果，你只是想修改最近一次提交的提交信息，那么很简单： $ git commit –amend这会把你带入文本编辑器，里面包含了你最近一条提交信息，供你修改。 当保存并关闭编辑器后，编辑器将会用你输入的内容替换最近一条提交信息。 如果你已经完成提交，又因为之前提交时忘记添加一个新创建的文件，想通过添加或修改文件来更改提交的快照，也可以通过类似的操作来完成。 通过修改文件然后运行 git add 或 git rm 一个已追踪的文件，随后运行 git commit --amend 拿走当前的暂存区域并使其做为新提交的快照。 使用这个技巧的时候需要小心，因为修正会改变提交的 SHA-1 校验和。 它类似于一个小的变基 - 如果已经推送了最后一次提交就不要修正它。 修改多个提交信息为了修改在提交历史中较远的提交，必须使用更复杂的工具。 Git 没有一个改变历史工具，但是可以使用变基工具来变基一系列提交，基于它们原来的 HEAD 而不是将其移动到另一个新的上面。 通过交互式变基工具，可以在任何想要修改的提交后停止，然后修改信息、添加文件或做任何想做的事情。 可以通过给 git rebase 增加 -i 选项来交互式地运行变基。 必须指定想要重写多久远的历史，这可以通过告诉命令将要变基到的提交来做到。 例如，如果想要修改最近三次提交信息，或者那组提交中的任意一个提交信息，将想要修改的最近一次提交的父提交作为参数传递给 git rebase -i命令，即 HEAD~2^ 或 HEAD~3。 记住 ~3 可能比较容易，因为你正尝试修改最后三次提交；但是注意实际上指定了以前的四次提交，即想要修改提交的父提交： $ git rebase -i HEAD~3再次记住这是一个变基命令 - 在 HEAD~3..HEAD 范围内的每一个提交都会被重写，无论你是否修改信息。 不要涉及任何已经推送到中央服务器的提交 - 这样做会产生一次变更的两个版本，因而使他人困惑。 运行这个命令会在文本编辑器上给你一个提交的列表，看起来像下面这样：123456789101112131415161718192021pick f7f3f6d changed my name a bitpick 310154e updated README formatting and added blamepick a5f4a0d added cat-file# Rebase 710f0f8..a5f4a0d onto 710f0f8## Commands:# p, pick = use commit# r, reword = use commit, but edit the commit message# e, edit = use commit, but stop for amending# s, squash = use commit, but meld into previous commit# f, fixup = like &quot;squash&quot;, but discard this commit&apos;s log message# x, exec = run command (the rest of the line) using shell## These lines can be re-ordered; they are executed from top to bottom.## If you remove a line here THAT COMMIT WILL BE LOST.## However, if you remove everything, the rebase will be aborted.## Note that empty commits are commented out 需要重点注意的是相对于正常使用的 log 命令，这些提交显示的顺序是相反的。 运行一次 log 命令，会看到类似这样的东西：1234$ git log --pretty=format:&quot;%h %s&quot; HEAD~3..HEADa5f4a0d added cat-file310154e updated README formatting and added blamef7f3f6d changed my name a bit 注意其中的反序显示。 交互式变基给你一个它将会运行的脚本。 它将会从你在命令行中指定的提交（HEAD~3）开始，从上到下的依次重演每一个提交引入的修改。 它将最旧的而不是最新的列在上面，因为那会是第一个将要重演的。 你需要修改脚本来让它停留在你想修改的变更上。 要达到这个目的，你只要将你想修改的每一次提交前面的 ‘pick’ 改为 ‘edit’。 例如，只想修改第三次提交信息，可以像下面这样修改文件：123edit f7f3f6d changed my name a bitpick 310154e updated README formatting and added blamepick a5f4a0d added cat-file 当保存并退出编辑器时，Git 将你带回到列表中的最后一次提交，把你送回命令行并提示以下信息：123456789$ git rebase -i HEAD~3Stopped at f7f3f6d... changed my name a bitYou can amend the commit now, with git commit --amendOnce you’re satisfied with your changes, run git rebase --continue 这些指令准确地告诉你该做什么。 输入 $ git commit –amend修改提交信息，然后退出编辑器。 然后，运行$ git rebase –continue这个命令将会自动地应用另外两个提交，然后就完成了。 如果需要将不止一处的 pick 改为 edit，需要在每一个修改为 edit 的提交上重复这些步骤。 每一次，Git 将会停止，让你修正提交，然后继续直到完成。 重新排序提交也可以使用交互式变基来重新排序或完全移除提交。 如果想要移除 “added cat-file” 提交然后修改另外两个提交引入的顺序，可以将变基脚本从这样：123pick f7f3f6d changed my name a bitpick 310154e updated README formatting and added blamepick a5f4a0d added cat-file 改为这样：12pick 310154e updated README formatting and added blamepick f7f3f6d changed my name a bit 当保存并退出编辑器时，Git 将你的分支带回这些提交的父提交，应用 310154e 然后应用 f7f3f6d，最后停止。 事实修改了那些提交的顺序并完全地移除了 “added cat-file” 提交。 压缩提交通过交互式变基工具，也可以将一连串提交压缩成一个单独的提交。 在变基信息中脚本给出了有用的指令：12345678910111213141516## Commands:# p, pick = use commit# r, reword = use commit, but edit the commit message# e, edit = use commit, but stop for amending# s, squash = use commit, but meld into previous commit# f, fixup = like &quot;squash&quot;, but discard this commit&apos;s log message# x, exec = run command (the rest of the line) using shell## These lines can be re-ordered; they are executed from top to bottom.## If you remove a line here THAT COMMIT WILL BE LOST.## However, if you remove everything, the rebase will be aborted.## Note that empty commits are commented out 如果，指定 “squash” 而不是 “pick” 或 “edit”，Git 将应用两者的修改并合并提交信息在一起。 所以，如果想要这三次提交变为一个提交，可以这样修改脚本：123pick f7f3f6d changed my name a bitsquash 310154e updated README formatting and added blamesquash a5f4a0d added cat-file 当保存并退出编辑器时，Git 应用所有的三次修改然后将你放到编辑器中来合并三次提交信息：1234567891011# This is a combination of 3 commits.# The first commit&apos;s message is:changed my name a bit# This is the 2nd commit message:updated README formatting and added blame# This is the 3rd commit message:added cat-file 当你保存之后，你就拥有了一个包含前三次提交的全部变更的提交。 拆分提交拆分一个提交会撤消这个提交，然后多次地部分地暂存与提交直到完成你所需次数的提交。 例如，假设想要拆分三次提交的中间那次提交。 想要将它拆分为两次提交：第一个 “updated README formatting”，第二个 “added blame” 来代替原来的 “updated README formatting and added blame”。 可以通过修改 rebase -i 的脚本来做到这点，将要拆分的提交的指令修改为 “edit”：123pick f7f3f6d changed my name a bitedit 310154e updated README formatting and added blamepick a5f4a0d added cat-file 然后，当脚本将你进入到命令行时，重置那个提交，拿到被重置的修改，从中创建几次提交。 当保存并退出编辑器时，Git 带你到列表中第一个提交的父提交，应用第一个提交（f7f3f6d），应用第二个提交（310154e），然后让你进入命令行。 那里，可以通过 git reset HEAD^ 做一次针对那个提交的混合重置，实际上将会撤消那次提交并将修改的文件未暂存。 现在可以暂存并提交文件直到有几个提交，然后当完成时运行 git rebase --continue：123456$ git reset HEAD^$ git add README$ git commit -m &apos;updated README formatting&apos;$ git add lib/simplegit.rb$ git commit -m &apos;added blame&apos;$ git rebase --continue Git 在脚本中应用最后一次提交（a5f4a0d），历史记录看起来像这样：12345$ git log -4 --pretty=format:&quot;%h %s&quot;1c002dd added cat-file9b29157 added blame35cfb2b updated README formattingf3cc40e changed my name a bit 再次强调，这些改动了所有在列表中的提交的 SHA-1 校验和，所以要确保列表中的提交还没有推送到共享仓库中。 核武器级选项：filter-branch有另一个历史改写的选项，如果想要通过脚本的方式改写大量提交的话可以使用它 - 例如，全局修改你的邮箱地址或从每一个提交中移除一个文件。 这个命令是 filter-branch，它可以改写历史中大量的提交，除非你的项目还没有公开并且其他人没有基于要改写的工作的提交做的工作，你不应当使用它。 然而，它可以很有用。 你将会学习到几个常用的用途，这样就得到了它适合使用地方的想法。 从每一个提交移除一个文件这经常发生。 有人粗心地通过 git add . 提交了一个巨大的二进制文件，你想要从所有地方删除它。 可能偶然地提交了一个包括一个密码的文件，然而你想要开源项目。 filter-branch 是一个可能会用来擦洗整个提交历史的工具。 为了从整个提交历史中移除一个叫做 passwords.txt 的文件，可以使用 --tree-filter 选项给 filter-branch：123$ git filter-branch --tree-filter &apos;rm -f passwords.txt&apos; HEADRewrite 6b9b3cf04e7c5686a9cb838c3f36a8cb6a0fc2bd (21/21)Ref &apos;refs/heads/master&apos; was rewritten --tree-filter 选项在检出项目的每一个提交后运行指定的命令然后重新提交结果。 在本例中，你从每一个快照中移除了一个叫作 passwords.txt 的文件，无论它是否存在。 如果想要移除所有偶然提交的编辑器备份文件，可以运行类似 git filter-branch --tree-filter &#39;rm -f *~&#39; HEAD 的命令。 最后将可以看到 Git 重写树与提交然后移动分支指针。 通常一个好的想法是在一个测试分支中做这件事，然后当你决定最终结果是真正想要的，可以硬重置 master 分支。 为了让 filter-branch 在所有分支上运行，可以给命令传递 --all 选项。 使一个子目录做为新的根目录假设已经从另一个源代码控制系统中导入，并且有几个没意义的子目录（trunk、tags 等等）。 如果想要让 trunk 子目录作为每一个提交的新的项目根目录，filter-branch 也可以帮助你那么做：123$ git filter-branch --subdirectory-filter trunk HEADRewrite 856f0bf61e41a27326cdae8f09fe708d679f596f (12/12)Ref &apos;refs/heads/master&apos; was rewritten 现在新项目根目录是 trunk 子目录了。 Git 会自动移除所有不影响子目录的提交。 全局修改邮箱地址另一个常见的情形是在你开始工作时忘记运行 git config 来设置你的名字与邮箱地址，或者你想要开源一个项目并且修改所有你的工作邮箱地址为你的个人邮箱地址。 任何情形下，你也可以通过 filter-branch 来一次性修改多个提交中的邮箱地址。 需要小心的是只修改你自己的邮箱地址，所以你使用 --commit-filter：123456789$ git filter-branch --commit-filter &apos; if [ &quot;$GIT_AUTHOR_EMAIL&quot; = &quot;schacon@localhost&quot; ]; then GIT_AUTHOR_NAME=&quot;Scott Chacon&quot;; GIT_AUTHOR_EMAIL=&quot;schacon@example.com&quot;; git commit-tree &quot;$@&quot;; else git commit-tree &quot;$@&quot;; fi&apos; HEAD 这会遍历并重写每一个提交来包含你的新邮箱地址。 因为提交包含了它们父提交的 SHA-1 校验和，这个命令会修改你的历史中的每一个提交的 SHA-1 校验和，而不仅仅只是那些匹配邮箱地址的提交。]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 工具 - 搜索]]></title>
    <url>%2F2017%2F11%2F06%2Fgit-%E5%B7%A5%E5%85%B7-%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[搜索无论仓库里的代码量有多少，你经常需要查找一个函数是在哪里调用或者定义的，或者一个方法的变更历史。 Git 提供了两个有用的工具来快速地从它的数据库中浏览代码和提交。 我们来简单的看一下。 Git GrepGit 提供了一个 grep 命令，你可以很方便地从提交历史或者工作目录中查找一个字符串或者正则表达式。 我们用 Git 本身源代码的查找作为例子。默认情况下 Git 会查找你工作目录的文件。 你可以传入 -n 参数来输出 Git 所找到的匹配行行号。1234567891011$ git grep -n gmtime_rcompat/gmtime.c:3:#undef gmtime_rcompat/gmtime.c:8: return git_gmtime_r(timep, &amp;result);compat/gmtime.c:11:struct tm *git_gmtime_r(const time_t *timep, struct tm *result)compat/gmtime.c:16: ret = gmtime_r(timep, result);compat/mingw.c:606:struct tm *gmtime_r(const time_t *timep, struct tm *result)compat/mingw.h:162:struct tm *gmtime_r(const time_t *timep, struct tm *result);date.c:429: if (gmtime_r(&amp;now, &amp;now_tm))date.c:492: if (gmtime_r(&amp;time, tm)) &#123;git-compat-util.h:721:struct tm *git_gmtime_r(const time_t *, struct tm *);git-compat-util.h:723:#define gmtime_r git_gmtime_r grep 命令有一些有趣的选项。 例如，你可以使用 --count 选项来使 Git 输出概述的信息，仅仅包括哪些文件包含匹配以及每个文件包含了多少个匹配。123456$ git grep --count gmtime_rcompat/gmtime.c:4compat/mingw.c:1compat/mingw.h:1date.c:2git-compat-util.h:2 如果你想看匹配的行是属于哪一个方法或者函数，你可以传入 -p 选项：12345$ git grep -p gmtime_r *.cdate.c=static int match_multi_number(unsigned long num, char c, const char *date, char *end, struct tm *tm)date.c: if (gmtime_r(&amp;now, &amp;now_tm))date.c=static int match_digit(const char *date, struct tm *tm, int *offset, int *tm_gmt)date.c: if (gmtime_r(&amp;time, tm)) &#123; 在这里我们可以看到在 date.c 文件中有 match_multi_number 和 match_digit 两个函数调用了 gmtime_r。 你还可以使用 –and 标志来查看复杂的字符串组合，也就是在同一行同时包含多个匹配。 比如，我们要查看在旧版本 1.8.0 的 Git 代码库中定义了常量名包含 “LINK” 或者 “BUF_MAX” 这两个字符串所在的行。 这里我们也用到了 --break 和 --heading 选项来使输出更加容易阅读。123456789101112131415161718192021$ git grep --break --heading \ -n -e &apos;#define&apos; --and \( -e LINK -e BUF_MAX \) v1.8.0v1.8.0:builtin/index-pack.c62:#define FLAG_LINK (1u&lt;&lt;20)v1.8.0:cache.h73:#define S_IFGITLINK 016000074:#define S_ISGITLINK(m) (((m) &amp; S_IFMT) == S_IFGITLINK)v1.8.0:environment.c54:#define OBJECT_CREATION_MODE OBJECT_CREATION_USES_HARDLINKSv1.8.0:strbuf.c326:#define STRBUF_MAXLINK (2*PATH_MAX)v1.8.0:symlinks.c53:#define FL_SYMLINK (1 &lt;&lt; 2)v1.8.0:zlib.c30:/* #define ZLIB_BUF_MAX ((uInt)-1) */31:#define ZLIB_BUF_MAX ((uInt) 1024 * 1024 * 1024) /* 1GB */ 相比于一些常用的搜索命令比如 grep 和 ack，git grep 命令有一些的优点。 第一就是速度非常快，第二是你不仅仅可以可以搜索工作目录，还可以搜索任意的 Git 树。 在上一个例子中，我们在一个旧版本的 Git 源代码中查找，而不是当前检出的版本。 Git 日志搜索或许你不想知道某一项在 哪里 ，而是想知道是什么 时候 存在或者引入的。 git log 命令有许多强大的工具可以通过提交信息甚至是 diff 的内容来找到某个特定的提交。 例如，如果我们想找到 ZLIB_BUF_MAX 常量是什么时候引入的，我们可以使用 -S 选项来显示新增和删除该字符串的提交。123$ git log -SZLIB_BUF_MAX --onelinee01503b zlib: allow feeding more than 4GB in one goef49a7a zlib: zlib can only process 4GB at a time 如果我们查看这些提交的 diff，我们可以看到在 ef49a7a 这个提交引入了常量，并且在 e01503b 这个提交中被修改了。 如果你希望得到更精确的结果，你可以使用 -G 选项来使用正则表达式搜索。 行日志搜索行日志搜索是另一个相当高级并且有用的日志搜索功能。 这是一个最近新增的不太知名的功能，但却是十分有用。 在 git log 后加上 -L 选项即可调用，它可以展示代码中一行或者一个函数的历史。 例如，假设我们想查看 zlib.c 文件中git_deflate_bound 函数的每一次变更，我们可以执行 git log -L :git_deflate_bound:zlib.c。 Git 会尝试找出这个函数的范围，然后查找历史记录，并且显示从函数创建之后一系列变更对应的补丁。12345678910111213141516171819202122232425262728293031323334$ git log -L :git_deflate_bound:zlib.ccommit ef49a7a0126d64359c974b4b3b71d7ad42ee3bcaAuthor: Junio C Hamano &lt;gitster@pobox.com&gt;Date: Fri Jun 10 11:52:15 2011 -0700 zlib: zlib can only process 4GB at a timediff --git a/zlib.c b/zlib.c--- a/zlib.c+++ b/zlib.c@@ -85,5 +130,5 @@-unsigned long git_deflate_bound(z_streamp strm, unsigned long size)+unsigned long git_deflate_bound(git_zstream *strm, unsigned long size) &#123;- return deflateBound(strm, size);+ return deflateBound(&amp;strm-&gt;z, size); &#125;commit 225a6f1068f71723a910e8565db4e252b3ca21faAuthor: Junio C Hamano &lt;gitster@pobox.com&gt;Date: Fri Jun 10 11:18:17 2011 -0700 zlib: wrap deflateBound() toodiff --git a/zlib.c b/zlib.c--- a/zlib.c+++ b/zlib.c@@ -81,0 +85,5 @@+unsigned long git_deflate_bound(z_streamp strm, unsigned long size)+&#123;+ return deflateBound(strm, size);+&#125;+ 如果 Git 无法计算出如何匹配你代码中的函数或者方法，你可以提供一个正则表达式。 例如，这个命令和上面的是等同的：git log -L &#39;/unsigned long git_deflate_bound/&#39;,/^}/:zlib.c。 你也可以提供单行或者一个范围的行号来获得相同的输出。]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 签署工作]]></title>
    <url>%2F2017%2F11%2F06%2Fgit-%E7%AD%BE%E7%BD%B2%E5%B7%A5%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[签署工作Git 虽然是密码级安全的，但它不是万无一失的。 如果你从因特网上的其他人那里拿取工作，并且想要验证提交是不是真正地来自于可信来源，Git 提供了几种通过 GPG 来签署和验证工作的方式。 GPG 介绍首先，在开始签名之前你需要先配置 GPG 并安装个人密钥。123456$ gpg --list-keys/Users/schacon/.gnupg/pubring.gpg---------------------------------pub 2048R/0A46826A 2014-06-04uid Scott Chacon (Git signing key) &lt;schacon@gmail.com&gt;sub 2048R/874529A9 2014-06-04 如果你还没有安装一个密钥，可以使用 gpg --gen-key生成一个。 gpg –gen-key一旦你有一个可以签署的私钥，可以通过设置 Git 的 user.signingkey 选项来签署。git config –global user.signingkey 0A46826A现在 Git 默认使用你的密钥来签署标签与提交。 签署标签如果已经设置好一个 GPG 私钥，可以使用它来签署新的标签。 所有需要做的只是使用 -s 代替 -a 即可：12345$ git tag -s v1.5 -m &apos;my signed 1.5 tag&apos;You need a passphrase to unlock the secret key foruser: &quot;Ben Straub &lt;ben@straub.cc&gt;&quot;2048-bit RSA key, ID 800430EB, created 2014-05-04 如果在那个标签上运行 git show，会看到你的 GPG 签名附属在后面：1234567891011121314151617181920212223$ git show v1.5tag v1.5Tagger: Ben Straub &lt;ben@straub.cc&gt;Date: Sat May 3 20:29:41 2014 -0700my signed 1.5 tag-----BEGIN PGP SIGNATURE-----Version: GnuPG v1iQEcBAABAgAGBQJTZbQlAAoJEF0+sviABDDrZbQH/09PfE51KPVPlanr6q1v4/UtLQxfojUWiLQdg2ESJItkcuweYg+kc3HCyFejeDIBw9dpXt00rY26p05qrpnG+85bhM1/PswpPLuBSr+oCIDj5GMC2r2iEKsfv2fJbNW8iWAXVLoWZRF8B0MfqX/YTMbmecorc4iXzQu7tupRihslbNkfvfciMnSDeSvzCpWAHl7h8Wj6hhqePmLm9lAYqnKp8S5B/1SSQuEAjRZgI4IexpZoeKGVDptPHxLLS38fozsyi0QyDyzEgJxcJQVMXxViRUysgqjcpT8+iQM1PblGfHR4XAhuOqN5Fx06PSaFZhqvWFezJ28/CLyX5q+oIVk==EFTF-----END PGP SIGNATURE-----commit ca82a6dff817ec66f44342007202690a93763949Author: Scott Chacon &lt;schacon@gee-mail.com&gt;Date: Mon Mar 17 21:52:11 2008 -0700 changed the version number 验证标签要验证一个签署的标签，可以运行 git tag -v [tag-name]。 这个命令使用 GPG 来验证签名。 为了验证能正常工作，签署者的公钥需要在你的钥匙链中。12345678910111213$ git tag -v v1.4.2.1object 883653babd8ee7ea23e6a5c392bb739348b1eb61type committag v1.4.2.1tagger Junio C Hamano &lt;junkio@cox.net&gt; 1158138501 -0700GIT 1.4.2.1Minor fixes since 1.4.2, including git-mv and git-http with alternates.gpg: Signature made Wed Sep 13 02:08:25 2006 PDT using DSA key ID F3119B9Agpg: Good signature from &quot;Junio C Hamano &lt;junkio@cox.net&gt;&quot;gpg: aka &quot;[jpeg image of size 1513]&quot;Primary key fingerprint: 3565 2A26 2040 E066 C9A7 4A7D C0C6 D9A4 F311 9B9A 如果没有签署者的公钥，那么你将会得到类似下面的东西：123gpg: Signature made Wed Sep 13 02:08:25 2006 PDT using DSA key ID F3119B9Agpg: Can&apos;t check signature: public key not founderror: could not verify the tag &apos;v1.4.2.1&apos; 签署提交在最新版本的 Git 中（v1.7.9 及以上），也可以签署个人提交。 如果相对于标签而言你对直接签署到提交更感兴趣的话，所有要做的只是增加一个 -S 到 git commit 命令。12345678910$ git commit -a -S -m &apos;signed commit&apos;You need a passphrase to unlock the secret key foruser: &quot;Scott Chacon (Git signing key) &lt;schacon@gmail.com&gt;&quot;2048-bit RSA key, ID 0A46826A, created 2014-06-04[master 5c3386c] signed commit 4 files changed, 4 insertions(+), 24 deletions(-) rewrite Rakefile (100%) create mode 100644 lib/git.rb git log 也有一个 --show-signature 选项来查看及验证这些签名。12345678$ git log --show-signature -1commit 5c3386cf54bba0a33a32da706aa52bc0155503c2gpg: Signature made Wed Jun 4 19:49:17 2014 PDT using RSA key ID 0A46826Agpg: Good signature from &quot;Scott Chacon (Git signing key) &lt;schacon@gmail.com&gt;&quot;Author: Scott Chacon &lt;schacon@gmail.com&gt;Date: Wed Jun 4 19:49:17 2014 -0700 signed commit 另外，也可以配置 git log 来验证任何找到的签名并将它们以 %G? 格式列在输出中。123456$ git log --pretty=&quot;format:%h %G? %aN %s&quot;5c3386c G Scott Chacon signed commitca82a6d N Scott Chacon changed the version number085bb3b N Scott Chacon removed unnecessary test codea11bef0 N Scott Chacon first commit 这里我们可以看到只有最后一次提交是签署并有效的，而之前的提交都不是。 在 Git 1.8.3 及以后的版本中，“git merge” 与“git pull” 可以使用 --verify-signatures 选项来检查并拒绝没有携带可信 GPG 签名的提交。 如果使用这个选项来合并一个包含未签名或有效的提交的分支时，合并不会生效。12$ git merge --verify-signatures non-verifyfatal: Commit ab06180 does not have a GPG signature. 如果合并包含的只有有效的签名的提交，合并命令会提示所有的签名它已经检查过了然后会继续向前。123456$ git merge --verify-signatures signed-branchCommit 13ad65e has a good GPG signature by Scott Chacon (Git signing key) &lt;schacon@gmail.com&gt;Updating 5c3386c..13ad65eFast-forward README | 2 ++ 1 file changed, 2 insertions(+) 也可以给 git merge 命令附加 -S 选项来签署自己生成的合并提交。 下面的例子演示了验证将要合并的分支的每一个提交都是签名的并且签署最后生成的合并提交。12345678910$ git merge --verify-signatures -S signed-branchCommit 13ad65e has a good GPG signature by Scott Chacon (Git signing key) &lt;schacon@gmail.com&gt;You need a passphrase to unlock the secret key foruser: &quot;Scott Chacon (Git signing key) &lt;schacon@gmail.com&gt;&quot;2048-bit RSA key, ID 0A46826A, created 2014-06-04Merge made by the &apos;recursive&apos; strategy. README | 2 ++ 1 file changed, 2 insertions(+) 每个人必须签署签署标签与提交很棒，但是如果决定在正常的工作流程中使用它，你必须确保团队中的每一个人都理解如何这样做。 如果没有，你将会花费大量时间帮助其他人找出并用签名的版本重写提交。 在采用签署成为标准工作流程的一部分前，确保你完全理解 GPG 及签署带来的好处。]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 储藏与清理]]></title>
    <url>%2F2017%2F11%2F06%2Fgit-%E5%82%A8%E8%97%8F%E4%B8%8E%E6%B8%85%E7%90%86%2F</url>
    <content type="text"><![CDATA[储藏与清理有时，当你在项目的一部分上已经工作一段时间后，所有东西都进入了混乱的状态，而这时你想要切换到另一个分支做一点别的事情。 问题是，你不想仅仅因为过会儿回到这一点而为做了一半的工作创建一次提交。 针对这个问题的答案是 git stash 命令。 储藏会处理工作目录的脏的状态 - 即，修改的跟踪文件与暂存改动 - 然后将未完成的修改保存到一个栈上，而你可以在任何时候重新应用这些改动。 储藏工作为了演示，进入项目并改动几个文件，然后可能暂存其中的一个改动。 如果运行 git status，可以看到有改动的状态：1234567891011$ git statusChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: index.htmlChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: lib/simplegit.rb 现在想要切换分支，但是还不想要提交之前的工作；所以储藏修改。 将新的储藏推送到栈上，运行 git stash 或 git stash save：12345$ git stashSaved working directory and index state \ &quot;WIP on master: 049d078 added the index file&quot;HEAD is now at 049d078 added the index file(To restore them type &quot;git stash apply&quot;) 工作目录是干净的了：123$ git status# On branch masternothing to commit, working directory clean 在这时，你能够轻易地切换分支并在其他地方工作；你的修改被存储在栈上。 要查看储藏的东西，可以使用 git stash list：1234$ git stash liststash@&#123;0&#125;: WIP on master: 049d078 added the index filestash@&#123;1&#125;: WIP on master: c264051 Revert &quot;added file_size&quot;stash@&#123;2&#125;: WIP on master: 21d80a5 added number to log 在本例中，有两个之前做的储藏，所以你接触到了三个不同的储藏工作。 可以通过原来 stash 命令的帮助提示中的命令将你刚刚储藏的工作重新应用：git stash apply。 如果想要应用其中一个更旧的储藏，可以通过名字指定它，像这样：git stash apply stash@{2}。 如果不指定一个储藏，Git 认为指定的是最近的储藏：12345678$ git stash apply# On branch master# Changed but not updated:# (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)## modified: index.html# modified: lib/simplegit.rb# 可以看到 Git 重新修改了当你保存储藏时撤消的文件。 在本例中，当尝试应用储藏时有一个干净的工作目录，并且尝试将它应用在保存它时所在的分支；但是有一个干净的工作目录与应用在同一分支并不是成功应用储藏的充分必要条件。 可以在一个分支上保存一个储藏，切换到另一个分支，然后尝试重新应用这些修改。 当应用储藏时工作目录中也可以有修改与未提交的文件 - 如果有任何东西不能干净地应用，Git 会产生合并冲突。 文件的改动被重新应用了，但是之前暂存的文件却没有重新暂存。 想要那样的话，必须使用 --index 选项来运行 git stash apply 命令，来尝试重新应用暂存的修改。 如果已经那样做了，那么你将回到原来的位置：123456789101112$ git stash apply --index# On branch master# Changes to be committed:# (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)## modified: index.html## Changed but not updated:# (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)## modified: lib/simplegit.rb# 应用选项只会尝试应用暂存的工作 - 在堆栈上还有它。 可以运行 git stash drop 加上将要移除的储藏的名字来移除它：123456$ git stash liststash@&#123;0&#125;: WIP on master: 049d078 added the index filestash@&#123;1&#125;: WIP on master: c264051 Revert &quot;added file_size&quot;stash@&#123;2&#125;: WIP on master: 21d80a5 added number to log$ git stash drop stash@&#123;0&#125;Dropped stash@&#123;0&#125; (364e91f3f268f0900bc3ee613f9f733e82aaed43) 也可以运行 git stash pop 来应用储藏然后立即从栈上扔掉它。 创造性的储藏有几个储藏的变种可能也很有用。 第一个非常流行的选项是 stash save 命令的 --keep-index 选项。 它告诉 Git 不要储藏任何你通过 git add 命令已暂存的东西。 当你做了几个改动并只想提交其中的一部分，过一会儿再回来处理剩余改动时，这个功能会很有用。12345678910$ git status -sM index.html M lib/simplegit.rb$ git stash --keep-indexSaved working directory and index state WIP on master: 1b65b17 added the index fileHEAD is now at 1b65b17 added the index file$ git status -sM index.html 另一个经常使用储藏来做的事情是像储藏跟踪文件一样储藏未跟踪文件。 默认情况下，git stash 只会储藏已经在索引中的文件。 如果指定 --include-untracked 或 -u 标记，Git 也会储藏任何创建的未跟踪文件。1234567891011$ git status -sM index.html M lib/simplegit.rb?? new-file.txt$ git stash -uSaved working directory and index state WIP on master: 1b65b17 added the index fileHEAD is now at 1b65b17 added the index file$ git status -s$ 最终，如果指定了 --patch 标记，Git 不会储藏所有修改过的任何东西，但是会交互式地提示哪些改动想要储藏、哪些改动需要保存在工作目录中。12345678910111213141516171819$ git stash --patchdiff --git a/lib/simplegit.rb b/lib/simplegit.rbindex 66d332e..8bb5674 100644--- a/lib/simplegit.rb+++ b/lib/simplegit.rb@@ -16,6 +16,10 @@ class SimpleGit return `#&#123;git_cmd&#125; 2&gt;&amp;1`.chomp end end++ def show(treeish = &apos;master&apos;)+ command(&quot;git show #&#123;treeish&#125;&quot;)+ end end testStash this hunk [y,n,q,a,d,/,e,?]? ySaved working directory and index state WIP on master: 1b65b17 added the index file 从储藏创建一个分支如果储藏了一些工作，将它留在那儿了一会儿，然后继续在储藏的分支上工作，在重新应用工作时可能会有问题。 如果应用尝试修改刚刚修改的文件，你会得到一个合并冲突并不得不解决它。 如果想要一个轻松的方式来再次测试储藏的改动，可以运行 git stash branch 创建一个新分支，检出储藏工作时所在的提交，重新在那应用工作，然后在应用成功后扔掉储藏：1234567891011121314$ git stash branch testchangesSwitched to a new branch &quot;testchanges&quot;# On branch testchanges# Changes to be committed:# (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)## modified: index.html## Changed but not updated:# (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)## modified: lib/simplegit.rb#Dropped refs/stash@&#123;0&#125; (f0dfc4d5dc332d1cee34a634182e168c4efc3359) 这是在新分支轻松恢复储藏工作并继续工作的一个很不错的途径。 清理工作目录对于工作目录中一些工作或文件，你想做的也许不是储藏而是移除。 git clean 命令会帮你做这些事。 有一些通用的原因比如说为了移除由合并或外部工具生成的东西，或是为了运行一个干净的构建而移除之前构建的残留。 你需要谨慎地使用这个命令，因为它被设计为从工作目录中移除未被追踪的文件。 如果你改变主意了，你也不一定能找回来那些文件的内容。 一个更安全的选项是运行 git stash --all 来移除每一样东西并存放在栈中。 你可以使用git clean命令去除冗余文件或者清理工作目录。 使用git clean -f -d命令来移除工作目录中所有未追踪的文件以及空的子目录。 -f 意味着 强制 或 “确定移除”。 如果只是想要看看它会做什么，可以使用 -n 选项来运行命令，这意味着 “做一次演习然后告诉你 将要 移除什么”。123$ git clean -d -nWould remove test.oWould remove tmp/ 默认情况下，git clean 命令只会移除没有忽略的未跟踪文件。 任何与 .gitiignore 或其他忽略文件中的模式匹配的文件都不会被移除。 如果你也想要移除那些文件，例如为了做一次完全干净的构建而移除所有由构建生成的 .o 文件，可以给 clean 命令增加一个 -x 选项。12345678910111213$ git status -s M lib/simplegit.rb?? build.TMP?? tmp/$ git clean -n -dWould remove build.TMPWould remove tmp/$ git clean -n -d -xWould remove build.TMPWould remove test.oWould remove tmp/ 如果不知道 git clean 命令将会做什么，在将 -n 改为 -f 来真正做之前总是先用 -n 来运行它做双重检查。 另一个小心处理过程的方式是使用 -i 或 “interactive” 标记来运行它。 这将会以交互模式运行 clean 命令。1234567$ git clean -x -iWould remove the following items: build.TMP test.o*** Commands *** 1: clean 2: filter by pattern 3: select by numbers 4: ask each 5: quit 6: helpWhat now&gt; 这种方式下可以分别地检查每一个文件或者交互地指定删除的模式。]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 交互式暂存]]></title>
    <url>%2F2017%2F11%2F06%2Fgit-%E4%BA%A4%E4%BA%92%E5%BC%8F%E6%9A%82%E5%AD%98%2F</url>
    <content type="text"><![CDATA[交互式暂存Git 自带的一些脚本可以使在命令行下工作更容易。 本节的几个互交命令可以帮助你将文件的特定部分组合成提交。 当你修改一组文件后，希望这些改动能放到若干提交而不是混杂在一起成为一个提交时，这几个工具会非常有用。 通过这种方式，可以确保提交是逻辑上独立的变更集，同时也会使其他开发者在与你工作时很容易地审核。 如果运行 git add 时使用 -i 或者 --interactive 选项，Git 将会进入一个交互式终端模式，显示类似下面的东西：12345678910$ git add -i staged unstaged path 1: unchanged +0/-1 TODO 2: unchanged +1/-1 index.html 3: unchanged +5/-1 lib/simplegit.rb*** Commands *** 1: status 2: update 3: revert 4: add untracked 5: patch 6: diff 7: quit 8: helpWhat now&gt; 可以看到这个命令以非常不同的视图显示了暂存区 - 基本上与 git status 是相同的信息，但是更简明扼要一些。 它将暂存的修改列在左侧，未暂存的修改列在右侧。 在这块区域后是命令区域。 在这里你可以做一些工作，包括暂存文件、取消暂存文件、暂存文件的一部分、添加未被追踪的文件、查看暂存内容的区别。 暂存与取消暂存文件如果在 What now&gt; 提示符后键入 2 或 u，脚本将会提示想要暂存哪个文件：123456What now&gt; 2 staged unstaged path 1: unchanged +0/-1 TODO 2: unchanged +1/-1 index.html 3: unchanged +5/-1 lib/simplegit.rbUpdate&gt;&gt; 要暂存 TODO 与 index.html 文件，可以输入数字：123456Update&gt;&gt; 1,2 staged unstaged path* 1: unchanged +0/-1 TODO* 2: unchanged +1/-1 index.html 3: unchanged +5/-1 lib/simplegit.rbUpdate&gt;&gt; 每个文件前面的 * 意味着选中的文件将会被暂存。 如果在 Update&gt;&gt; 提示符后不输入任何东西并直接按回车，Git 将会暂存之前选择的文件：1234567891011Update&gt;&gt;updated 2 paths*** Commands *** 1: status 2: update 3: revert 4: add untracked 5: patch 6: diff 7: quit 8: helpWhat now&gt; 1 staged unstaged path 1: +0/-1 nothing TODO 2: +1/-1 nothing index.html 3: unchanged +5/-1 lib/simplegit.rb 现在可以看到 TODO 与 index.html 文件已经被暂存而 simplegit.rb 文件还未被暂存。 如果这时想要取消暂存 TODO 文件，使用 3 或 r（撤消）选项：123456789101112131415*** Commands *** 1: status 2: update 3: revert 4: add untracked 5: patch 6: diff 7: quit 8: helpWhat now&gt; 3 staged unstaged path 1: +0/-1 nothing TODO 2: +1/-1 nothing index.html 3: unchanged +5/-1 lib/simplegit.rbRevert&gt;&gt; 1 staged unstaged path* 1: +0/-1 nothing TODO 2: +1/-1 nothing index.html 3: unchanged +5/-1 lib/simplegit.rbRevert&gt;&gt; [enter]reverted one path 再次查看 Git 状态，可以看到已经取消暂存 TODO 文件：12345678*** Commands *** 1: status 2: update 3: revert 4: add untracked 5: patch 6: diff 7: quit 8: helpWhat now&gt; 1 staged unstaged path 1: unchanged +0/-1 TODO 2: +1/-1 nothing index.html 3: unchanged +5/-1 lib/simplegit.rb 如果想要查看已暂存内容的区别，可以使用 6 或 d（区别）命令。 它会显示暂存文件的一个列表，可以从中选择想要查看的暂存区别。 这跟你在命令行指定 git diff --cached 非常相似：12345678910111213141516171819*** Commands *** 1: status 2: update 3: revert 4: add untracked 5: patch 6: diff 7: quit 8: helpWhat now&gt; 6 staged unstaged path 1: +1/-1 nothing index.htmlReview diff&gt;&gt; 1diff --git a/index.html b/index.htmlindex 4d07108..4335f49 100644--- a/index.html+++ b/index.html@@ -16,7 +16,7 @@ Date Finder &lt;p id=&quot;out&quot;&gt;...&lt;/p&gt;-&lt;div id=&quot;footer&quot;&gt;contact : support@github.com&lt;/div&gt;+&lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; 通过这些基本命令，可以使用交互式添加模式来轻松地处理暂存区。 暂存补丁Git 也可以暂存文件的特定部分。 例如，如果在 simplegit.rb 文件中做了两处修改，但只想要暂存其中的一个而不是另一个，Git 会帮你轻松地完成。 从交互式提示符中，输入 5 或 p（补丁）。 Git 会询问你想要部分暂存哪些文件；然后，对已选择文件的每一个部分，它都会一个个地显示文件区别并询问你是否想要暂存它们：1234567891011121314diff --git a/lib/simplegit.rb b/lib/simplegit.rbindex dd5ecc4..57399e0 100644--- a/lib/simplegit.rb+++ b/lib/simplegit.rb@@ -22,7 +22,7 @@ class SimpleGit end def log(treeish = &apos;master&apos;)- command(&quot;git log -n 25 #&#123;treeish&#125;&quot;)+ command(&quot;git log -n 30 #&#123;treeish&#125;&quot;) end def blame(path)Stage this hunk [y,n,a,d,/,j,J,g,e,?]? 这时有很多选项。 输入 ? 显示所有可以使用的命令列表：1234567891011121314Stage this hunk [y,n,a,d,/,j,J,g,e,?]? ?y - stage this hunkn - do not stage this hunka - stage this and all the remaining hunks in the filed - do not stage this hunk nor any of the remaining hunks in the fileg - select a hunk to go to/ - search for a hunk matching the given regexj - leave this hunk undecided, see next undecided hunkJ - leave this hunk undecided, see next hunkk - leave this hunk undecided, see previous undecided hunkK - leave this hunk undecided, see previous hunks - split the current hunk into smaller hunkse - manually edit the current hunk? - print help 通常情况下可以输入 y 或 n 来选择是否要暂存每一个区块，当然，暂存特定文件中的所有部分或为之后的选择跳过一个区块也是非常有用的。 如果你只暂存文件的一部分，状态输出可能会像下面这样：12345What now&gt; 1 staged unstaged path 1: unchanged +0/-1 TODO 2: +1/-1 nothing index.html 3: +1/-1 +4/-0 lib/simplegit.rb simplegit.rb 文件的状态很有趣。 它显示出若干行被暂存与若干行未被暂存。 已经部分地暂存了这个文件。 在这时，可以退出交互式添加脚本并且运行 git commit 来提交部分暂存的文件。 也可以不必在交互式添加模式中做部分文件暂存 - 可以在命令行中使用 git add -p 或 git add --patch 来启动同样的脚本。 更进一步地，可以使用 reset --patch 命令的补丁模式来部分重置文件，通过 checkout --patch 命令来部分检出文件与 stash save --patch 命令来部分暂存文件。 我们将会在接触这些命令的高级使用方法时了解更多详细信息。]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 修订版本（Revision）选择]]></title>
    <url>%2F2017%2F11%2F06%2Fgit-%E4%BF%AE%E8%AE%A2%E7%89%88%E6%9C%AC%EF%BC%88Revision%EF%BC%89%E9%80%89%E6%8B%A9%2F</url>
    <content type="text"><![CDATA[修订版本（Revision）选择Git 允许你通过几种方法来指明特定的或者一定范围内的提交。了解它们并不是必需的，但是了解一下总没坏处。 单个修订版本显然你可以使用给出的 SHA-1 值来指明一次提交，不过也有更加人性化的方法来做同样的事。本节概述了指明单个提交的诸多方法。 简短的SHAGit 很聪明，它能够通过你提供的前几个字符来识别你想要的那次提交，只要你提供的那部分 SHA-1 不短于四个字符，并且没有歧义——也就是说，当前仓库中只有一个对象以这段 SHA-1 开头。例如，想要查看一次指定的提交，假设你运行 git log 命令并找到你增加了功能的那次提交：12345678910111213141516171819$ git logcommit 734713bc047d87bf7eac9674765ae793478c50d3Author: Scott Chacon &lt;schacon@gmail.com&gt;Date: Fri Jan 2 18:32:33 2009 -0800 fixed refs handling, added gc auto, updated testscommit d921970aadf03b3cf0e71becdaab3147ba71cdefMerge: 1c002dd... 35cfb2b...Author: Scott Chacon &lt;schacon@gmail.com&gt;Date: Thu Dec 11 15:08:43 2008 -0800 Merge commit &apos;phedders/rdocs&apos;commit 1c002dd4b536e7479fe34593e72e6c6c1819e53bAuthor: Scott Chacon &lt;schacon@gmail.com&gt;Date: Thu Dec 11 14:58:32 2008 -0800 added some blame and merge stuff 假设是 1c002dd.... 。如果你想 git show 这次提交，下面的命令是等价的（假设简短的版本没有歧义）：123$ git show 1c002dd4b536e7479fe34593e72e6c6c1819e53b$ git show 1c002dd4b536e7479f$ git show 1c002d Git 可以为你的 SHA-1 值生成出简短且唯一的缩写。如果你传递 --abbrev-commit 给 git log 命令，输出结果里就会使用简短且唯一的值；它默认使用七个字符来表示，不过必要时为了避免 SHA-1 的歧义，会增加字符数：1234$ git log --abbrev-commit --pretty=onelineca82a6d changed the version number085bb3b removed unnecessary test codea11bef0 first commit 通常在一个项目中，使用八到十个字符来避免 SHA-1 歧义已经足够了。最大的 Git 项目之一，Linux 内核，目前也只需要最长 40 个字符中的 12 个字符来保持唯一性。 关于 SHA-1 的简短说明许多人可能会担心一个问题：在随机的偶然情况下，在他们的仓库里会出现两个具有相同 SHA-1 值的对象。那会怎么样呢？ 如果你真的向仓库里提交了一个跟之前的某个对象具有相同 SHA-1 值的对象，Git 将会发现之前的那个对象已经存在在 Git 数据库中，并认为它已经被写入了。如果什么时候你想再次检出那个对象时，你会总是得到先前的那个对象的数据。 不过，你应该了解到，这种情况发生的概率是多么微小。SHA-1 摘要长度是 20 字节，也就是 160 位。为了保证有 50% 的概率出现一次冲突，需要 2^80 个随机哈希的对象（计算冲突机率的公式是 p = (n(n-1)/2) * (1/2^160))。2^80 是 1.2 x 10^24，也就是一亿亿亿，那是地球上沙粒总数的 1200 倍。 现在举例说一下怎样才能产生一次 SHA-1 冲突。如果地球上 65 亿的人类都在编程，每人每秒都在产生等价于整个 Linux 内核历史（一百万个 Git 对象）的代码，并将之提交到一个巨大的 Git 仓库里面，那将花费 5 年的时间才会产生足够的对象，使其拥有 50% 的概率产生一次 SHA-1 对象冲突。这要比你编程团队的成员同一个晚上在互不相干的意外中被狼袭击并杀死的机率还要小。 分支引用指明一次提交的最直接的方法要求有一个指向它的分支引用。这样，你就可以在任何需要一个提交对象或者 SHA-1 值的 Git 命令中使用该分支名称了。如果你想要显示一个分支的最后一次提交的对象，例如假设 topic1 分支指向 ca82a6d，那么下面的命令是等价的：12$ git show ca82a6dff817ec66f44342007202690a93763949$ git show topic1 如果你想知道某个分支指向哪个特定的 SHA，或者想看任何一个例子中被简写的 SHA-1，你可以使用一个叫做 rev-parse 的 Git 探测工具。在第 9 章你可以看到关于探测工具的更多信息；简单来说，rev-parse 是为了底层操作而不是日常操作设计的。不过，有时你想看 Git 现在到底处于什么状态时，它可能会很有用。这里你可以对你的分支运执行 rev-parse。12$ git rev-parse topic1ca82a6dff817ec66f44342007202690a93763949 引用日志里的简称在你工作的同时，Git 在后台的工作之一就是保存一份引用日志——一份记录最近几个月你的 HEAD 和分支引用的日志。 你可以使用 git reflog 来查看引用日志：12345678$ git reflog734713b HEAD@&#123;0&#125;: commit: fixed refs handling, added gc auto, updatedd921970 HEAD@&#123;1&#125;: merge phedders/rdocs: Merge made by recursive.1c002dd HEAD@&#123;2&#125;: commit: added some blame and merge stuff1c36188 HEAD@&#123;3&#125;: rebase -i (squash): updating HEAD95df984 HEAD@&#123;4&#125;: commit: # This is a combination of two commits.1c36188 HEAD@&#123;5&#125;: rebase -i (squash): updating HEAD7e05da5 HEAD@&#123;6&#125;: rebase -i (pick): updating HEAD 每次你的分支顶端因为某些原因被修改时，Git 就会为你将信息保存在这个临时历史记录里面。你也可以使用这份数据来指明更早的分支。如果你想查看仓库中 HEAD 在五次前的值，你可以使用引用日志的输出中的 @{n} 引用： $ git show HEAD@{5}你也可以使用这个语法来查看某个分支在一定时间前的位置。例如，想看你的 master 分支昨天在哪，你可以输入$ git show master@{yesterday}它就会显示昨天分支的顶端在哪。这项技术只对还在你引用日志里的数据有用，所以不能用来查看比几个月前还早的提交。 想要看类似于 git log 输出格式的引用日志信息，你可以运行 git log -g：12345678910111213141516$ git log -g mastercommit 734713bc047d87bf7eac9674765ae793478c50d3Reflog: master@&#123;0&#125; (Scott Chacon &lt;schacon@gmail.com&gt;)Reflog message: commit: fixed refs handling, added gc auto, updatedAuthor: Scott Chacon &lt;schacon@gmail.com&gt;Date: Fri Jan 2 18:32:33 2009 -0800 fixed refs handling, added gc auto, updated testscommit d921970aadf03b3cf0e71becdaab3147ba71cdefReflog: master@&#123;1&#125; (Scott Chacon &lt;schacon@gmail.com&gt;)Reflog message: merge phedders/rdocs: Merge made by recursive.Author: Scott Chacon &lt;schacon@gmail.com&gt;Date: Thu Dec 11 15:08:43 2008 -0800 Merge commit &apos;phedders/rdocs&apos; 需要注意的是，引用日志信息只存在于本地——这是一个记录你在你自己的仓库里做过什么的日志。其他人拷贝的仓库里的引用日志不会和你的相同；而你新克隆一个仓库的时候，引用日志是空的，因为你在仓库里还没有操作。git show HEAD@{2.months.ago} 这条命令只有在你克隆了一个项目至少两个月时才会有用——如果你是五分钟前克隆的仓库，那么它将不会有结果返回。 祖先引用另一种指明某次提交的常用方法是通过它的祖先。如果你在引用最后加上一个 ^，Git 将其理解为此次提交的父提交。 假设你的工程历史是这样的：123456789$ git log --pretty=format:&apos;%h %s&apos; --graph* 734713b fixed refs handling, added gc auto, updated tests* d921970 Merge commit &apos;phedders/rdocs&apos;|\| * 35cfb2b Some rdoc changes* | 1c002dd added some blame and merge stuff|/* 1c36188 ignore *.gem* 9b29157 add open3_detach to gemspec file list 那么，想看上一次提交，你可以使用 HEAD^，意思是“HEAD 的父提交”1234567$ git show HEAD^commit d921970aadf03b3cf0e71becdaab3147ba71cdefMerge: 1c002dd... 35cfb2b...Author: Scott Chacon &lt;schacon@gmail.com&gt;Date: Thu Dec 11 15:08:43 2008 -0800 Merge commit &apos;phedders/rdocs&apos; 你也可以在 ^ 后添加一个数字——例如，d921970^2 意思是“d921970 的第二父提交”。这种语法只在合并提交时有用，因为合并提交可能有多个父提交。第一父提交是你合并时所在分支，而第二父提交是你所合并的分支：12345678910111213$ git show d921970^commit 1c002dd4b536e7479fe34593e72e6c6c1819e53bAuthor: Scott Chacon &lt;schacon@gmail.com&gt;Date: Thu Dec 11 14:58:32 2008 -0800 added some blame and merge stuff$ git show d921970^2commit 35cfb2b795a55793d7cc56a6cc2060b4bb732548Author: Paul Hedderly &lt;paul+git@mjr.org&gt;Date: Wed Dec 10 22:22:03 2008 +0000 Some rdoc changes 另外一个指明祖先提交的方法是 ~。这也是指向第一父提交，所以 HEAD~ 和 HEAD^ 是等价的。当你指定数字的时候就明显不一样了。HEAD~2 是指“第一父提交的第一父提交”，也就是“祖父提交”——它会根据你指定的次数检索第一父提交。例如，在上面列出的历史记录里面，HEAD~3 会是123456$ git show HEAD~3commit 1c3618887afb5fbcbea25b7c013f4e2114448b8dAuthor: Tom Preston-Werner &lt;tom@mojombo.com&gt;Date: Fri Nov 7 13:47:59 2008 -0500 ignore *.gem 也可以写成HEAD^^^，同样是第一父提交的第一父提交的第一父提交：123456$ git show HEAD^^^commit 1c3618887afb5fbcbea25b7c013f4e2114448b8dAuthor: Tom Preston-Werner &lt;tom@mojombo.com&gt;Date: Fri Nov 7 13:47:59 2008 -0500 ignore *.gem 你也可以混合使用这些语法——你可以通过 HEAD~3^2 指明先前引用的第二父提交（假设它是一个合并提交）。 提交范围现在你已经可以指明单次的提交，让我们来看看怎样指明一定范围的提交。这在你管理分支的时候尤显重要——如果你有很多分支，你可以指明范围来圈定一些问题的答案，比如：“这个分支上我有哪些工作还没合并到主分支的？” 双点最常用的指明范围的方法是双点的语法。这种语法主要是让 Git 区分出可从一个分支中获得而不能从另一个分支中获得的提交。例如，假设你有类似于图 6-1 的提交历史。图 6-1. 范围选择的提交历史实例你想要查看你的试验分支上哪些没有被提交到主分支，那么你就可以使用 master..experiment 来让 Git 显示这些提交的日志——这句话的意思是“所有可从experiment分支中获得而不能从master分支中获得的提交”。为了使例子简单明了，我使用了图标中提交对象的字母来代替真实日志的输出，所以会显示：123$ git log master..experimentDC 另一方面，如果你想看相反的——所有在 master 而不在 experiment 中的分支——你可以交换分支的名字。experiment..master 显示所有可在 master 获得而在 experiment 中不能的提交：123$ git log experiment..masterFE 这在你想保持 experiment 分支最新和预览你将合并的提交的时候特别有用。这个语法的另一种常见用途是查看你将把什么推送到远程： $ git log origin/master..HEAD这条命令显示任何在你当前分支上而不在远程origin 上的提交。如果你运行 git push 并且的你的当前分支正在跟踪 origin/master，被git log origin/master..HEAD 列出的提交就是将被传输到服务器上的提交。 你也可以留空语法中的一边来让 Git 来假定它是 HEAD。例如，输入 git log origin/master.. 将得到和上面的例子一样的结果—— Git 使用 HEAD 来代替不存在的一边。 多点双点语法就像速记一样有用；但是你也许会想针对两个以上的分支来指明修订版本，比如查看哪些提交被包含在某些分支中的一个，但是不在你当前的分支上。Git允许你在引用前使用^字符或者--not指明你不希望提交被包含其中的分支。因此下面三个命令是等同的：123$ git log refA..refB$ git log ^refA refB$ git log refB --not refA 这样很好，因为它允许你在查询中指定多于两个的引用，而这是双点语法所做不到的。例如，如果你想查找所有从refA或refB包含的但是不被refC包含的提交，你可以输入下面中的一个12$ git log refA refB ^refC$ git log refA refB --not refC 这建立了一个非常强大的修订版本查询系统，应该可以帮助你解决分支里包含了什么这个问题。 三点最后一种主要的范围选择语法是三点语法，这个可以指定被两个引用中的一个包含但又不被两者同时包含的分支。回过头来看一下图6-1里所列的提交历史的例子。 如果你想查看master或者experiment中包含的但不是两者共有的引用，你可以运行12345$ git log master...experimentFEDC 这个再次给出你普通的log输出但是只显示那四次提交的信息，按照传统的提交日期排列。这种情形下，log命令的一个常用参数是--left-right，它会显示每个提交到底处于哪一侧的分支。这使得数据更加有用。12345$ git log --left-right master...experiment&lt; F&lt; E&gt; D&gt; C 有了以上工具，让Git知道你要察看哪些提交就容易得多了。]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 项目的管理]]></title>
    <url>%2F2017%2F11%2F03%2Fgit-%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[项目的管理既然是相互协作，在贡献代码的同时，也免不了要维护管理自己的项目。像是怎么处理别人用 format-patch 生成的补丁，或是集成远端仓库上某个分支上的变化等等。但无论是管理代码仓库，还是帮忙审核收到的补丁，都需要同贡献者约定某种长期可持续的工作方式。 使用特性分支进行工作如果想要集成新的代码进来，最好局限在特性分支上做。临时的特性分支可以让你随意尝试，进退自如。比如碰上无法正常工作的补丁，可以先搁在那边，直到有时间仔细核查修复为止。创建的分支可以用相关的主题关键字命名，比如 ruby_client 或者其它类似的描述性词语，以帮助将来回忆。Git 项目本身还时常把分支名称分置于不同命名空间下，比如 sc/ruby_client 就说明这是 sc 这个人贡献的。 现在从当前主干分支为基础，新建临时分支： $ git branch sc/ruby_client master另外，如果你希望立即转到分支上去工作，可以用 checkout -b：$ git checkout -b sc/ruby_client master好了，现在已经准备妥当，可以试着将别人贡献的代码合并进来了。之后评估一下有没有问题，最后再决定是不是真的要并入主干。 采纳来自邮件的补丁如果收到一个通过电邮发来的补丁，你应该先把它应用到特性分支上进行评估。有两种应用补丁的方法：git apply 或者 git am。 使用 apply 命令应用补丁如果收到的补丁文件是用 git diff 或由其它 Unix 的 diff 命令生成，就该用 git apply 命令来应用补丁。假设补丁文件存在 /tmp/patch-ruby-client.patch，可以这样运行： $ git apply /tmp/patch-ruby-client.patch这会修改当前工作目录下的文件，效果基本与运行 patch -p1 打补丁一样，但它更为严格，且不会出现混乱。如果是 git diff 格式描述的补丁，此命令还会相应地添加，删除，重命名文件。当然，普通的 patch 命令是不会这么做的。另外请注意，git apply 是一个事务性操作的命令，也就是说，要么所有补丁都打上去，要么全部放弃。所以不会出现 patch 命令那样，一部分文件打上了补丁而另一部分却没有，这样一种不上不下的修订状态。所以总的来说，git apply 要比 patch 严谨许多。因为仅仅是更新当前的文件，所以此命令不会自动生成提交对象，你得手工缓存相应文件的更新状态并执行提交命令。 在实际打补丁之前，可以先用 git apply --check 查看补丁是否能够干净顺利地应用到当前分支中：123$ git apply --check 0001-seeing-if-this-helps-the-gem.patcherror: patch failed: ticgit.gemspec:1error: ticgit.gemspec: patch does not apply 如果没有任何输出，表示我们可以顺利采纳该补丁。如果有问题，除了报告错误信息之外，该命令还会返回一个非零的状态，所以在 shell 脚本里可用于检测状态。 使用 am 命令应用补丁如果贡献者也用 Git，且擅于制作 format-patch 补丁，那你的合并工作将会非常轻松。因为这些补丁中除了文件内容差异外，还包含了作者信息和提交消息。所以请鼓励贡献者用 format-patch 生成补丁。对于传统的 diff 命令生成的补丁，则只能用 git apply 处理。 对于 format-patch 制作的新式补丁，应当使用 git am 命令。从技术上来说，git am 能够读取 mbox 格式的文件。这是种简单的纯文本文件，可以包含多封电邮，格式上用 From 加空格以及随便什么辅助信息所组成的行作为分隔行，以区分每封邮件，就像这样：123456From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001From: Jessica Smith &lt;jessica@example.com&gt;Date: Sun, 6 Apr 2008 10:17:23 -0700Subject: [PATCH 1/2] add limit to log functionLimit log functionality to the first 20 这是 format-patch 命令输出的开头几行，也是一个有效的 mbox 文件格式。如果有人用 git send-email 给你发了一个补丁，你可以将此邮件下载到本地，然后运行 git am 命令来应用这个补丁。如果你的邮件客户端能将多封电邮导出为 mbox 格式的文件，就可以用 git am 一次性应用所有导出的补丁。 如果贡献者将 format-patch 生成的补丁文件上传到类似 Request Ticket 一样的任务处理系统，那么可以先下载到本地，继而使用 git am 应用该补丁： $ git am 0001-limit-log-function.patchApplying: add limit to log function你会看到它被干净地应用到本地分支，并自动创建了新的提交对象。作者信息取自邮件头 From 和 Date，提交消息则取自 Subject 以及正文中补丁之前的内容。来看具体实例，采纳之前展示的那个 mbox 电邮补丁后，最新的提交对象为：12345678910$ git log --pretty=fuller -1commit 6c5e70b984a60b3cecd395edd5b48a7575bf58e0Author: Jessica Smith &lt;jessica@example.com&gt;AuthorDate: Sun Apr 6 10:17:23 2008 -0700Commit: Scott Chacon &lt;schacon@gmail.com&gt;CommitDate: Thu Apr 9 09:19:06 2009 -0700 add limit to log function Limit log functionality to the first 20 Commit 部分显示的是采纳补丁的人，以及采纳的时间。而 Author 部分则显示的是原作者，以及创建补丁的时间。 有时，我们也会遇到打不上补丁的情况。这多半是因为主干分支和补丁的基础分支相差太远，但也可能是因为某些依赖补丁还未应用。这种情况下，git am 会报错并询问该怎么做：12345678$ git am 0001-seeing-if-this-helps-the-gem.patchApplying: seeing if this helps the gemerror: patch failed: ticgit.gemspec:1error: ticgit.gemspec: patch does not applyPatch failed at 0001.When you have resolved this problem run &quot;git am --resolved&quot;.If you would prefer to skip this patch, instead run &quot;git am --skip&quot;.To restore the original branch and stop patching run &quot;git am --abort&quot;. Git 会在有冲突的文件里加入冲突解决标记，这同合并或衍合操作一样。解决的办法也一样，先编辑文件消除冲突，然后暂存文件，最后运行 git am --resolved 提交修正结果：1234$ (fix the file)$ git add ticgit.gemspec$ git am --resolvedApplying: seeing if this helps the gem 如果想让 Git 更智能地处理冲突，可以用 -3 选项进行三方合并。如果当前分支未包含该补丁的基础代码或其祖先，那么三方合并就会失败，所以该选项默认为关闭状态。一般来说，如果该补丁是基于某个公开的提交制作而成的话，你总是可以通过同步来获取这个共同祖先，所以用三方合并选项可以解决很多麻烦：1234567$ git am -3 0001-seeing-if-this-helps-the-gem.patchApplying: seeing if this helps the gemerror: patch failed: ticgit.gemspec:1error: ticgit.gemspec: patch does not applyUsing index info to reconstruct a base tree...Falling back to patching base and 3-way merge...No changes -- Patch already applied. 像上面的例子，对于打过的补丁我又再打一遍，自然会产生冲突，但因为加上了 -3 选项，所以它很聪明地告诉我，无需更新，原有的补丁已经应用。 对于一次应用多个补丁时所用的 mbox 格式文件，可以用 am 命令的交互模式选项 -i，这样就会在打每个补丁前停住，询问该如何操作：123456$ git am -3 -i mboxCommit Body is:--------------------------seeing if this helps the gem--------------------------Apply? [y]es/[n]o/[e]dit/[v]iew patch/[a]ccept all 在多个补丁要打的情况下，这是个非常好的办法，一方面可以预览下补丁内容，同时也可以有选择性的接纳或跳过某些补丁。 打完所有补丁后，如果测试下来新特性可以正常工作，那就可以安心地将当前特性分支合并到长期分支中去了。 检出远程分支如果贡献者有自己的 Git 仓库，并将修改推送到此仓库中，那么当你拿到仓库的访问地址和对应分支的名称后，就可以加为远程分支，然后在本地进行合并。 比如，Jessica 发来一封邮件，说在她代码库中的 ruby-client 分支上已经实现了某个非常棒的新功能，希望我们能帮忙测试一下。我们可以先把她的仓库加为远程仓库，然后抓取数据，完了再将她所说的分支检出到本地来测试：123$ git remote add jessica git://github.com/jessica/myproject.git$ git fetch jessica$ git checkout -b rubyclient jessica/ruby-client 若是不久她又发来邮件，说还有个很棒的功能实现在另一分支上，那我们只需重新抓取下最新数据，然后检出那个分支到本地就可以了，无需重复设置远程仓库。 这种做法便于同别人保持长期的合作关系。但前提是要求贡献者有自己的服务器，而我们也需要为每个人建一个远程分支。有些贡献者提交代码补丁并不是很频繁，所以通过邮件接收补丁效率会更高。同时我们自己也不会希望建上百来个分支，却只从每个分支取一两个补丁。但若是用脚本程序来管理，或直接使用代码仓库托管服务，就可以简化此过程。当然，选择何种方式取决于你和贡献者的喜好。 使用远程分支的另外一个好处是能够得到提交历史。不管代码合并是不是会有问题，至少我们知道该分支的历史分叉点，所以默认会从共同祖先开始自动进行三方合并，无需 -3 选项，也不用像打补丁那样祈祷存在共同的基准点。 如果只是临时合作，只需用 git pull 命令抓取远程仓库上的数据，合并到本地临时分支就可以了。一次性的抓取动作自然不会把该仓库地址加为远程仓库。1234$ git pull git://github.com/onetimeguy/project.gitFrom git://github.com/onetimeguy/project * branch HEAD -&gt; FETCH_HEADMerge made by recursive. 决断代码取舍现在特性分支上已合并好了贡献者的代码，是时候决断取舍了。本节将回顾一些之前学过的命令，以看清将要合并到主干的是哪些代码，从而理解它们到底做了些什么，是否真的要并入。 一般我们会先看下，特性分支上都有哪些新增的提交。比如在 contrib 特性分支上打了两个补丁，仅查看这两个补丁的提交信息，可以用 --not 选项指定要屏蔽的分支 master，这样就会剔除重复的提交历史：123456789101112$ git log contrib --not mastercommit 5b6235bd297351589efc4d73316f0a68d484f118Author: Scott Chacon &lt;schacon@gmail.com&gt;Date: Fri Oct 24 09:53:59 2008 -0700 seeing if this helps the gemcommit 7482e0d16d04bea79d0dba8988cc78df655f16a0Author: Scott Chacon &lt;schacon@gmail.com&gt;Date: Mon Oct 22 19:38:36 2008 -0700 updated the gemspec to hopefully work better 还可以查看每次提交的具体修改。请牢记，在 git log后加-p 选项将展示每次提交的内容差异。 如果想看当前分支同其他分支合并时的完整内容差异，有个小窍门： $ git diff master虽然能得到差异内容，但请记住，结果有可能和我们的预期不同。一旦主干 master 在特性分支创建之后有所修改，那么通过 diff 命令来比较的，是最新主干上的提交快照。显然，这不是我们所要的。比方在 master 分支中某个文件里添了一行，然后运行上面的命令，简单的比较最新快照所得到的结论只能是，特性分支中删除了这一行。 这个很好理解：如果 master 是特性分支的直接祖先，不会产生任何问题；如果它们的提交历史在不同的分叉上，那么产生的内容差异，看起来就像是增加了特性分支上的新代码，同时删除了 master 分支上的新代码。 实际上我们真正想要看的，是新加入到特性分支的代码，也就是合并时会并入主干的代码。所以，准确地讲，我们应该比较特性分支和它同 master 分支的共同祖先之间的差异。 我们可以手工定位它们的共同祖先，然后与之比较：123$ git merge-base contrib master36c7dba2c95e6bbb78dfa822519ecfec6e1ca649$ git diff 36c7db 但这么做很麻烦，所以 Git 提供了便捷的 ... 语法。对于 diff 命令，可以把 ... 加在原始分支（拥有共同祖先）和当前分支之间： $ git diff master…contrib现在看到的，就是实际将要引入的新代码。这是一个非常有用的命令，应该牢记。 代码集成一旦特性分支准备停当，接下来的问题就是如何集成到更靠近主线的分支中。此外还要考虑维护项目的总体步骤是什么。虽然有很多选择，不过我们这里只介绍其中一部分。 合并流程一般最简单的情形，是在 master 分支中维护稳定代码，然后在特性分支上开发新功能，或是审核测试别人贡献的代码，接着将它并入主干，最后删除这个特性分支，如此反复。来看示例，假设当前代码库中有两个分支，分别为 ruby_client 和 php_client，如图 5-19 所示。然后先把 ruby_client 合并进主干，再合并 php_client，最后的提交历史如图 5-20 所示。图 5-19. 多个特性分支图 5-20. 合并特性分支之后这是最简单的流程，所以在处理大一些的项目时可能会有问题。 对于大型项目，至少需要维护两个长期分支 master 和 develop。新代码（图 5-21 中的 ruby_client）将首先并入 develop 分支（图 5-22 中的 C8），经过一个阶段，确认develop 中的代码已稳定到可发行时，再将 master 分支快进到稳定点（图 5-23 中的 C8）。而平时这两个分支都会被推送到公开的代码库。图 5-21. 特性分支合并前图 5-22. 特性分支合并后图 5-23. 特性分支发布后 这样，在人们克隆仓库时就有两种选择：既可检出最新稳定版本，确保正常使用；也能检出开发版本，试用最前沿的新特性。 你也可以扩展这个概念，先将所有新代码合并到临时特性分支，等到该分支稳定下来并通过测试后，再并入 develop 分支。然后，让时间检验一切，如果这些代码确实可以正常工作相当长一段时间，那就有理由相信它已经足够稳定，可以放心并入主干分支发布。 大项目的合并流程Git 项目本身有四个长期分支：用于发布的 master 分支、用于合并基本稳定特性的 next 分支、用于合并仍需改进特性的 pu 分支（pu 是 proposed updates 的缩写），以及用于除错维护的 maint 分支（maint 取自 maintenance）。维护者可以按照之前介绍的方法，将贡献者的代码引入为不同的特性分支（如图 5-24 所示），然后测试评估，看哪些特性能稳定工作，哪些还需改进。稳定的特性可以并入next 分支，然后再推送到公共仓库，以供其他人试用。 图 5-24. 管理复杂的并行贡献仍需改进的特性可以先并入 pu 分支。直到它们完全稳定后再并入 master。同时一并检查下 next 分支，将足够稳定的特性也并入 master。所以一般来说，master 始终是在快进，next 偶尔做下衍合，而 pu 则是频繁衍合，如图 5-25 所示：图 5-25. 将特性并入长期分支并入 master 后的特性分支，已经无需保留分支索引，放心删除好了。Git 项目还有一个 maint 分支，它是以最近一次发行版为基础分化而来的，用于维护除错补丁。所以克隆 Git 项目仓库后会得到这四个分支，通过检出不同分支可以了解各自进展，或是试用前沿特性，或是贡献代码。而维护者则通过管理这些分支，逐步有序地并入第三方贡献。 衍合与挑拣（cherry-pick）的流程一些维护者更喜欢衍合或者挑拣贡献者的代码，而不是简单的合并，因为这样能够保持线性的提交历史。如果你完成了一个特性的开发，并决定将它引入到主干代码中，你可以转到那个特性分支然后执行衍合命令，好在你的主干分支上（也可能是develop分支之类的）重新提交这些修改。如果这些代码工作得很好，你就可以快进master分支，得到一个线性的提交历史。 另一个引入代码的方法是挑拣。挑拣类似于针对某次特定提交的衍合。它首先提取某次提交的补丁，然后试着应用在当前分支上。如果某个特性分支上有多个commits，但你只想引入其中之一就可以使用这种方法。也可能仅仅是因为你喜欢用挑拣，讨厌衍合。假设你有一个类似图 5-26 的工程。图 5-26. 挑拣（cherry-pick）之前的历史如果你希望拉取e43a6到你的主干分支，可以这样：1234$ git cherry-pick e43a6fd3e94888d76779ad79fb568ed180e5fcdfFinished one cherry-pick.[master]: created a0a41a9: &quot;More friendly message when locking the index fails.&quot; 3 files changed, 17 insertions(+), 3 deletions(-) 这将会引入e43a6的代码，但是会得到不同的SHA-1值，因为应用日期不同。现在你的历史看起来像图 5-27. 图 5-27. 挑拣（cherry-pick）之后的历史现在，你可以删除这个特性分支并丢弃你不想引入的那些commit。 给发行版签名你可以删除上次发布的版本并重新打标签，也可以像第二章所说的那样建立一个新的标签。如果你决定以维护者的身份给发行版签名，应该这样做：1234$ git tag -s v1.5 -m &apos;my signed 1.5 tag&apos;You need a passphrase to unlock the secret key foruser: &quot;Scott Chacon &lt;schacon@gmail.com&gt;&quot;1024-bit DSA key, ID F721C45A, created 2009-02-09 完成签名之后，如何分发PGP公钥（public key）是个问题。（译者注：分发公钥是为了验证标签）。还好，Git的设计者想到了解决办法：可以把key（即公钥）作为blob变量写入Git库，然后把它的内容直接写在标签里。gpg --list-keys命令可以显示出你所拥有的key：123456$ gpg --list-keys/Users/schacon/.gnupg/pubring.gpg---------------------------------pub 1024D/F721C45A 2009-02-09 [expires: 2010-02-09]uid Scott Chacon &lt;schacon@gmail.com&gt;sub 2048g/45D02282 2009-02-09 [expires: 2010-02-09] 然后，导出key的内容并经由管道符传递给git hash-object，之后钥匙会以blob类型写入Git中，最后返回这个blob量的SHA-1值：12$ gpg -a --export F721C45A | git hash-object -w --stdin659ef797d181633c87ec71ac3f9ba29fe5775b92 现在你的Git已经包含了这个key的内容了，可以通过不同的SHA-1值指定不同的key来创建标签。 $ git tag -a maintainer-pgp-pub 659ef797d181633c87ec71ac3f9ba29fe5775b92在运行git push --tags命令之后，maintainer-pgp-pub标签就会公布给所有人。如果有人想要校验标签，他可以使用如下命令导入你的key：$ git show maintainer-pgp-pub | gpg –import人们可以用这个key校验你签名的所有标签。另外，你也可以在标签信息里写入一个操作向导，用户只需要运行git show &lt;tag&gt;查看标签信息，然后按照你的向导就能完成校验。 生成内部版本号因为Git不会为每次提交自动附加类似’v123’的递增序列，所以如果你想要得到一个便于理解的提交号可以运行git describe命令。Git将会返回一个字符串，由三部分组成：最近一次标定的版本号，加上自那次标定之后的提交次数，再加上一段所描述的提交的SHA-1值：12$ git describe masterv1.6.2-rc1-20-g8c5b85c 这个字符串可以作为快照的名字，方便人们理解。如果你的Git是你自己下载源码然后编译安装的，你会发现git --version命令的输出和这个字符串差不多。如果在一个刚刚打完标签的提交上运行describe命令，只会得到这次标定的版本号，而没有后面两项信息。 git describe命令只适用于有标注的标签（通过-a或者-s选项创建的标签），所以发行版的标签都应该是带有标注的，以保证git describe能够正确的执行。你也可以把这个字符串作为checkout或者show命令的目标，因为他们最终都依赖于一个简短的SHA-1值，当然如果这个SHA-1值失效他们也跟着失效。最近Linux内核为了保证SHA-1值的唯一性，将位数由8位扩展到10位，这就导致扩展之前的git describe输出完全失效了。 准备发布现在可以发布一个新的版本了。首先要将代码的压缩包归档，方便那些可怜的还没有使用Git的人们。可以使用git archive：123$ git archive master --prefix=&apos;project/&apos; | gzip &gt; `git describe master`.tar.gz$ ls *.tar.gzv1.6.2-rc1-20-g8c5b85c.tar.gz 这个压缩包解压出来的是一个文件夹，里面是你项目的最新代码快照。你也可以用类似的方法建立一个zip压缩包，在git archive加上--format=zip选项： $ git archive master –prefix=’project/‘ –format=zip &gt; git describe master.zip现在你有了一个tar.gz压缩包和一个zip压缩包，可以把他们上传到你网站上或者用e-mail发给别人。 制作简报是时候通知邮件列表里的朋友们来检验你的成果了。使用git shortlog命令可以方便快捷的制作一份修改日志（changelog），告诉大家上次发布之后又增加了哪些特性和修复了哪些bug。实际上这个命令能够统计给定范围内的所有提交;假如你上一次发布的版本是v1.0.1，下面的命令将给出自从上次发布之后的所有提交的简介：1234567891011121314$ git shortlog --no-merges master --not v1.0.1Chris Wanstrath (8): Add support for annotated tags to Grit::Tag Add packed-refs annotated tag support. Add Grit::Commit#to_patch Update version and History.txt Remove stray `puts` Make ls_tree ignore nilsTom Preston-Werner (4): fix dates in history dynamic version method Version bump to 1.0.2 Regenerated gemspec for version 1.0.2 这就是自从v1.0.1版本以来的所有提交的简介，内容按照作者分组，以便你能快速的发e-mail给他们。]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 为项目作贡献]]></title>
    <url>%2F2017%2F11%2F03%2Fgit-%E4%B8%BA%E9%A1%B9%E7%9B%AE%E4%BD%9C%E8%B4%A1%E7%8C%AE%2F</url>
    <content type="text"><![CDATA[为项目作贡献接下来，我们来学习一下作为项目贡献者，会有哪些常见的工作模式。 不过要说清楚整个协作过程真的很难，Git 如此灵活，人们的协作方式便可以各式各样，没有固定不变的范式可循，而每个项目的具体情况又多少会有些不同，比如说参与者的规模，所选择的工作流程，每个人的提交权限，以及 Git 以外贡献等等，都会影响到具体操作的细节。 首当其冲的是参与者规模。项目中有多少开发者是经常提交代码的？经常又是多久呢？大多数两至三人的小团队，一天大约只有几次提交，如果不是什么热门项目的话就更少了。可要是在大公司里，或者大项目中，参与者可以多到上千，每天都会有十几个上百个补丁提交上来。这种差异带来的影响是显著的，越是多的人参与进来，就越难保证每次合并正确无误。你正在工作的代码，可能会因为合并进来其他人的更新而变得过时，甚至受创无法运行。而已经提交上去的更新，也可能在等着审核合并的过程中变得过时。那么，我们该怎样做才能确保代码是最新的，提交的补丁也是可用的呢？接下来便是项目所采用的工作流。是集中式的，每个开发者都具有等同的写权限？项目是否有专人负责检查所有补丁？是不是所有补丁都做过同行复阅（peer-review）再通过审核的？你是否参与审核过程？如果使用副官系统，那你是不是限定于只能向此副官提交？ 还有你的提交权限。有或没有向主项目提交更新的权限，结果完全不同，直接决定最终采用怎样的工作流。如果不能直接提交更新，那该如何贡献自己的代码呢？是不是该有个什么策略？你每次贡献代码会有多少量？提交频率呢？ 所有以上这些问题都会或多或少影响到最终采用的工作流。接下来，我会在一系列由简入繁的具体用例中，逐一阐述。此后在实践时，应该可以借鉴这里的例子，略作调整，以满足实际需要构建自己的工作流。 提交指南开始分析特定用例之前，先来了解下如何撰写提交说明。一份好的提交指南可以帮助协作者更轻松更有效地配合。Git 项目本身就提供了一份文档（Git 项目源代码目录中 Documentation/SubmittingPatches），列数了大量提示，从如何编撰提交说明到提交补丁，不一而足。 首先，请不要在更新中提交多余的白字符（whitespace）。Git 有种检查此类问题的方法，在提交之前，先运行 git diff --check，会把可能的多余白字符修正列出来。下面的示例，我已经把终端中显示为红色的白字符用 X 替换掉：1234567$ git diff --checklib/simplegit.rb:5: trailing whitespace.+ @git_dir = File.expand_path(git_dir)XXlib/simplegit.rb:7: trailing whitespace.+ XXXXXXXXXXXlib/simplegit.rb:26: trailing whitespace.+ def command(git_cmd)XXXX 这样在提交之前你就可以看到这类问题，及时解决以免困扰其他开发者。 接下来，请将每次提交限定于完成一次逻辑功能。并且可能的话，适当地分解为多次小更新，以便每次小型提交都更易于理解。请不要在周末穷追猛打一次性解决五个问题，而最后拖到周一再提交。就算是这样也请尽可能利用暂存区域，将之前的改动分解为每次修复一个问题，再分别提交和加注说明。如果针对两个问题改动的是同一个文件，可以试试看 git add –patch 的方式将部分内容置入暂存区域（我们会在第六章再详细介绍）。无论是五次小提交还是混杂在一起的大提交，最终分支末端的项目快照应该还是一样的，但分解开来之后，更便于其他开发者复阅。这么做也方便自己将来取消某个特定问题的修复。我们将在第六章介绍一些重写提交历史，同暂存区域交互的技巧和工具，以便最终得到一个干净有意义，且易于理解的提交历史。 最后需要谨记的是提交说明的撰写。写得好可以让大家协作起来更轻松。一般来说，提交说明最好限制在一行以内，50 个字符以下，简明扼要地描述更新内容，空开一行后，再展开详细注解。Git 项目本身需要开发者撰写详尽注解，包括本次修订的因由，以及前后不同实现之间的比较，我们也该借鉴这种做法。另外，提交说明应该用祈使现在式语态，比如，不要说成 “I added tests for” 或 “Adding tests for” 而应该用 “Add tests for”。 下面是来自 tpope.net 的 Tim Pope 原创的提交说明格式模版，供参考：12345678910111213本次更新的简要描述（50 个字符以内）如果必要，此处展开详尽阐述。段落宽度限定在 72 个字符以内。某些情况下，第一行的简要描述将用作邮件标题，其余部分作为邮件正文。其间的空行是必要的，以区分两者（当然没有正文另当别论）。如果并在一起，rebase 这样的工具就可能会迷惑。另起空行后，再进一步补充其他说明。 - 可以使用这样的条目列举式。 - 一般以单个空格紧跟短划线或者星号作为每项条目的起始符。每个条目间用一空行隔开。 不过这里按自己项目的约定，可以略作变化。 如果你的提交说明都用这样的格式来书写，好多事情就可以变得十分简单。Git 项目本身就是这样要求的，我强烈建议你到 Git 项目仓库下运行 git log --no-merges 看看，所有提交历史的说明是怎样撰写的。（译注：如果现在还没有克隆 git 项目源代码，是时候 git clone git://git.kernel.org/pub/scm/git/git.git 了。） 为简单起见，在接下来的例子（及本书随后的所有演示）中，我都不会用这种格式，而使用 -m 选项提交 git commit。不过请还是按照我之前讲的做，别学我这里偷懒的方式。 私有的小型团队我们从最简单的情况开始，一个私有项目，与你一起协作的还有另外一到两位开发者。这里说私有，是指源代码不公开，其他人无法访问项目仓库。而你和其他开发者则都具有推送数据到仓库的权限。 这种情况下，你们可以用 Subversion 或其他集中式版本控制系统类似的工作流来协作。你仍然可以得到 Git 带来的其他好处：离线提交，快速分支与合并等等，但工作流程还是差不多的。主要区别在于，合并操作发生在客户端而非服务器上。 让我们来看看，两个开发者一起使用同一个共享仓库，会发生些什么。第一个人，John，克隆了仓库，作了些更新，在本地提交。（下面的例子中省略了常规提示，用 … 代替以节约版面。）123456789# John&apos;s Machine$ git clone john@githost:simplegit.gitInitialized empty Git repository in /home/john/simplegit/.git/...$ cd simplegit/$ vim lib/simplegit.rb$ git commit -am &apos;removed invalid default value&apos;[master 738ee87] removed invalid default value 1 files changed, 1 insertions(+), 1 deletions(-) 第二个开发者，Jessica，一样这么做：克隆仓库，提交更新：123456789# Jessica&apos;s Machine$ git clone jessica@githost:simplegit.gitInitialized empty Git repository in /home/jessica/simplegit/.git/...$ cd simplegit/$ vim TODO$ git commit -am &apos;add reset task&apos;[master fbff5bc] add reset task 1 files changed, 1 insertions(+), 0 deletions(-) 现在，Jessica 将她的工作推送到服务器上：12345# Jessica&apos;s Machine$ git push origin master...To jessica@githost:simplegit.git 1edee6b..fbff5bc master -&gt; master John 也尝试推送自己的工作上去：12345# John&apos;s Machine$ git push origin masterTo john@githost:simplegit.git ! [rejected] master -&gt; master (non-fast forward)error: failed to push some refs to &apos;john@githost:simplegit.git&apos; John 的推送操作被驳回，因为 Jessica 已经推送了新的数据上去。请注意，特别是你用惯了 Subversion 的话，这里其实修改的是两个文件，而不是同一个文件的同一个地方。Subversion 会在服务器端自动合并提交上来的更新，而 Git 则必须先在本地合并后才能推送。于是，John 不得不先把 Jessica 的更新拉下来：1234$ git fetch origin...From john@githost:simplegit + 049d078...fbff5bc master -&gt; origin/master 此刻，John 的本地仓库如图 5-4 所示：图 5-4. John 的仓库历史虽然 John 下载了 Jessica 推送到服务器的最近更新（fbff5），但目前只是 origin/master 指针指向它，而当前的本地分支 master 仍然指向自己的更新（738ee），所以需要先把她的提交合并过来，才能继续推送数据：1234$ git merge origin/masterMerge made by recursive. TODO | 1 + 1 files changed, 1 insertions(+), 0 deletions(-) 还好，合并过程非常顺利，没有冲突，现在 John 的提交历史如图 5-5 所示：图 5-5. 合并 origin/master 后 John 的仓库历史现在，John 应该再测试一下代码是否仍然正常工作，然后将合并结果（72bbc）推送到服务器上：1234$ git push origin master...To john@githost:simplegit.git fbff5bc..72bbc59 master -&gt; master 最终，John 的提交历史变为图 5-6 所示：图 5-6. 推送后 John 的仓库历史而在这段时间，Jessica 已经开始在另一个特性分支工作了。她创建了 issue54 并提交了三次更新。她还没有下载 John 提交的合并结果，所以提交历史如图 5-7 所示：图 5-7. Jessica 的提交历史Jessica 想要先和服务器上的数据同步，所以先下载数据：12345# Jessica&apos;s Machine$ git fetch origin...From jessica@githost:simplegit fbff5bc..72bbc59 master -&gt; origin/master 于是 Jessica 的本地仓库历史多出了 John 的两次提交（738ee 和 72bbc），如图 5-8 所示：图 5-8. 获取 John 的更新之后 Jessica 的提交历史此时，Jessica 在特性分支上的工作已经完成，但她想在推送数据之前，先确认下要并进来的数据究竟是什么，于是运行 git log 查看：123456$ git log --no-merges origin/master ^issue54commit 738ee872852dfaa9d6634e0dea7a324040193016Author: John Smith &lt;jsmith@example.com&gt;Date: Fri May 29 16:01:27 2009 -0700 removed invalid default value 现在，Jessica 可以将特性分支上的工作并到 master 分支，然后再并入 John 的工作（origin/master）到自己的 master 分支，最后再推送回服务器。当然，得先切回主分支才能集成所有数据：123$ git checkout masterSwitched to branch &quot;master&quot;Your branch is behind &apos;origin/master&apos; by 2 commits, and can be fast-forwarded. 要合并 origin/master 或 issue54 分支，谁先谁后都没有关系，因为它们都在上游（upstream）（译注：想像分叉的更新像是汇流成河的源头，所以上游 upstream 是指最新的提交），所以无所谓先后顺序，最终合并后的内容快照都是一样的，而仅是提交历史看起来会有些先后差别。Jessica 选择先合并 issue54：123456$ git merge issue54Updating fbff5bc..4af4298Fast forward README | 1 + lib/simplegit.rb | 6 +++++- 2 files changed, 6 insertions(+), 1 deletions(-) 正如所见，没有冲突发生，仅是一次简单快进。现在 Jessica 开始合并 John 的工作（origin/master）：12345$ git merge origin/masterAuto-merging lib/simplegit.rbMerge made by recursive. lib/simplegit.rb | 2 +- 1 files changed, 1 insertions(+), 1 deletions(-) 所有的合并都非常干净。现在 Jessica 的提交历史如图 5-9 所示：图 5-9. 合并 John 的更新后 Jessica 的提交历史现在 Jessica 已经可以在自己的 master 分支中访问 origin/master 的最新改动了，所以她应该可以成功推送最后的合并结果到服务器上（假设 John 此时没再推送新数据上来）：1234$ git push origin master...To jessica@githost:simplegit.git 72bbc59..8059c15 master -&gt; master 至此，每个开发者都提交了若干次，且成功合并了对方的工作成果，最新的提交历史如图 5-10 所示：图 5-10. Jessica 推送数据后的提交历史以上就是最简单的协作方式之一：先在自己的特性分支中工作一段时间，完成后合并到自己的 master 分支；然后下载合并 origin/master 上的更新（如果有的话），再推回远程服务器。一般的协作流程如图 5-11 所示：图 5-11. 多用户共享仓库协作方式的一般工作流程时序 私有团队间协作现在我们来看更大一点规模的私有团队协作。如果有几个小组分头负责若干特性的开发和集成，那他们之间的协作过程是怎样的。 假设 John 和 Jessica 一起负责开发某项特性 A，而同时 Jessica 和 Josie 一起负责开发另一项功能 B。公司使用典型的集成管理员式工作流，每个组都有一名管理员负责集成本组代码，及更新项目主仓库的 master 分支。所有开发都在代表小组的分支上进行。 让我们跟随 Jessica 的视角看看她的工作流程。她参与开发两项特性，同时和不同小组的开发者一起协作。克隆生成本地仓库后，她打算先着手开发特性 A。于是创建了新的 featureA 分支，继而编写代码：1234567# Jessica&apos;s Machine$ git checkout -b featureASwitched to a new branch &quot;featureA&quot;$ vim lib/simplegit.rb$ git commit -am &apos;add limit to log function&apos;[featureA 3300904] add limit to log function 1 files changed, 1 insertions(+), 1 deletions(-) 此刻，她需要分享目前的进展给 John，于是她将自己的 featureA 分支提交到服务器。由于 Jessica 没有权限推送数据到主仓库的 master 分支（只有集成管理员有此权限），所以只能将此分支推上去同 John 共享协作：1234$ git push origin featureA...To jessica@githost:simplegit.git * [new branch] featureA -&gt; featureA Jessica 发邮件给 John 让他上来看看 featureA 分支上的进展。在等待他的反馈之前，Jessica 决定继续工作，和 Josie 一起开发 featureB 上的特性 B。当然，先创建此分支，分叉点以服务器上的 master 为起点：1234# Jessica&apos;s Machine$ git fetch origin$ git checkout -b featureB origin/masterSwitched to a new branch &quot;featureB&quot; 随后，Jessica 在 featureB 上提交了若干更新：12345678$ vim lib/simplegit.rb$ git commit -am &apos;made the ls-tree function recursive&apos;[featureB e5b0fdc] made the ls-tree function recursive 1 files changed, 1 insertions(+), 1 deletions(-)$ vim lib/simplegit.rb$ git commit -am &apos;add ls-files&apos;[featureB 8512791] add ls-files 1 files changed, 5 insertions(+), 0 deletions(-) 现在 Jessica 的更新历史如图 5-12 所示：图 5-12. Jessica 的更新历史Jessica 正准备推送自己的进展上去，却收到 Josie 的来信，说是她已经将自己的工作推到服务器上的 featureBee 分支了。这样，Jessica 就必须先将 Josie 的代码合并到自己本地分支中，才能再一起推送回服务器。她用 git fetch 下载 Josie 的最新代码：1234$ git fetch origin...From jessica@githost:simplegit * [new branch] featureBee -&gt; origin/featureBee 然后 Jessica 使用 git merge 将此分支合并到自己分支中：12345$ git merge origin/featureBeeAuto-merging lib/simplegit.rbMerge made by recursive. lib/simplegit.rb | 4 ++++ 1 files changed, 4 insertions(+), 0 deletions(-) 合并很顺利，但另外有个小问题：她要推送自己的 featureB 分支到服务器上的 featureBee 分支上去。当然，她可以使用冒号（:）格式指定目标分支：1234$ git push origin featureB:featureBee...To jessica@githost:simplegit.git fba9af8..cd685d1 featureB -&gt; featureBee 我们称此为refspec。更多有关于 Git refspec 的讨论和使用方式会在第九章作详细阐述。 接下来，John 发邮件给 Jessica 告诉她，他看了之后作了些修改，已经推回服务器 featureA 分支，请她过目下。于是 Jessica 运行 git fetch 下载最新数据：1234$ git fetch origin...From jessica@githost:simplegit 3300904..aad881d featureA -&gt; origin/featureA 接下来便可以用 git log 查看更新了些什么：123456$ git log origin/featureA ^featureAcommit aad881d154acdaeb2b6b18ea0e827ed8a6d671e6Author: John Smith &lt;jsmith@example.com&gt;Date: Fri May 29 19:57:33 2009 -0700 changed log output to 30 from 25 最后，她将 John 的工作合并到自己的 featureA 分支中：1234567$ git checkout featureASwitched to branch &quot;featureA&quot;$ git merge origin/featureAUpdating 3300904..aad881dFast forward lib/simplegit.rb | 10 +++++++++-1 files changed, 9 insertions(+), 1 deletions(-) Jessica 稍做一番修整后同步到服务器：1234567$ git commit -am &apos;small tweak&apos;[featureA 774b3ed] small tweak 1 files changed, 1 insertions(+), 1 deletions(-)$ git push origin featureA...To jessica@githost:simplegit.git 3300904..774b3ed featureA -&gt; featureA 现在的 Jessica 提交历史如图 5-13 所示：图 5-13. 在特性分支中提交更新后的提交历史现在，Jessica，Josie 和 John 通知集成管理员服务器上的 featureA 及 featureBee 分支已经准备好，可以并入主线了。在管理员完成集成工作后，主分支上便多出一个新的合并提交（5399e），用 fetch 命令更新到本地后，提交历史如图 5-14 所示：图 5-14. 合并特性分支后的 Jessica 提交历史许多开发小组改用 Git 就是因为它允许多个小组间并行工作，而在稍后恰当时机再行合并。通过共享远程分支的方式，无需干扰整体项目代码便可以开展工作，因此使用 Git 的小型团队间协作可以变得非常灵活自由。以上工作流程的时序如图 5-15 所示：图 5-15. 团队间协作工作流程基本时序 公开的小型项目上面说的是私有项目协作，但要给公开项目作贡献，情况就有些不同了。因为你没有直接更新主仓库分支的权限，得寻求其它方式把工作成果交给项目维护人。下面会介绍两种方法，第一种使用 git 托管服务商提供的仓库复制功能，一般称作 fork，比如 repo.or.cz 和 GitHub 都支持这样的操作，而且许多项目管理员都希望大家使用这样的方式。另一种方法是通过电子邮件寄送文件补丁。 但不管哪种方式，起先我们总需要克隆原始仓库，而后创建特性分支开展工作。基本工作流程如下：1234567$ git clone (url)$ cd project$ git checkout -b featureA$ (work)$ git commit$ (work)$ git commit 你可能想到用 rebase -i 将所有更新先变作单个提交，又或者想重新安排提交之间的差异补丁，以方便项目维护者审阅 – 有关交互式衍合操作的细节见第六章。 在完成了特性分支开发，提交给项目维护者之前，先到原始项目的页面上点击“Fork”按钮，创建一个自己可写的公共仓库（译注：即下面的 url 部分，参照后续的例子，应该是 git://githost/simplegit.git）。然后将此仓库添加为本地的第二个远端仓库，姑且称为 myfork： $ git remote add myfork (url)你需要将本地更新推送到这个仓库。要是将远端 master 合并到本地再推回去，还不如把整个特性分支推上去来得干脆直接。而且，假若项目维护者未采纳你的贡献的话（不管是直接合并还是 cherry pick），都不用回退（rewind）自己的 master 分支。但若维护者合并或 cherry-pick 了你的工作，最后总还可以从他们的更新中同步这些代码。好吧，现在先把 featureA 分支整个推上去：$ git push myfork featureA然后通知项目管理员，让他来抓取你的代码。通常我们把这件事叫做 pull request。可以直接用 GitHub 等网站提供的 “pull request” 按钮自动发送请求通知；或手工把 git request-pull 命令输出结果电邮给项目管理员。 request-pull 命令接受两个参数，第一个是本地特性分支开始前的原始分支，第二个是请求对方来抓取的 Git 仓库 URL（译注：即下面 myfork 所指的，自己可写的公共仓库）。比如现在Jessica 准备要给 John 发一个 pull requst，她之前在自己的特性分支上提交了两次更新，并把分支整个推到了服务器上，所以运行该命令会看到：123456789101112131415$ git request-pull origin/master myforkThe following changes since commit 1edee6b1d61823a2de3b09c160d7080b8d1b3a40: John Smith (1): added a new functionare available in the git repository at: git://githost/simplegit.git featureAJessica Smith (2): add limit to log function change log output to 30 from 25 lib/simplegit.rb | 10 +++++++++- 1 files changed, 9 insertions(+), 1 deletions(-) 输出的内容可以直接发邮件给管理者，他们就会明白这是从哪次提交开始旁支出去的，该到哪里去抓取新的代码，以及新的代码增加了哪些功能等等。 像这样随时保持自己的 master 分支和官方 origin/master 同步，并将自己的工作限制在特性分支上的做法，既方便又灵活，采纳和丢弃都轻而易举。就算原始主干发生变化，我们也能重新衍合提供新的补丁。比如现在要开始第二项特性的开发，不要在原来已推送的特性分支上继续，还是按原始 master 开始：123456$ git checkout -b featureB origin/master$ (work)$ git commit$ git push myfork featureB$ (email maintainer)$ git fetch origin 现在，A、B 两个特性分支各不相扰，如同竹筒里的两颗豆子，队列中的两个补丁，你随时都可以分别从头写过，或者衍合，或者修改，而不用担心特性代码的交叉混杂。如图 5-16 所示：图 5-16. featureB 以后的提交历史假设项目管理员接纳了许多别人提交的补丁后，准备要采纳你提交的第一个分支，却发现因为代码基准不一致，合并工作无法正确干净地完成。这就需要你再次衍合到最新的 origin/master，解决相关冲突，然后重新提交你的修改：123$ git checkout featureA$ git rebase origin/master$ git push -f myfork featureA 自然，这会重写提交历史，如图 5-17 所示：图 5-17. featureA 重新衍合后的提交历史注意，此时推送分支必须使用 -f 选项（译注：表示 force，不作检查强制重写）替换远程已有的 featureA 分支，因为新的 commit 并非原来的后续更新。当然你也可以直接推送到另一个新的分支上去，比如称作 featureAv2。 再考虑另一种情形：管理员看过第二个分支后觉得思路新颖，但想请你改下具体实现。我们只需以当前 origin/master 分支为基准，开始一个新的特性分支 featureBv2，然后把原来的 featureB 的更新拿过来，解决冲突，按要求重新实现部分代码，然后将此特性分支推送上去：12345$ git checkout -b featureBv2 origin/master$ git merge --no-commit --squash featureB$ (change implementation)$ git commit$ git push myfork featureBv2 这里的 --squash 选项将目标分支上的所有更改全拿来应用到当前分支上，而 --no-commit 选项告诉 Git 此时无需自动生成和记录（合并）提交。这样，你就可以在原来代码基础上，继续工作，直到最后一起提交。 好了，现在可以请管理员抓取 featureBv2 上的最新代码了，如图 5-18 所示： 图 5-18. featureBv2 之后的提交历史 公开的大型项目许多大型项目都会立有一套自己的接受补丁流程，你应该注意下其中细节。但多数项目都允许通过开发者邮件列表接受补丁，现在我们来看具体例子。 整个工作流程类似上面的情形：为每个补丁创建独立的特性分支，而不同之处在于如何提交这些补丁。不需要创建自己可写的公共仓库，也不用将自己的更新推送到自己的服务器，你只需将每次提交的差异内容以电子邮件的方式依次发送到邮件列表中即可。12345$ git checkout -b topicA$ (work)$ git commit$ (work)$ git commit 如此一番后，有了两个提交要发到邮件列表。我们可以用 git format-patch 命令来生成 mbox 格式的文件然后作为附件发送。每个提交都会封装为一个 .patch 后缀的 mbox 文件，但其中只包含一封邮件，邮件标题就是提交消息（译注：额外有前缀，看例子），邮件内容包含补丁正文和 Git 版本号。这种方式的妙处在于接受补丁时仍可保留原来的提交消息，请看接下来的例子：123$ git format-patch -M origin/master0001-add-limit-to-log-function.patch0002-changed-log-output-to-30-from-25.patch format-patch 命令依次创建补丁文件，并输出文件名。上面的 -M 选项允许 Git 检查是否有对文件重命名的提交。我们来看看补丁文件的内容：123456789101112131415161718192021222324252627$ cat 0001-add-limit-to-log-function.patchFrom 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001From: Jessica Smith &lt;jessica@example.com&gt;Date: Sun, 6 Apr 2008 10:17:23 -0700Subject: [PATCH 1/2] add limit to log functionLimit log functionality to the first 20--- lib/simplegit.rb | 2 +- 1 files changed, 1 insertions(+), 1 deletions(-)diff --git a/lib/simplegit.rb b/lib/simplegit.rbindex 76f47bc..f9815f1 100644--- a/lib/simplegit.rb+++ b/lib/simplegit.rb@@ -14,7 +14,7 @@ class SimpleGit end def log(treeish = &apos;master&apos;)- command(&quot;git log #&#123;treeish&#125;&quot;)+ command(&quot;git log -n 20 #&#123;treeish&#125;&quot;) end def ls_tree(treeish = &apos;master&apos;)--1.6.2.rc1.20.g8c5b.dirty 如果有额外信息需要补充，但又不想放在提交消息中说明，可以编辑这些补丁文件，在第一个 — 行之前添加说明，但不要修改下面的补丁正文，比如例子中的 Limit log functionality to the first 20 部分。这样，其它开发者能阅读，但在采纳补丁时不会将此合并进来。 你可以用邮件客户端软件发送这些补丁文件，也可以直接在命令行发送。有些所谓智能的邮件客户端软件会自作主张帮你调整格式，所以粘贴补丁到邮件正文时，有可能会丢失换行符和若干空格。Git 提供了一个通过 IMAP 发送补丁文件的工具。接下来我会演示如何通过 Gmail 的 IMAP 服务器发送。另外，在 Git 源代码中有个 Documentation/SubmittingPatches 文件，可以仔细读读，看看其它邮件程序的相关导引。 首先在 ~/.gitconfig 文件中配置 imap 项。每个选项都可用 git config 命令分别设置，当然直接编辑文件添加以下内容更便捷：1234567[imap] folder = &quot;[Gmail]/Drafts&quot; host = imaps://imap.gmail.com user = user@gmail.com pass = p4ssw0rd port = 993 sslverify = false 如果你的 IMAP 服务器没有启用 SSL，就无需配置最后那两行，并且 host 应该以 imap:// 开头而不再是有 s 的 imaps://。 保存配置文件后，就能用 git send-email 命令把补丁作为邮件依次发送到指定的 IMAP 服务器上的文件夹中（译注：这里就是 Gmail 的 [Gmail]/Drafts 文件夹。但如果你的语言设置不是英文，此处的文件夹 Drafts 字样会变为对应的语言。）：123456$ cat *.patch |git imap-sendResolving imap.gmail.com... okConnecting to [74.125.142.109]:993... okLogging in...sending 2 messages100% (2/2) done 然后，你应该去你到草稿箱去更改你要发送的补丁的收件人信息，以及需要抄送的人，然后发送它。 您也可以通过SMTP服务器发送补丁。和上面一样，你可以通过git config命令单独设置每个参数，也可以在你的~/.gitconfig文件中的sendemail节点手动添加它们。12345[sendemail] smtpencryption = tls smtpserver = smtp.gmail.com smtpuser = user@gmail.com smtpserverport = 587 配置完成后，您可以使用git send-email来发送你的补丁：1234567$ git send-email *.patch0001-added-limit-to-log-function.patch0002-changed-log-output-to-30-from-25.patchWho should the emails appear to be from? [Jessica Smith &lt;jessica@example.com&gt;]Emails will be sent from: Jessica Smith &lt;jessica@example.com&gt;Who should the emails be sent to? jessica@example.comMessage-ID to be used as In-Reply-To for the first email? y 接下来，Git 会根据每个补丁依次输出类似下面的日志：1234567891011121314(mbox) Adding cc: Jessica Smith &lt;jessica@example.com&gt; from \line &apos;From: Jessica Smith &lt;jessica@example.com&gt;&apos;OK. Log says:Sendmail: /usr/sbin/sendmail -i jessica@example.comFrom: Jessica Smith &lt;jessica@example.com&gt;To: jessica@example.comSubject: [PATCH 1/2] added limit to log functionDate: Sat, 30 May 2009 13:29:15 -0700Message-Id: &lt;1243715356-61726-1-git-send-email-jessica@example.com&gt;X-Mailer: git-send-email 1.6.2.rc1.20.g8c5b.dirtyIn-Reply-To: &lt;y&gt;References: &lt;y&gt;Result: OK]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git Git 守护进程]]></title>
    <url>%2F2017%2F11%2F03%2Fgit-Git-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Git 守护进程对于提供公共的，非授权的只读访问，我们可以抛弃 HTTP 协议，改用 Git 自己的协议，这主要是出于性能和速度的考虑。Git 协议远比 HTTP 协议高效，因而访问速度也快，所以它能节省很多用户的时间。 重申一下，这一点只适用于非授权的只读访问。如果建在防火墙之外的服务器上，那么它所提供的服务应该只是那些公开的只读项目。如果是在防火墙之内的服务器上，可用于支撑大量参与人员或自动系统（用于持续集成或编译的主机）只读访问的项目，这样可以省去逐一配置 SSH 公钥的麻烦。但不管哪种情形，Git 协议的配置设定都很简单。基本上，只要以守护进程的形式运行该命令即可： git daemon –reuseaddr –base-path=/opt/git/ /opt/git/这里的 --reuseaddr 选项表示在重启服务前，不等之前的连接超时就立即重启。而 --base-path 选项则允许克隆项目时不必给出完整路径。最后面的路径告诉 Git 守护进程允许开放给用户访问的仓库目录。假如有防火墙，则需要为该主机的 9418 端口设置为允许通信。 以守护进程的形式运行该进程的方法有很多，但主要还得看用的是什么操作系统。在 Ubuntu 主机上，可以用 Upstart 脚本达成。编辑该文件： /etc/event.d/local-git-daemon加入以下内容：12345678start on startupstop on shutdownexec /usr/bin/git daemon \ --user=git --group=git \ --reuseaddr \ --base-path=/opt/git/ \ /opt/git/respawn 出于安全考虑，强烈建议用一个对仓库只有读取权限的用户身份来运行该进程 — 只需要简单地新建一个名为 git-ro 的用户（译注：新建用户默认对仓库文件不具备写权限，但这取决于仓库目录的权限设定。务必确认 git-ro 对仓库只能读不能写。），并用它的身份来启动进程。这里为了简化，后面我们还是用之前运行 Gitosis 的用户 ‘git’。 这样一来，当你重启计算机时，Git 进程也会自动启动。要是进程意外退出或者被杀掉，也会自行重启。在设置完成后，不重启计算机就启动该守护进程，可以运行： initctl start local-git-daemon而在其他操作系统上，可以用 xinetd，或者 sysvinit 系统的脚本，或者其他类似的脚本 — 只要能让那个命令变为守护进程并可监控。 接下来，我们必须告诉 Gitosis 哪些仓库允许通过 Git 协议进行匿名只读访问。如果每个仓库都设有各自的段落，可以分别指定是否允许 Git 进程开放给用户匿名读取。比如允许通过 Git 协议访问 iphone_project，可以把下面两行加到 gitosis.conf 文件的末尾：12[repo iphone_project]daemon = yes 在提交和推送完成后，运行中的 Git 守护进程就会响应来自 9418 端口对该项目的访问请求。 如果不考虑 Gitosis，单单起了 Git 守护进程的话，就必须到每一个允许匿名只读访问的仓库目录内，创建一个特殊名称的空文件作为标志：12$ cd /path/to/project.git$ touch git-daemon-export-ok 该文件的存在，表明允许 Git 守护进程开放对该项目的匿名只读访问。 Gitosis 还能设定哪些项目允许放在 GitWeb 上显示。先打开 GitWeb 的配置文件 /etc/gitweb.conf，添加以下四行：1234$projects_list = &quot;/home/git/gitosis/projects.list&quot;;$projectroot = &quot;/home/git/repositories&quot;;$export_ok = &quot;git-daemon-export-ok&quot;;@git_base_url_list = (&apos;git://gitserver&apos;); 接下来，只要配置各个项目在 Gitosis 中的 gitweb 参数，便能达成是否允许 GitWeb 用户浏览该项目。比如，要让 iphone_project 项目在 GitWeb 里出现，把 repo 的设定改成下面的样子：123[repo iphone_project]daemon = yesgitweb = yes 在提交并推送过之后，GitWeb 就会自动开始显示 iphone_project 项目的细节和历史。]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git Gitolite]]></title>
    <url>%2F2017%2F11%2F03%2Fgit-Gitolite%2F</url>
    <content type="text"><![CDATA[Gitolite本节作为Gitolite的一个快速指南，指导基本的安装和设置。不能完全替代随Gitolite自带的大量文档。而且可能会随时改变本节内容，因此你也许想看看最新的版本。 Gitolite是在Git之上的一个授权层，依托sshd或者httpd来进行认证。（概括：认证是确定用户是谁，授权是决定该用户是否被允许做他想做的事情）。 Gitolite允许你定义访问许可而不只作用于仓库，而同样于仓库中的每个branch和tag name。你可以定义确切的人(或一组人)只能push特定的”refs”(或者branches或者tags)而不是其他人。 安装安装Gitolite非常简单, 你甚至不用读自带的那一大堆文档。你需要一个unix服务器上的账户；许多linux变种和solaris 10都已经试过了。你不需要root访问，假设git，perl，和一个openssh兼容的ssh服务器已经装好了。在下面的例子里，我们会用git账户在gitserver进行。 Gitolite是不同于“服务”的软件 – 其通过ssh访问, 而且每个在服务器上的userid都是一个潜在的“gitolite主机”。我们在这里描述最简单的安装方法，对于其他方法，请参考其文档。 开始，在你的服务器上创建一个名为git的用户，然后以这个用户登录。从你的工作站拷贝你的SSH公钥（也就是你用ssh-keygen默认生成的~/.ssh/id_dsa.pub文件），重命名为&lt;yourname&gt;.pub（我们这里使用scott.pub作为例子）。然后执行下面的命令：1234$ git clone git://github.com/sitaramc/gitolite$ gitolite/install -ln # assumes $HOME/bin exists and is in your $PATH$ gitolite setup -pk $HOME/scott.pub 最后一个命令在服务器上创建了一个名为gitolite-admin的Git仓库。 最后，回到你的工作站，执行git clone git@gitserver:gitolite-admin。然后你就完成了！Gitolite现在已经安装在了服务器上，在你的工作站上，你也有一个名为gitolite-admin的新仓库。你可用通过更改这个仓库以及推送到服务器上来管理你的Gitolite配置。 定制安装默认快速安装对大多数人都管用，还有一些定制安装方法如果你用的上的话。一些设置可以通过编辑rc文件来简单地改变，但是如果这个不够，有关于定制Gitolite的文档供参考。 配置文件和访问规则安装结束后，你切换到gitolite-admin仓库（放在你的HOME目录）然后看看都有啥：12345678910111213$ cd ~/gitolite-admin/$ lsconf/ keydir/$ find conf keydir -type fconf/gitolite.confkeydir/scott.pub$ cat conf/gitolite.confrepo gitolite-admin RW+ = scottrepo testing RW+ = @all 注意 “scott” ( 之前用gl-setup 命令时候的 pubkey 名稱) 有读写权限而且在 gitolite-admin 仓库里有一个同名的公钥文件。 添加用户很简单。为了添加一个名为alice的用户，获取她的公钥，命名为alice.pub，然后放到在你工作站上的gitolite-admin克隆的keydir目录。添加，提交，然后推送更改。这样用户就被添加了。 gitolite配置文件的语法在conf/example.conf里，我们只会提到一些主要的。 你可以给用户或者仓库分组。分组名就像一些宏；定义的时候，无所谓他们是工程还是用户；区别在于你使用“宏”的时候1234567@oss_repos = linux perl rakudo git gitolite@secret_repos = fenestra pear@admins = scott@interns = ashok@engineers = sitaram dilbert wally alice@staff = @admins @engineers @interns 你可以控制许可在”ref“级别。在下面的例子里，实习生可以push ”int“分支。工程师可以push任何有”eng-“开头的branch，还有refs/tags下面用”rc”开头的后面跟数字的。而且管理员可以随便更改(包括rewind)对任何参考名。12345repo @oss_repos RW int$ = @interns RW eng- = @engineers RW refs/tags/rc[0-9] = @engineers RW+ = @admins 在RWorRW+之后的表达式是正则表达式(regex)对应着后面的push用的参考名字(ref)。所以我们叫它”参考正则“（refex）！当然，一个refex可以比这里表现的更强大，所以如果你对perl的正则表达式不熟的话就不要改过头。 同样，你可能猜到了，Gitolite字头refs/heads/是一个便捷句法如果参考正则没有用refs/开头。 一个这个配置文件语法的重要功能是，所有的仓库的规则不需要在同一个位置。你能报所有普通的东西放在一起，就像上面的对所有oss_repos的规则那样，然后建一个特殊的规则对后面的特殊案例，就像：12repo gitolite RW+ = sitaram 那条规则刚刚加入规则集的 gitolite 仓库. 这次你可能会想要知道访问控制规则是如何应用的，我们简要介绍一下。 在gitolite里有两级访问控制。第一是在仓库级别；如果你已经读或者写访问过了任何在仓库里的参考，那么你已经读或者写访问仓库了。 第二级，应用只能写访问，通过在仓库里的branch或者tag。用户名如果尝试过访问 (W或+)，参考名被更新为已知。访问规则检查是否出现在配置文件里，为这个联合寻找匹配 (但是记得参考名是正则匹配的，不是字符串匹配的)。如果匹配被找到了，push就成功了。不匹配的访问会被拒绝。 带’拒绝’的高级访问控制目前，我们只看过了许可是R,RW, 或者RW+这样子的。但是gitolite还允许另外一种许可：-，代表 ”拒绝“。这个给了你更多的能力，当然也有一点复杂，因为不匹配并不是唯一的拒绝访问的方法，因此规则的顺序变得无关了！ 这么说好了，在前面的情况中，我们想要工程师可以rewind任意branch除了master和integ。 这里是如何做到的123RW master integ = @engineers - master integ = @engineers RW+ = @engineers 你再一次简单跟随规则从上至下知道你找到一个匹配你的访问模式的，或者拒绝。非rewind push到master或者integ 被第一条规则允许。一个rewind push到那些refs不匹配第一条规则，掉到第二条，因此被拒绝。任何push(rewind或非rewind)到参考或者其他master或者integ不会被前两条规则匹配，即被第三条规则允许。 通过改变文件限制 push此外限制用户push改变到哪条branch的，你也可以限制哪个文件他们可以碰的到。比如, 可能Makefile (或者其他哪些程序) 真的不能被任何人做任何改动，因为好多东西都靠着它呢，或者如果某些改变刚好不对就会崩溃。你可以告诉 gitolite:1234repo foo RW = @junior_devs @senior_devs - VREF/NAME/Makefile = @junior_devs 这是一个强力的公能写在 conf/example.conf里。 个人分支Gitolite也支持一个叫”个人分支“的功能 (或者叫, ”个人分支命名空间“) 在合作环境里非常有用。 在 git世界里许多代码交换通过”pull“请求发生。然而在合作环境里，委任制的访问是‘绝不’，一个开发者工作站不能认证，你必须push到中心服务器并且叫其他人从那里pull。 这个通常会引起一些branch名称簇变成像 VCS里一样集中化，加上设置许可变成管理员的苦差事。 Gitolite让你定义一个”个人的“或者”乱七八糟的”命名空间字首给每个开发人员(比如，refs/personal/&lt;devname&gt;/*)；看在doc/3-faq-tips-etc.mkd里的”personal branches”一段获取细节。 “通配符” 仓库Gitolite 允许你定义带通配符的仓库(其实还是perl正则式), 比如随便整个例子的话assignments/s[0-9][0-9]/a[0-9][0-9]。 这是一个非常有用的功能，需要通过设置$GL_WILDREPOS = 1; 在 rc文件中启用。允许你安排一个新许可模式(“C”)允许用户创建仓库基于通配符，自动分配拥有权对特定用户 - 创建者，允许他交出 R和 RW许可给其他合作用户等等。这个功能在doc/4-wildcard-repositories.mkd文档里 其他功能我们用一些其他功能的例子结束这段讨论，这些以及其他功能都在 “faqs, tips, etc” 和其他文档里。 记录: Gitolite 记录所有成功的访问。如果你太放松给了别人 rewind许可 (RW+) 和其他孩子弄没了 “master”， 记录文件会救你的命，如果其他简单快速的找到SHA都不管用。 访问权报告: 另一个方便的功能是你尝试用ssh连接到服务器的时候发生了什么。Gitolite告诉你哪个 repos你访问过，那个访问可能是什么。这里是例子：123456789hello scott, this is git@git running gitolite3 v3.01-18-g9609868 on git 1.7.4.4 R anu-wsd R entrans R W git-notes R W gitolite R W gitolite-admin R indic_web_input R shreelipi_converter 委托：真正的大安装，你可以把责任委托给一组仓库给不同的人然后让他们独立管理那些部分。这个减少了主管理者的负担，让他瓶颈更小。这个功能在他自己的文档目录里的 doc/下面。 镜像: Gitolite可以帮助你维护多个镜像，如果主服务器挂掉的话在他们之间很容易切换。]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git Gitosis]]></title>
    <url>%2F2017%2F11%2F03%2Fgit-Gitosis%2F</url>
    <content type="text"><![CDATA[Gitosis把所有用户的公钥保存在 authorized_keys 文件的做法，只能凑和一阵子，当用户数量达到几百人的规模时，管理起来就会十分痛苦。每次改删用户都必须登录服务器不去说，这种做法还缺少必要的权限管理 — 每个人都对所有项目拥有完整的读写权限。 幸好我们还可以选择应用广泛的 Gitosis 项目。简单地说，Gitosis 就是一套用来管理 authorized_keys 文件和实现简单连接限制的脚本。有趣的是，用来添加用户和设定权限的并非通过网页程序，而只是管理一个特殊的 Git 仓库。你只需要在这个特殊仓库内做好相应的设定，然后推送到服务器上，Gitosis 就会随之改变运行策略，听起来就很酷，对吧？Gitosis 的安装算不上傻瓜化，但也不算太难。用 Linux 服务器架设起来最简单 — 以下例子中，我们使用装有 Ubuntu 8.10 系统的服务器。 Gitosis 的工作依赖于某些 Python 工具，所以首先要安装 Python 的 setuptools 包，在 Ubuntu 上称为 python-setuptools： $ apt-get install python-setuptools接下来，从 Gitosis 项目主页克隆并安装：123$ git clone https://github.com/tv42/gitosis.git$ cd gitosis$ sudo python setup.py install 这会安装几个供 Gitosis 使用的工具。默认 Gitosis 会把 /home/git 作为存储所有 Git 仓库的根目录，这没什么不好，不过我们之前已经把项目仓库都放在 /opt/git 里面了，所以为方便起见，我们可以做一个符号连接，直接划转过去，而不必重新配置： $ ln -s /opt/git /home/git/repositoriesGitosis 将会帮我们管理用户公钥，所以先把当前控制文件改名备份，以便稍后重新添加，准备好让 Gitosis 自动管理 authorized_keys 文件：$ mv /home/git/.ssh/authorized_keys /home/git/.ssh/ak.bak接下来，如果之前把 git 用户的登录 shell 改为 git-shell 命令的话，先恢复 ‘git’ 用户的登录 shell。改过之后，大家仍然无法通过该帐号登录（译注：因为 authorized_keys 文件已经没有了。），不过不用担心，这会交给 Gitosis 来实现。所以现在先打开 /etc/passwd 文件，把这行：git:x:1000:1000::/home/git:/usr/bin/git-shell改回:git:x:1000:1000::/home/git:/bin/sh好了，现在可以初始化 Gitosis 了。你可以用自己的公钥执行 gitosis-init 命令，要是公钥不在服务器上，先临时复制一份：123$ sudo -H -u git gitosis-init &lt; /tmp/id_dsa.pubInitialized empty Git repository in /opt/git/gitosis-admin.git/Reinitialized existing Git repository in /opt/git/gitosis-admin.git/ 这样该公钥的拥有者就能修改用于配置 Gitosis 的那个特殊 Git 仓库了。接下来，需要手工对该仓库中的 post-update 脚本加上可执行权限： $ sudo chmod 755 /opt/git/gitosis-admin.git/hooks/post-update基本上就算是好了。如果设定过程没出什么差错，现在可以试一下用初始化 Gitosis 的公钥的拥有者身份 SSH 登录服务器，应该会看到类似下面这样：1234$ ssh git@gitserverPTY allocation request failed on channel 0ERROR:gitosis.serve.main:Need SSH_ORIGINAL_COMMAND in environment. Connection to gitserver closed. 说明 Gitosis 认出了该用户的身份，但由于没有运行任何 Git 命令，所以它切断了连接。那么，现在运行一个实际的 Git 命令 — 克隆 Gitosis 的控制仓库：12# 在你本地计算机上$ git clone git@gitserver:gitosis-admin.git 这会得到一个名为 gitosis-admin 的工作目录，主要由两部分组成：12345$ cd gitosis-admin$ find ../gitosis.conf./keydir./keydir/scott.pub gitosis.conf 文件是用来设置用户、仓库和权限的控制文件。keydir 目录则是保存所有具有访问权限用户公钥的地方— 每人一个。在 keydir 里的文件名（比如上面的 scott.pub）应该跟你的不一样 — Gitosis 会自动从使用 gitosis-init 脚本导入的公钥尾部的描述中获取该名字。 看一下 gitosis.conf 文件的内容，它应该只包含与刚刚克隆的 gitosis-admin 相关的信息：123456$ cat gitosis.conf[gitosis][group gitosis-admin]members = scottwritable = gitosis-admin 它显示用户 scott — 初始化 Gitosis 公钥的拥有者 — 是唯一能管理 gitosis-admin 项目的人。 现在我们来添加一个新项目。为此我们要建立一个名为 mobile 的新段落，在其中罗列手机开发团队的开发者，以及他们拥有写权限的项目。由于 ‘scott’ 是系统中的唯一用户，我们把他设为唯一用户，并允许他读写名为 iphone_project 的新项目：123[group mobile]members = scottwritable = iphone_project 修改完之后，提交 gitosis-admin 里的改动，并推送到服务器使其生效：12345678910$ git commit -am &apos;add iphone_project and mobile group&apos;[master 8962da8] add iphone_project and mobile group 1 file changed, 4 insertions(+)$ git push origin masterCounting objects: 5, done.Compressing objects: 100% (3/3), done.Writing objects: 100% (3/3), 272 bytes | 0 bytes/s, done.Total 3 (delta 0), reused 0 (delta 0)To git@gitserver:gitosis-admin.git fb27aec..8962da8 master -&gt; master 在新工程 iphone_project 里首次推送数据到服务器前，得先设定该服务器地址为远程仓库。但你不用事先到服务器上手工创建该项目的裸仓库— Gitosis 会在第一次遇到推送时自动创建：12345678$ git remote add origin git@gitserver:iphone_project.git$ git push origin masterInitialized empty Git repository in /opt/git/iphone_project.git/Counting objects: 3, done.Writing objects: 100% (3/3), 230 bytes | 0 bytes/s, done.Total 3 (delta 0), reused 0 (delta 0)To git@gitserver:iphone_project.git * [new branch] master -&gt; master 请注意，这里不用指明完整路径（实际上，如果加上反而没用），只需要一个冒号加项目名字即可 — Gitosis 会自动帮你映射到实际位置。 要和朋友们在一个项目上协同工作，就得重新添加他们的公钥。不过这次不用在服务器上一个一个手工添加到 ~/.ssh/authorized_keys 文件末端，而只需管理 keydir 目录中的公钥文件。文件的命名将决定在 gitosis.conf 中对用户的标识。现在我们为 John，Josie 和 Jessica 添加公钥：123$ cp /tmp/id_rsa.john.pub keydir/john.pub$ cp /tmp/id_rsa.josie.pub keydir/josie.pub$ cp /tmp/id_rsa.jessica.pub keydir/jessica.pub 然后把他们都加进 ‘mobile’ 团队，让他们对 iphone_project 具有读写权限：123[group mobile]members = scott john josie jessicawritable = iphone_project 如果你提交并推送这个修改，四个用户将同时具有该项目的读写权限。 Gitosis 也具有简单的访问控制功能。如果想让 John 只有读权限，可以这样做：1234567[group mobile]members = scott josie jessicawritable = iphone_project[group mobile_ro]members = johnreadonly = iphone_project 现在 John 可以克隆和获取更新，但 Gitosis 不会允许他向项目推送任何内容。像这样的组可以随意创建，多少不限，每个都可以包含若干不同的用户和项目。甚至还可以指定某个组为成员之一（在组名前加上 @ 前缀），自动继承该组的成员：12345678910[group mobile_committers]members = scott josie jessica[group mobile]members = @mobile_committerswritable = iphone_project[group mobile_2]members = @mobile_committers johnwritable = another_iphone_project 如果遇到意外问题，试试看把 loglevel=DEBUG 加到 [gitosis] 的段落（译注：把日志设置为调试级别，记录更详细的运行信息。）。如果一不小心搞错了配置，失去了推送权限，也可以手工修改服务器上的 /home/git/.gitosis.conf 文件 — Gitosis 实际是从该文件读取信息的。它在得到推送数据时，会把新的 gitosis.conf 存到该路径上。所以如果你手工编辑该文件的话，它会一直保持到下次向 gitosis-admin 推送新版本的配置内容为止。]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git GitWeb]]></title>
    <url>%2F2017%2F11%2F03%2Fgit-GitWeb%2F</url>
    <content type="text"><![CDATA[GitWeb现在我们的项目已经有了可读可写和只读的连接方式，不过如果能有一个简单的 web 界面访问就更好了。Git 自带一个叫做 GitWeb 的 CGI 脚本，运行效果可以到 http://git.kernel.org 这样的站点体验下（见图 4-1）。Figure 4-1. 基于网页的 GitWeb 用户界面如果想看看自己项目的效果，不妨用 Git 自带的一个命令，可以使用类似 lighttpd 或 webrick 这样轻量级的服务器启动一个临时进程。如果是在 Linux 主机上，通常都预装了 lighttpd ，可以到项目目录中键入 git instaweb 来启动。如果用的是 Mac ，Leopard 预装了 Ruby，所以 webrick 应该是最好的选择。如果要用 lighttpd 以外的程序来启动git instaweb，可以通过 --httpd 选项指定：123$ git instaweb --httpd=webrick[2009-02-21 10:02:21] INFO WEBrick 1.3.1[2009-02-21 10:02:21] INFO ruby 1.8.6 (2008-03-03) [universal-darwin9.0] 这会在 1234 端口开启一个 HTTPD 服务，随之在浏览器中显示该页，十分简单。关闭服务时，只需在原来的命令后面加上 --stop 选项就可以了： $ git instaweb –httpd=webrick –stop如果需要为团队或者某个开源项目长期运行 GitWeb，那么 CGI 脚本就要由正常的网页服务来运行。一些 Linux 发行版可以通过 apt 或 yum 安装一个叫做 gitweb 的软件包，不妨首先尝试一下。我们将快速介绍一下手动安装 GitWeb 的流程。首先，你需要 Git 的源码，其中带有 GitWeb，并能生成定制的 CGI 脚本：12345$ git clone git://git.kernel.org/pub/scm/git/git.git$ cd git/$ make GITWEB_PROJECTROOT=&quot;/opt/git&quot; \ prefix=/usr gitweb$ sudo cp -Rf gitweb /var/www/ 注意，通过指定 GITWEB_PROJECTROOT 变量告诉编译命令 Git 仓库的位置。然后，设置 Apache 以 CGI 方式运行该脚本，添加一个 VirtualHost 配置：123456789101112&lt;VirtualHost *:80&gt; ServerName gitserver DocumentRoot /var/www/gitweb &lt;Directory /var/www/gitweb&gt; Options ExecCGI +FollowSymLinks +SymLinksIfOwnerMatch AllowOverride All order allow,deny Allow from all AddHandler cgi-script cgi DirectoryIndex gitweb.cgi &lt;/Directory&gt;&lt;/VirtualHost&gt; 不难想象，GitWeb 可以使用任何兼容 CGI 的网页服务来运行；如果偏向使用其他 web 服务器，配置也不会很麻烦。现在，通过 http://gitserver 就可以在线访问仓库了，在 http://git.server 上还可以通过 HTTP 克隆和获取仓库的内容。]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 公共访问]]></title>
    <url>%2F2017%2F11%2F03%2Fgit-%E5%85%AC%E5%85%B1%E8%AE%BF%E9%97%AE%2F</url>
    <content type="text"><![CDATA[公共访问匿名的读取权限该怎么实现呢？也许除了内部私有的项目之外，你还需要托管一些开源项目。或者因为要用一些自动化的服务器来进行编译，或者有一些经常变化的服务器群组，而又不想整天生成新的 SSH 密钥 — 总之，你需要简单的匿名读取权限。 或许对小型的配置来说最简单的办法就是运行一个静态 web 服务，把它的根目录设定为 Git 仓库所在的位置，然后开启本章第一节提到的 post-update 挂钩。这里继续使用之前的例子。假设仓库处于 /opt/git 目录，主机上运行着 Apache 服务。重申一下，任何 web 服务程序都可以达到相同效果；作为范例，我们将用一些基本的 Apache 设定来展示大体需要的步骤。首先，开启挂钩： 12345678910$ cat .git/hooks/post-update#!/bin/sh## An example hook script to prepare a packed repository for use over# dumb transports.## To enable this hook, rename this file to &quot;post-update&quot;.#exec git-update-server-info 意思是当通过 SSH 向服务器推送时，Git 将运行这个 git-update-server-info 命令来更新匿名 HTTP 访问获取数据时所需要的文件。 接下来，在 Apache 配置文件中添加一个 VirtualHost 条目，把文档根目录设为 Git 项目所在的根目录。这里我们假定 DNS 服务已经配置好，会把对 .gitserver 的请求发送到这台主机：12345678&lt;VirtualHost *:80&gt; ServerName git.gitserver DocumentRoot /opt/git &lt;Directory /opt/git/&gt; Order allow, deny allow from all &lt;/Directory&gt;&lt;/VirtualHost&gt; 另外，需要把 /opt/git 目录的 Unix 用户组设定为 www-data ，这样 web 服务才可以读取仓库内容，因为运行 CGI 脚本的 Apache 实例进程默认就是以该用户的身份起来的： $ chgrp -R www-data /opt/git重启 Apache 之后，就可以通过项目的 URL 来克隆该目录下的仓库了。$ git clone http://git.gitserver/project.git1这一招可以让你在几分钟内为相当数量的用户架设好基于 HTTP 的读取权限。另一个提供非授权访问的简单方法是开启一个 Git 守护进程，不过这将要求该进程作为后台进程常驻 — 接下来的这一节就要讨论这方面的细节。]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 架设服务器]]></title>
    <url>%2F2017%2F11%2F03%2Fgit-%E6%9E%B6%E8%AE%BE%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[架设服务器现在我们过一边服务器端架设 SSH 访问的流程。本例将使用 authorized_keys 方法来给用户授权。我们还将假定使用类似 Ubuntu 这样的标准 Linux 发行版。首先，创建一个名为 ‘git’ 的用户，并为其创建一个 .ssh 目录。 $ sudo adduser git$ su git$ cd$ mkdir .ssh接下来，把开发者的 SSH 公钥添加到这个用户的 authorized_keys 文件中。假设你通过电邮收到了几个公钥并存到了临时文件里。重复一下，公钥大致看起来是这个样子：$ cat /tmp/id_rsa.john.pubssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCB007n/ww+ouN4gSLKssMxXnBOvf9LGt4LojG6rs6hPB09j9R/T17/x4lhJA0F3FR1rP6kYBRsWj2aThGw6HXLm9/5zytK6Ztg3RPKK+4kYjh6541NYsnEAZuXz0jTTyAUfrtU3Z5E003C4oxOj6H0rfIF1kKI9MAQLMdpGW1GYEIgS9EzSdfd8AcCIicTDWbqLAcU4UpkaX8KyGlLwsNuuGztobF8m72ALC/nLF6JLtPofwFBlgc+myivO7TCUSBdLQlgMVOFq1I2uPWQOkOWQAHukEOmfjy2jctxSDBQ220ymjaNsHT4kgtZg2AYYgPqdAv8JggJICUvax2T9va5 gsg-keypair只要把它们逐个追加到 authorized_keys 文件尾部即可：$ cat /tmp/id_rsa.john.pub &gt;&gt; ~/.ssh/authorized_keys$ cat /tmp/id_rsa.josie.pub &gt;&gt; ~/.ssh/authorized_keys$ cat /tmp/id_rsa.jessica.pub &gt;&gt; ~/.ssh/authorized_keys现在可以用 --bare 选项运行 git init 来建立一个裸仓库，这会初始化一个不包含工作目录的仓库。$ cd /opt/git$ mkdir project.git$ cd project.git$ git –bare init这时，Join，Josie 或者 Jessica 就可以把它加为远程仓库，推送一个分支，从而把第一个版本的项目文件上传到仓库里了。值得注意的是，每次添加一个新项目都需要通过 shell 登入主机并创建一个裸仓库目录。我们不妨以 gitserver 作为 git 用户及项目仓库所在的主机名。如果在网络内部运行该主机，并在 DNS 中设定 gitserver 指向该主机，那么以下这些命令都是可用的： 在 John 的电脑上$ cd myproject$ git init$ git add .$ git commit -m ‘initial commit’$ git remote add origin git@gitserver:/opt/git/project.git$ git push origin master这样，其他人的克隆和推送也一样变得很简单：$ git clone git@gitserver:/opt/git/project.git$ cd project$ vim README$ git commit -am ‘fix for the README file’$ git push origin master用这个方法可以很快捷地为少数几个开发者架设一个可读写的 Git 服务。 作为一个额外的防范措施，你可以用 Git 自带的 git-shell 工具限制 git 用户的活动范围。只要把它设为 git 用户登入的 shell，那么该用户就无法使用普通的 bash 或者 csh 什么的 shell 程序。编辑 /etc/passwd 文件： $ sudo vim /etc/passwd在文件末尾，你应该能找到类似这样的行：git:x:1000:1000::/home/git:/bin/sh把 bin/sh 改为 /usr/bin/git-shell （或者用 which git-shell 查看它的实际安装路径）。该行修改后的样子如下：git:x:1000:1000::/home/git:/usr/bin/git-shell现在 git 用户只能用 SSH 连接来推送和获取 Git 仓库，而不能直接使用主机 shell。尝试普通 SSH 登录的话，会看到下面这样的拒绝信息：$ ssh git@gitserverfatal: What do you think I am? A shell?Connection to gitserver closed.]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 生成 SSH 公钥]]></title>
    <url>%2F2017%2F11%2F03%2Fgit-%E7%94%9F%E6%88%90-SSH-%E5%85%AC%E9%92%A5%2F</url>
    <content type="text"><![CDATA[生成 SSH 公钥大多数 Git 服务器都会选择使用 SSH 公钥来进行授权。系统中的每个用户都必须提供一个公钥用于授权，没有的话就要生成一个。生成公钥的过程在所有操作系统上都差不多。 首先先确认一下是否已经有一个公钥了。SSH 公钥默认储存在账户的主目录下的 ~/.ssh目录。进去看看： $ cd ~/.ssh$ lsauthorized_keys2 id_dsa known_hostsconfig id_dsa.pub关键是看有没有用 something 和 something.pub 来命名的一对文件，这个 something 通常就是 id_dsa 或 id_rsa。有 .pub 后缀的文件就是公钥，另一个文件则是密钥。假如没有这些文件，或者干脆连 .ssh 目录都没有，可以用 ssh-keygen 来创建。该程序在 Linux/Mac 系统上由 SSH 包提供，而在 Windows 上则包含在 MSysGit 包里：$ ssh-keygenGenerating public/private rsa key pair.Enter file in which to save the key &gt;(/Users/schacon/.ssh/id_rsa):Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in /Users/schacon/.ssh/id_rsa.Your public key has been saved in /Users/schacon/.ssh/id_rsa.pub.The key fingerprint is:43:c5:5b:5f:b1:f1:50:43:ad:20:a6:92:6a:1f:9a:3a &gt;schacon@agadorlaptop.local它先要求你确认保存公钥的位置（.ssh/id_rsa），然后它会让你重复一个密码两次，如果不想在使用公钥的时候输入密码，可以留空。 现在，所有做过这一步的用户都得把它们的公钥给你或者 Git 服务器的管理员（假设 SSH 服务被设定为使用公钥机制）。他们只需要复制 .pub 文件的内容然后发邮件给管理员。公钥的样子大致如下： $ cat ~/.ssh/id_rsa.pubssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAklOUpkDHrfHY17SbrmTIpNLTGK9Tjom/BWDSUGPl+nafzlHDTYW7hdI4yZ5ew18JH4JW9jbhUFrviQzM7xlELEVf4h9lFX5QVkbPppSwg0cda3Pbv7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8V6RjsNAQwdsdMFvSlVK/7XAt3FaoJoAsncM1Q9x5+3V0Ww68/eIFmb1zuUFljQJKprrX88XypNDvjYNby6vw/Pb0rwert/EnmZ+AW4OZPnTPI89ZPmVMLuayrD2cE86Z/il8b+gw3r3+1nKatmIkjn2so1d01QraTlMqVSsbxNrRFi9wrf+M7Q== schacon@agadorlaptop.local关于在多个操作系统上设立相同 SSH 公钥的教程，可以查阅 GitHub 上有关 SSH 公钥的向导：http://github.com/guides/providing-your-ssh-key。]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 在服务器上部署 Git]]></title>
    <url>%2F2017%2F11%2F03%2Fgit-%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E9%83%A8%E7%BD%B2-Git%2F</url>
    <content type="text"><![CDATA[在服务器上部署 Git开始架设 Git 服务器前，需要先把现有仓库导出为裸仓库 — 即一个不包含当前工作目录的仓库。做法直截了当，克隆时用 --bare 选项即可。裸仓库的目录名一般以 .git 结尾，像这样： $ git clone –bare my_project my_project.gitCloning into bare repository ‘my_project.git’…done.该命令的输出或许会让人有些不解。其实 clone 操作基本上相当于 git init 加 git fetch，所以这里出现的其实是 git init 的输出，先由它建立一个空目录，而之后传输数据对象的操作并无任何输出，只是悄悄在幕后执行。现在 my_project.git 目录中已经有了一份 Git 目录数据的副本。整体上的效果大致相当于：$ cp -Rf my_project/.git my_project.git但在配置文件中有若干小改动，不过对用户来讲，使用方式都一样，不会有什么影响。它仅取出 Git 仓库的必要原始数据，存放在该目录中，而不会另外创建工作目录。 把裸仓库移到服务器上有了裸仓库的副本后，剩下的就是把它放到服务器上并设定相关协议。假设一个域名为 git.example.com 的服务器已经架设好，并可以通过 SSH 访问，我们打算把所有 Git 仓库储存在 /opt/git 目录下。只要把裸仓库复制过去： $ scp -r my_project.git user@git.example.com:/opt/git现在，所有对该服务器有 SSH 访问权限，并可读取 /opt/git 目录的用户都可以用下面的命令克隆该项目：$ git clone user@git.example.com:/opt/git/my_project.git如果某个 SSH 用户对 /opt/git/my_project.git 目录有写权限，那他就有推送权限。如果到该项目目录中运行 git init 命令，并加上 –shared 选项，那么 Git 会自动修改该仓库目录的组权限为可写（译注：实际上 --shared 可以指定其他行为，只是默认为将组权限改为可写并执行 g+sx，所以最后会得到 rws。）。$ ssh user@git.example.com$ cd /opt/git/my_project.git$ git init –bare –shared由此可见，根据现有的 Git 仓库创建一个裸仓库，然后把它放上你和同事都有 SSH 访问权的服务器是多么容易。现在已经可以开始在同一项目上密切合作了。 值得注意的是，这的的确确是架设一个少数人具有连接权的 Git 服务的全部 — 只要在服务器上加入可以用 SSH 登录的帐号，然后把裸仓库放在大家都有读写权限的地方。一切都准备停当，无需更多。 下面的几节中，你会了解如何扩展到更复杂的设定。这些内容包含如何避免为每一个用户建立一个账户，给仓库添加公共读取权限，架设网页界面，使用 Gitosis 工具等等。然而，只是和几个人在一个不公开的项目上合作的话，仅仅是一个 SSH 服务器和裸仓库就足够了，记住这点就可以了。 小型安装如果设备较少或者你只想在小型开发团队里尝试 Git ，那么一切都很简单。架设 Git 服务最复杂的地方在于账户管理。如果需要仓库对特定的用户可读，而给另一部分用户读写权限，那么访问和许可的安排就比较困难 SSH 连接如果已经有了一个所有开发成员都可以用 SSH 访问的服务器，架设第一个服务器将变得异常简单，几乎什么都不用做（正如上节中介绍的那样）。如果需要对仓库进行更复杂的访问控制，只要使用服务器操作系统的本地文件访问许可机制就行了。 如果需要团队里的每个人都对仓库有写权限，又不能给每个人在服务器上建立账户，那么提供 SSH 连接就是唯一的选择了。我们假设用来共享仓库的服务器已经安装了 SSH 服务，而且你通过它访问服务器。 有好几个办法可以让团队的每个人都有访问权。第一个办法是给每个人建立一个账户，直截了当但略过繁琐。反复运行 adduser 并给所有人设定临时密码可不是好玩的。 第二个办法是在主机上建立一个 git 账户，让每个需要写权限的人发送一个 SSH 公钥，然后将其加入 git 账户的 ~/.ssh/authorized_keys 文件。这样一来，所有人都将通过 git 账户访问主机。这丝毫不会影响提交的数据 — 访问主机用的身份不会影响提交对象的提交者信息。 另一个办法是让 SSH 服务器通过某个 LDAP 服务，或者其他已经设定好的集中授权机制，来进行授权。只要每个人都能获得主机的 shell 访问权，任何可用的 SSH 授权机制都能达到相同效果。]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 协议]]></title>
    <url>%2F2017%2F11%2F03%2Fgit-%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[协议Git 可以使用四种主要的协议来传输数据：本地传输，SSH 协议，Git 协议和 HTTP 协议。下面分别介绍一下哪些情形应该使用（或避免使用）这些协议。 值得注意的是，除了 HTTP 协议外，其他所有协议都要求在服务器端安装并运行 Git。 本地协议最基本的就是本地协议（Local protocol），所谓的远程仓库在该协议中的表示，就是硬盘上的另一个目录。这常见于团队每一个成员都对一个共享的文件系统（例如 NFS）拥有访问权，或者比较少见的多人共用同一台电脑的情况。后面一种情况并不安全，因为所有代码仓库实例都储存在同一台电脑里，增加了灾难性数据损失的可能性。如果你使用一个共享的文件系统，就可以在一个本地文件系统中克隆仓库，推送和获取。克隆的时候只需要将远程仓库的路径作为 URL 使用，比如下面这样： $ git clone /opt/git/project.git 或者这样： $ git clone file:///opt/git/project.git如果在 URL 开头明确使用 file:// ，那么 Git 会以一种略微不同的方式运行。如果你只给出路径，Git 会尝试使用硬链接或直接复制它所需要的文件。如果使用了 file:// ，Git 会调用它平时通过网络来传输数据的工序，而这种方式的效率相对较低。使用 file:// 前缀的主要原因是当你需要一个不包含无关引用或对象的干净仓库副本的时候 — 一般指从其他版本控制系统导入的，或类似情形（参见第 9 章的维护任务）。我们这里仅仅使用普通路径，这样更快。 要添加一个本地仓库作为现有 Git 项目的远程仓库，可以这样做： $ git remote add local_proj /opt/git/project.git然后就可以像在网络上一样向这个远程仓库推送和获取数据了。 优点基于文件仓库的优点在于它的简单，同时保留了现存文件的权限和网络访问权限。如果你的团队已经有一个全体共享的文件系统，建立仓库就十分容易了。你只需把一份裸仓库的副本放在大家都能访问的地方，然后像对其他共享目录一样设置读写权限就可以了。我们将在下一节“在服务器上部署 Git ”中讨论如何导出一个裸仓库的副本。 这也是从别人工作目录中获取工作成果的快捷方法。假如你和你的同事在一个项目中合作，他们想让你检出一些东西的时候，运行类似 git pull /home/john/project 通常会比他们推送到服务器，而你再从服务器获取简单得多 缺点这种方法的缺点是，与基本的网络连接访问相比，难以控制从不同位置来的访问权限。如果你想从家里的笔记本电脑上推送，就要先挂载远程硬盘，这和基于网络连接的访问相比更加困难和缓慢。 另一个很重要的问题是该方法不一定就是最快的，尤其是对于共享挂载的文件系统。本地仓库只有在你对数据访问速度快的时候才快。在同一个服务器上，如果二者同时允许 Git 访问本地硬盘，通过 NFS 访问仓库通常会比 SSH 慢。 SSH 协议Git 使用的传输协议中最常见的可能就是 SSH 了。这是因为大多数环境已经支持通过 SSH 对服务器的访问 — 即便还没有，架设起来也很容易。SSH 也是唯一一个同时支持读写操作的网络协议。另外两个网络协议（HTTP 和 Git）通常都是只读的，所以虽然二者对大多数人都可用，但执行写操作时还是需要 SSH。SSH 同时也是一个验证授权的网络协议；而因为其普遍性，一般架设和使用都很容易。 通过 SSH 克隆一个 Git 仓库，你可以像下面这样给出 ssh:// 的 URL： $ git clone ssh://user@server/project.git或者不指明某个协议 — 这时 Git 会默认使用 SSH ：$ git clone user@server:project.git如果不指明用户，Git 会默认使用当前登录的用户名连接服务器。 优点使用 SSH 的好处有很多。首先，如果你想拥有对网络仓库的写权限，基本上不可能不使用 SSH。其次，SSH 架设相对比较简单 — SSH 守护进程很常见，很多网络管理员都有一些使用经验，而且很多操作系统都自带了它或者相关的管理工具。再次，通过 SSH 进行访问是安全的 — 所有数据传输都是加密和授权的。最后，和 Git 及本地协议一样，SSH 也很高效，会在传输之前尽可能压缩数据。 缺点SSH 的限制在于你不能通过它实现仓库的匿名访问。即使仅为读取数据，人们也必须在能通过 SSH 访问主机的前提下才能访问仓库，这使得 SSH 不利于开源的项目。如果你仅仅在公司网络里使用，SSH 可能是你唯一需要使用的协议。如果想允许对项目的匿名只读访问，那么除了为自己推送而架设 SSH 协议之外，还需要支持其他协议以便他人访问读取。 Git 协议接下来是 Git 协议。这是一个包含在 Git 软件包中的特殊守护进程； 它会监听一个提供类似于 SSH 服务的特定端口（9418），而无需任何授权。打算支持 Git 协议的仓库，需要先创建 git-daemon-export-ok 文件 — 它是协议进程提供仓库服务的必要条件 — 但除此之外该服务没有什么安全措施。要么所有人都能克隆 Git 仓库，要么谁也不能。这也意味着该协议通常不能用来进行推送。你可以允许推送操作；然而由于没有授权机制，一旦允许该操作，网络上任何一个知道项目 URL 的人将都有推送权限。不用说，这是十分罕见的情况。 优点Git 协议是现存最快的传输协议。如果你在提供一个有很大访问量的公共项目，或者一个不需要对读操作进行授权的庞大项目，架设一个 Git 守护进程来供应仓库是个不错的选择。它使用与 SSH 协议相同的数据传输机制，但省去了加密和授权的开销。 缺点Git 协议消极的一面是缺少授权机制。用 Git 协议作为访问项目的唯一方法通常是不可取的。一般的做法是，同时提供 SSH 接口，让几个开发者拥有推送（写）权限，其他人通过 git:// 拥有只读权限。 Git 协议可能也是最难架设的协议。它要求有单独的守护进程，需要定制 — 我们将在本章的 “Gitosis” 一节详细介绍它的架设 — 需要设定 xinetd 或类似的程序，而这些工作就没那么轻松了。该协议还要求防火墙开放 9418 端口，而企业级防火墙一般不允许对这个非标准端口的访问。大型企业级防火墙通常会封锁这个少见的端口。 HTTP/S 协议最后还有 HTTP 协议。HTTP 或 HTTPS 协议的优美之处在于架设的简便性。基本上，只需要把 Git 的裸仓库文件放在 HTTP 的根目录下，配置一个特定的 post-update 挂钩（hook）就可以搞定（Git 挂钩的细节见第 7 章）。此后，每个能访问 Git 仓库所在服务器上 web 服务的人都可以进行克隆操作。下面的操作可以允许通过 HTTP 对仓库进行读取： $ cd /var/www/htdocs/$ git clone –bare /path/to/git_project gitproject.git$ cd gitproject.git$ mv hooks/post-update.sample hooks/post-update$ chmod a+x hooks/post-update这样就可以了。Git 附带的 post-update 挂钩会默认运行合适的命令（git update-server-info）来确保通过 HTTP 的获取和克隆正常工作。这条命令在你用 SSH 向仓库推送内容时运行；之后，其他人就可以用下面的命令来克隆仓库：$ git clone http://example.com/gitproject.git在本例中，我们使用了 Apache 设定中常用的 /var/www/htdocs 路径，不过你可以使用任何静态 web 服务 — 把裸仓库放在它的目录里就行。 Git 的数据是以最基本的静态文件的形式提供的（关于如何提供文件的详情见第 9 章）。 通过 HTTP 进行推送操作也是可能的，不过这种做法不太常见，并且牵扯到复杂的 WebDAV 设定。由于很少用到，本书将略过对该内容的讨论。如果对 HTTP 推送协议感兴趣，不妨打开这个地址看一下操作方法：http://www.kernel.org/pub/software/scm/git/docs/howto/setup-git-server-over-http.txt 。通过 HTTP 推送的好处之一是你可以使用任何 WebDAV 服务器，不需要为 Git 设定特殊环境；所以如果主机提供商支持通过 WebDAV 更新网站内容，你也可以使用这项功能。 优点使用 HTTP 协议的好处是易于架设。几条必要的命令就可以让全世界读取到仓库的内容。花费不过几分钟。HTTP 协议不会占用过多服务器资源。因为它一般只用到静态的 HTTP 服务提供所有数据，普通的 Apache 服务器平均每秒能支撑数千个文件的并发访问 — 哪怕让一个小型服务器超载都很难。 你也可以通过 HTTPS 提供只读的仓库，这意味着你可以加密传输内容；你甚至可以要求客户端使用特定签名的 SSL 证书。一般情况下，如果到了这一步，使用 SSH 公共密钥可能是更简单的方案；不过也存在一些特殊情况，这时通过 HTTPS 使用带签名的 SSL 证书或者其他基于 HTTP 的只读连接授权方式是更好的解决方案。 HTTP 还有个额外的好处：HTTP 是一个如此常见的协议，以至于企业级防火墙通常都允许其端口的通信。 缺点HTTP 协议的消极面在于，相对来说客户端效率更低。克隆或者下载仓库内容可能会花费更多时间，而且 HTTP 传输的体积和网络开销比其他任何一个协议都大。因为它没有按需供应的能力 — 传输过程中没有服务端的动态计算 — 因而 HTTP 协议经常会被称为傻瓜（dumb）协议。更多 HTTP 协议和其他协议效率上的差异见第 9 章。]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 服务器上的 Git]]></title>
    <url>%2F2017%2F11%2F03%2Fgit-%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git%2F</url>
    <content type="text"><![CDATA[服务器上的 Git到目前为止，你应该已经学会了使用 Git 来完成日常工作。然而，如果想与他人合作，还需要一个远程的 Git 仓库。尽管技术上可以从个人的仓库里推送和拉取修改内容，但我们不鼓励这样做，因为一不留心就很容易弄混其他人的进度。另外，你也一定希望合作者们即使在自己不开机的时候也能从仓库获取数据 — 拥有一个更稳定的公共仓库十分有用。因此，更好的合作方式是建立一个大家都可以访问的共享仓库，从那里推送和拉取数据。我们将把这个仓库称为 “Git 服务器”；代理一个 Git 仓库只需要花费很少的资源，几乎从不需要整个服务器来支持它的运行。架设一台 Git 服务器并不难。第一步是选择与服务器通讯的协议。本章第一节将介绍可用的协议以及各自优缺点。下面一节将介绍一些针对各个协议典型的设置以及如何在服务器上实施。最后，如果你不介意在他人服务器上保存你的代码，又想免去自己架设和维护服务器的麻烦，倒可以试试我们介绍的几个仓库托管服务。 如果你对架设自己的服务器没兴趣，可以跳到本章最后一节去看看如何申请一个代码托管服务的账户然后继续下一章，我们会在那里讨论分布式源码控制环境的林林总总。 远程仓库通常只是一个裸仓库（bare repository） — 即一个没有当前工作目录的仓库。因为该仓库只是一个合作媒介，所以不需要从硬盘上取出最新版本的快照；仓库里存放的仅仅是 Git 的数据。简单地说，裸仓库就是你工作目录中 .git 子目录内的内容。]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 分支的变基]]></title>
    <url>%2F2017%2F11%2F03%2Fgit-%E5%88%86%E6%94%AF%E7%9A%84%E5%8F%98%E5%9F%BA%2F</url>
    <content type="text"><![CDATA[分支的变基把一个分支中的修改整合到另一个分支的办法有两种：merge 和 rebase。在本章我们会学习什么是变基，如何使用变基，为什么变基操作如此富有魅力，以及我们应该在什么情况下使用变基。 基本的变基操作请回顾之前有关合并的一节（见图 3-27），你会看到开发进程分叉到两个不同分支，又各自提交了更新。图 3-27. 最初分叉的提交历史。之前介绍过，最容易的整合分支的方法是 merge 命令，它会把两个分支最新的快照（C3 和 C4）以及二者最新的共同祖先（C2）进行三方合并，合并的结果是产生一个新的提交对象（C5）。如图 3-28 所示：图 3-28. 通过合并一个分支来整合分叉了的历史。其实，还有另外一个选择：你可以把在 C3 里产生的变化补丁在 C4 的基础上重新打一遍。在 Git 里，这种操作叫做变基（rebase）。有了 rebase 命令，就可以把在一个分支里提交的改变移到另一个分支里重放一遍。 在上面这个例子中，运行：1234$ git checkout experiment$ git rebase masterFirst, rewinding head to replay your work on top of it...Applying: added staged command 它的原理是回到两个分支最近的共同祖先，根据当前分支（也就是要进行变基的分支 experiment）后续的历次提交对象（这里只有一个 C3），生成一系列文件补丁，然后以基底分支（也就是主干分支 master）最后一个提交对象（C4）为新的出发点，逐个应用之前准备好的补丁文件，最后会生成一个新的合并提交对象（C3’），从而改写 experiment 的提交历史，使它成为 master 分支的直接下游，如图 3-29 所示：图 3-29. 把 C3 里产生的改变到 C4 上重演一遍。现在回到 master 分支，进行一次快进合并（见图 3-30）：图 3-30. master 分支的快进。现在的 C3’ 对应的快照，其实和普通的三方合并，即上个例子中的 C5 对应的快照内容一模一样了。虽然最后整合得到的结果没有任何区别，但变基能产生一个更为整洁的提交历史。如果视察一个变基过的分支的历史记录，看起来会更清楚：仿佛所有修改都是在一根线上先后进行的，尽管实际上它们原本是同时并行发生的。 一般我们使用变基的目的，是想要得到一个能在远程分支上干净应用的补丁 — 比如某些项目你不是维护者，但想帮点忙的话，最好用变基：先在自己的一个分支里进行开发，当准备向主项目提交补丁的时候，根据最新的 origin/master 进行一次变基操作然后再提交，这样维护者就不需要做任何整合工作（译注：实际上是把解决分支补丁同最新主干代码之间冲突的责任，化转为由提交补丁的人来解决。），只需根据你提供的仓库地址作一次快进合并，或者直接采纳你提交的补丁。 请注意，合并结果中最后一次提交所指向的快照，无论是通过变基，还是三方合并，都会得到相同的快照内容，只不过提交历史不同罢了。变基是按照每行的修改次序重演一遍修改，而合并是把最终结果合在一起。 有趣的变基变基也可以放到其他分支进行，并不一定非得根据分化之前的分支。以图 3-31 的历史为例，我们为了给服务器端代码添加一些功能而创建了特性分支 server，然后提交 C3 和 C4。然后又从 C3 的地方再增加一个 client 分支来对客户端代码进行一些相应修改，所以提交了 C8 和 C9。最后，又回到 server 分支提交了 C10。图 3-31. 从一个特性分支里再分出一个特性分支的历史。假设在接下来的一次软件发布中，我们决定先把客户端的修改并到主线中，而暂缓并入服务端软件的修改（因为还需要进一步测试）。这个时候，我们就可以把基于 client 分支而非 server 分支的改变（即 C8 和 C9），跳过 server 直接放到 master 分支中重演一遍，但这需要用 git rebase 的 --onto 选项指定新的基底分支 master：1$ git rebase --onto master server client 这好比在说：“取出 client 分支，找出 client 分支和 server 分支的共同祖先之后的变化，然后把它们在 master 上重演一遍”。是不是有点复杂？不过它的结果如图 3-32 所示，非常酷（译注：虽然 client 里的 C8, C9 在 C3 之后，但这仅表明时间上的先后，而非在 C3 修改的基础上进一步改动，因为 server 和 client 这两个分支对应的代码应该是两套文件，虽然这么说不是很严格，但应理解为在 C3 时间点之后，对另外的文件所做的 C8，C9 修改，放到主干重演。）：图 3-32. 将特性分支上的另一个特性分支变基到其他分支。现在可以快进 master 分支了（见图 3-33）：12$ git checkout master$ git merge client 图 3-33. 快进 master 分支，使之包含 client 分支的变化。现在我们决定把 server 分支的变化也包含进来。我们可以直接把 server 分支变基到 master，而不用手工切换到 server 分支后再执行变基操作 — git rebase [主分支] [特性分支] 命令会先取出特性分支 server，然后在主分支 master 上重演：1$ git rebase master server 于是，server 的进度应用到 master 的基础上，如图 3-34 所示：图 3-34. 在 master 分支上变基 server 分支。然后就可以快进主干分支 master 了：12$ git checkout master$ git merge server 现在 client 和 server 分支的变化都已经集成到主干分支来了，可以删掉它们了。最终我们的提交历史会变成图 3-35 的样子：12$ git branch -d client$ git branch -d server 图 3-35. 最终的提交历史 变基的风险呃，奇妙的变基也并非完美无缺，要用它得遵守一条准则：一旦分支中的提交对象发布到公共仓库，就千万不要对该分支进行变基操作。如果你遵循这条金科玉律，就不会出差错。否则，人民群众会仇恨你，你的朋友和家人也会嘲笑你，唾弃你。 在进行变基的时候，实际上抛弃了一些现存的提交对象而创造了一些类似但不同的新的提交对象。如果你把原来分支中的提交对象发布出去，并且其他人更新下载后在其基础上开展工作，而稍后你又用 git rebase 抛弃这些提交对象，把新的重演后的提交对象发布出去的话，你的合作者就不得不重新合并他们的工作，这样当你再次从他们那里获取内容时，提交历史就会变得一团糟。 下面我们用一个实际例子来说明为什么公开的变基会带来问题。假设你从一个中央服务器克隆然后在它的基础上搞了一些开发，提交历史类似图 3-36 所示：图 3-36. 克隆一个仓库，在其基础上工作一番。现在，某人在 C1 的基础上做了些改变，并合并他自己的分支得到结果 C6，推送到中央服务器。当你抓取并合并这些数据到你本地的开发分支中后，会得到合并结果 C7，历史提交会变成图 3-37 这样：图 3-37. 抓取他人提交，并入自己主干。接下来，那个推送 C6 上来的人决定用变基取代之前的合并操作；继而又用 git push --force 覆盖了服务器上的历史，得到 C4’。而之后当你再从服务器上下载最新提交后，会得到：图 3-38. 有人推送了变基后得到的 C4’，丢弃了你作为开发基础的 C4 和 C6。下载更新后需要合并，但此时变基产生的提交对象 C4’ 的 SHA-1 校验值和之前 C4 完全不同，所以 Git 会把它们当作新的提交对象处理，而实际上此刻你的提交历史 C7 中早已经包含了 C4 的修改内容，于是合并操作会把 C7 和 C4’ 合并为 C8（见图 3-39）:图 3-39. 你把相同的内容又合并了一遍，生成一个新的提交 C8。C8 这一步的合并是迟早会发生的，因为只有这样你才能和其他协作者提交的内容保持同步。而在 C8 之后，你的提交历史里就会同时包含 C4 和 C4’，两者有着不同的 SHA-1 校验值，如果用 git log 查看历史，会看到两个提交拥有相同的作者日期与说明，令人费解。而更糟的是，当你把这样的历史推送到服务器后，会再次把这些变基后的提交引入到中央服务器，进一步困扰其他人（译注：这个例子中，出问题的责任方是那个发布了 C6 后又用变基发布 C4’ 的人，其他人会因此反馈双重历史到共享主干，从而混淆大家的视听。）。 如果把变基当成一种在推送之前清理提交历史的手段，而且仅仅变基那些尚未公开的提交对象，就没问题。如果变基那些已经公开的提交对象，并且已经有人基于这些提交对象开展了后续开发工作的话，就会出现叫人沮丧的麻烦。]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 远程分支]]></title>
    <url>%2F2017%2F11%2F03%2Fgit-%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF%2F</url>
    <content type="text"><![CDATA[远程分支远程分支（remote branch）是对远程仓库中的分支的索引。它们是一些无法移动的本地分支；只有在 Git 进行网络交互时才会更新。远程分支就像是书签，提醒着你上次连接远程仓库时上面各分支的位置。 我们用 (远程仓库名)/(分支名) 这样的形式表示远程分支。比如我们想看看上次同 origin 仓库通讯时 master 分支的样子，就应该查看 origin/master 分支。如果你和同伴一起修复某个问题，但他们先推送了一个 iss53 分支到远程仓库，虽然你可能也有一个本地的 iss53 分支，但指向服务器上最新更新的却应该是 origin/iss53 分支。可能有点乱，我们不妨举例说明。假设你们团队有个地址为 git.ourcompany.com 的 Git 服务器。如果你从这里克隆，Git 会自动为你将此远程仓库命名为 origin，并下载其中所有的数据，建立一个指向它的 master 分支的指针，在本地命名为 origin/master，但你无法在本地更改其数据。接着，Git 建立一个属于你自己的本地 master 分支，始于 origin 上 master 分支相同的位置，你可以就此开始工作（见图 3-22）：一次 Git 克隆会建立你自己的本地分支 master 和远程分支 origin/master，并且将它们都指向 origin 上的 master 分支。如果你在本地 master 分支做了些改动，与此同时，其他人向 git.ourcompany.com 推送了他们的更新，那么服务器上的 master 分支就会向前推进，而与此同时，你在本地的提交历史正朝向不同方向发展。不过只要你不和服务器通讯，你的 origin/master 指针仍然保持原位不会移动（见图 3-23）。在本地工作的同时有人向远程仓库推送内容会让提交历史开始分流。可以运行 git fetch origin 来同步远程服务器上的数据到本地。该命令首先找到 origin 是哪个服务器（本例为 git.ourcompany.com），从上面获取你尚未拥有的数据，更新你本地的数据库，然后把 origin/master 的指针移到它最新的位置上（见图 3-24）。git fetch 命令会更新 remote 索引。为了演示拥有多个远程分支（在不同的远程服务器上）的项目是如何工作的，我们假设你还有另一个仅供你的敏捷开发小组使用的内部服务器 git.team1.ourcompany.com。可以用第二章中提到的 git remote add 命令把它加为当前项目的远程分支之一。我们把它命名为 teamone，以便代替完整的 Git URL 以方便使用（见图 3-25）。图 3-25. 把另一个服务器加为远程仓库现在你可以用 git fetch teamone 来获取小组服务器上你还没有的数据了。由于当前该服务器上的内容是你 origin 服务器上的子集，Git 不会下载任何数据，而只是简单地创建一个名为 teamone/master 的远程分支，指向 teamone 服务器上 master 分支所在的提交对象 31b8e（见图 3-26）。图 3-26. 你在本地有了一个指向 teamone 服务器上 master 分支的索引。 推送本地分支要想和其他人分享某个本地分支，你需要把它推送到一个你拥有写权限的远程仓库。你创建的本地分支不会因为你的写入操作而被自动同步到你引入的远程服务器上，你需要明确地执行推送分支的操作。换句话说，对于无意分享的分支，你尽管保留为私人分支好了，而只推送那些协同工作要用到的特性分支。 如果你有个叫 serverfix 的分支需要和他人一起开发，可以运行 git push (远程仓库名) (分支名)：1234567$ git push origin serverfixCounting objects: 20, done.Compressing objects: 100% (14/14), done.Writing objects: 100% (15/15), 1.74 KiB, done.Total 15 (delta 5), reused 0 (delta 0)To git@github.com:schacon/simplegit.git * [new branch] serverfix -&gt; serverfix 这里其实走了一点捷径。Git 自动把 serverfix 分支名扩展为 refs/heads/serverfix:refs/heads/serverfix，意为“取出我在本地的 serverfix 分支，推送到远程仓库的 serverfix 分支中去”。我们将在第九章进一步介绍 refs/heads/ 部分的细节，不过一般使用的时候都可以省略它。也可以运行 git push origin serverfix:serverfix 来实现相同的效果，它的意思是“上传我本地的 serverfix 分支到远程仓库中去，仍旧称它为 serverfix 分支”。通过此语法，你可以把本地分支推送到某个命名不同的远程分支：若想把远程分支叫作 awesomebranch，可以用 git push origin serverfix:awesomebranch 来推送数据。 接下来，当你的协作者再次从服务器上获取数据时，他们将得到一个新的远程分支 origin/serverfix，并指向服务器上 serverfix 所指向的版本：1234567$ git fetch originremote: Counting objects: 20, done.remote: Compressing objects: 100% (14/14), done.remote: Total 15 (delta 5), reused 0 (delta 0)Unpacking objects: 100% (15/15), done.From git@github.com:schacon/simplegit * [new branch] serverfix -&gt; origin/serverfix 值得注意的是，在 fetch 操作下载好新的远程分支之后，你仍然无法在本地编辑该远程仓库中的分支。换句话说，在本例中，你不会有一个新的 serverfix 分支，有的只是一个你无法移动的 origin/serverfix 指针。 如果要把该远程分支的内容合并到当前分支，可以运行 git merge origin/serverfix。如果想要一份自己的 serverfix 来开发，可以在远程分支的基础上分化出一个新的分支来：123$ git checkout -b serverfix origin/serverfixBranch serverfix set up to track remote branch serverfix from origin.Switched to a new branch &apos;serverfix&apos; 这会切换到新建的 serverfix 本地分支，其内容同远程分支 origin/serverfix 一致，这样你就可以在里面继续开发了。 跟踪远程分支从远程分支 checkout 出来的本地分支，称为 跟踪分支 (tracking branch)。跟踪分支是一种和某个远程分支有直接联系的本地分支。在跟踪分支里输入 git push，Git 会自行推断应该向哪个服务器的哪个分支推送数据。同样，在这些分支里运行 git pull 会获取所有远程索引，并把它们的数据都合并到本地分支中来。 在克隆仓库时，Git 通常会自动创建一个名为 master 的分支来跟踪 origin/master。这正是 git push 和 git pull 一开始就能正常工作的原因。当然，你可以随心所欲地设定为其它跟踪分支，比如 origin 上除了 master 之外的其它分支。刚才我们已经看到了这样的一个例子：git checkout -b [分支名] [远程名]/[分支名]。如果你有 1.6.2 以上版本的 Git，还可以用 --track 选项简化：123$ git checkout --track origin/serverfixBranch serverfix set up to track remote branch serverfix from origin.Switched to a new branch &apos;serverfix&apos; 要为本地分支设定不同于远程分支的名字，只需在第一个版本的命令里换个名字：123$ git checkout -b sf origin/serverfixBranch sf set up to track remote branch serverfix from origin.Switched to a new branch &apos;sf&apos; 现在你的本地分支 sf 会自动将推送和抓取数据的位置定位到 origin/serverfix 了 删除远程分支如果不再需要某个远程分支了，比如搞定了某个特性并把它合并进了远程的 master 分支（或任何其他存放稳定代码的分支），可以用这个非常无厘头的语法来删除它：git push [远程名] :[分支名]。如果想在服务器上删除 serverfix 分支，运行下面的命令：123$ git push origin :serverfixTo git@github.com:schacon/simplegit.git - [deleted] serverfix 咚！服务器上的分支没了。你最好特别留心这一页，因为你一定会用到那个命令，而且你很可能会忘掉它的语法。有种方便记忆这条命令的方法：记住我们不久前见过的 git push [远程名] [本地分支]:[远程分支] 语法，如果省略 [本地分支]，那就等于是在说“在这里提取空白然后把它变成[远程分支]”]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 利用分支进行开发的工作流程]]></title>
    <url>%2F2017%2F11%2F03%2Fgit-%E5%88%A9%E7%94%A8%E5%88%86%E6%94%AF%E8%BF%9B%E8%A1%8C%E5%BC%80%E5%8F%91%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[利用分支进行开发的工作流程现在我们已经学会了新建分支和合并分支，可以（或应该）用它来做点什么呢？在本节，我们会介绍一些利用分支进行开发的工作流程。而正是由于分支管理的便捷，才衍生出了这类典型的工作模式，你可以根据项目的实际情况选择一种用用看。 长期分支由于 Git 使用简单的三方合并，所以就算在较长一段时间内，反复多次把某个分支合并到另一分支，也不是什么难事。也就是说，你可以同时拥有多个开放的分支，每个分支用于完成特定的任务，随着开发的推进，你可以随时把某个特性分支的成果并到其他分支中。 许多使用 Git 的开发者都喜欢用这种方式来开展工作，比如仅在 master 分支中保留完全稳定的代码，即已经发布或即将发布的代码。与此同时，他们还有一个名为 develop 或 next 的平行分支，专门用于后续的开发，或仅用于稳定性测试 — 当然并不是说一定要绝对稳定，不过一旦进入某种稳定状态，便可以把它合并到 master 里。这样，在确保这些已完成的特性分支（短期分支，比如之前的 iss53 分支）能够通过所有测试，并且不会引入更多错误之后，就可以并到主干分支中，等待下一次的发布。本质上我们刚才谈论的，是随着提交对象不断右移的指针。稳定分支的指针总是在提交历史中落后一大截，而前沿分支总是比较靠前（见图 3-18）。或者把它们想象成工作流水线，或许更好理解一些，经过测试的提交对象集合被遴选到更稳定的流水线（见图 3-19）。你可以用这招维护不同层次的稳定性。某些大项目还会有个 proposed（建议）或 pu（proposed updates，建议更新）分支，它包含着那些可能还没有成熟到进入 next 或 master 的内容。这么做的目的是拥有不同层次的稳定性：当这些分支进入到更稳定的水平时，再把它们合并到更高层分支中去。再次说明下，使用多个长期分支的做法并非必需，不过一般来说，对于特大型项目或特复杂的项目，这么做确实更容易管理。 特性分支在任何规模的项目中都可以使用特性（Topic）分支。一个特性分支是指一个短期的，用来实现单一特性或与其相关工作的分支。可能你在以前的版本控制系统里从未做过类似这样的事情，因为通常创建与合并分支消耗太大。然而在 Git 中，一天之内建立、使用、合并再删除多个分支是常见的事。 我们在上节的例子里已经见过这种用法了。我们创建了 iss53 和 hotfix 这两个特性分支，在提交了若干更新后，把它们合并到主干分支，然后删除。该技术允许你迅速且完全的进行语境切换 — 因为你的工作分散在不同的流水线里，每个分支里的改变都和它的目标特性相关，浏览代码之类的事情因而变得更简单了。你可以把作出的改变保持在特性分支中几分钟，几天甚至几个月，等它们成熟以后再合并，而不用在乎它们建立的顺序或者进度。 现在我们来看一个实际的例子。请看图 3-20，由下往上，起先我们在 master 工作到 C1，然后开始一个新分支 iss91 尝试修复 91 号缺陷，提交到 C6 的时候，又冒出一个解决该问题的新办法，于是从之前 C4 的地方又分出一个分支 iss91v2，干到 C8 的时候，又回到主干 master 中提交了 C9 和 C10，再回到 iss91v2 继续工作，提交 C11，接着，又冒出个不太确定的想法，从 master 的最新提交 C10 处开了个新的分支 dumbidea 做些试验。现在，假定两件事情：我们最终决定使用第二个解决方案，即 iss91v2 中的办法；另外，我们把 dumbidea 分支拿给同事们看了以后，发现它竟然是个天才之作。所以接下来，我们准备抛弃原来的 iss91 分支（实际上会丢弃 C5 和 C6），直接在主干中并入另外两个分支。最终的提交历史将变成图 3-21 这样：请务必牢记这些分支全部都是本地分支，这一点很重要。当你在使用分支及合并的时候，一切都是在你自己的 Git 仓库中进行的 — 完全不涉及与服务器的交互。]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 分支的管理]]></title>
    <url>%2F2017%2F11%2F03%2Fgit-%E5%88%86%E6%94%AF%E7%9A%84%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[分支的管理到目前为止，你已经学会了如何创建、合并和删除分支。除此之外，我们还需要学习如何管理分支，在日后的常规工作中会经常用到下面介绍的管理命令。 git branch 命令不仅仅能创建和删除分支，如果不加任何参数，它会给出当前所有分支的清单：1234$ git branch iss53* master testing 注意看 master 分支前的 * 字符：它表示当前所在的分支。也就是说，如果现在提交更新，master 分支将随着开发进度前移。若要查看各个分支最后一个提交对象的信息，运行 git branch -v：1234$ git branch -v iss53 93b412c fix javascript issue* master 7a98805 Merge branch &apos;iss53&apos; testing 782fd34 add scott to the author list in the readmes 要从该清单中筛选出你已经（或尚未）与当前分支合并的分支，可以用 --merged 和 --no-merged 选项（Git 1.5.6 以上版本）。比如用 git branch --merged 查看哪些分支已被并入当前分支（译注：也就是说哪些分支是当前分支的直接上游。）：123$ git branch --merged iss53* master 之前我们已经合并了 iss53，所以在这里会看到它。一般来说，列表中没有 * 的分支通常都可以用 git branch -d 来删掉。原因很简单，既然已经把它们所包含的工作整合到了其他分支，删掉也不会损失什么。 另外可以用 git branch --no-merged 查看尚未合并的工作：12$ git branch --no-merged testing 它会显示还未合并进来的分支。由于这些分支中还包含着尚未合并进来的工作成果，所以简单地用 git branch -d 删除该分支会提示错误，因为那样做会丢失数据：123$ git branch -d testingerror: The branch &apos;testing&apos; is not fully merged.If you are sure you want to delete it, run &apos;git branch -D testing&apos;. 不过，如果你确实想要删除该分支上的改动，可以用大写的删除选项 -D强制执行，就像上面提示信息中给出的那样。]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 分支的新建与合并]]></title>
    <url>%2F2017%2F11%2F03%2Fgit-%E5%88%86%E6%94%AF%E7%9A%84%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6%2F</url>
    <content type="text"><![CDATA[分支的新建与合并现在让我们来看一个简单的分支与合并的例子，实际工作中大体也会用到这样的工作流程： 开发某个网站。 为实现某个新的需求，创建一个分支。 在这个分支上开展工作。假设此时，你突然接到一个电话说有个很严重的问题需要紧急修补，那么可以按照下面的方式处理： 返回到原先已经发布到生产服务器上的分支。 为这次紧急修补建立一个新分支，并在其中修复问题。 通过测试后，回到生产服务器所在的分支，将修补分支合并进来，然后再推送到生产服务器上。 切换到之前实现新需求的分支，继续工作。 分支的新建与切换首先，我们假设你正在项目中愉快地工作，并且已经提交了几次更新现在，你决定要修补问题追踪系统上的 #53 问题。顺带说明下，Git 并不同任何特定的问题追踪系统打交道。这里为了说明要解决的问题，才把新建的分支取名为 iss53。要新建并切换到该分支，运行 git checkout 并加上 -b 参数：12 git checkout -b iss53Switched to a new branch &apos;iss53&apos; 这相当于执行下面这两条命令：12$ git branch iss53$ git checkout iss53 示意该命令的执行结果。创建了一个新分支的指针接着你开始尝试修复问题，在提交了若干次更新后，iss53 分支的指针也会随着向前推进，因为它就是当前分支（换句话说，当前的 HEAD 指针正指向 iss53，见图 3-12）：12$ vim index.html$ git commit -a -m &apos;added a new footer [issue 53]&apos; 现在你就接到了那个网站问题的紧急电话，需要马上修补。有了 Git ，我们就不需要同时发布这个补丁和 iss53 里作出的修改，也不需要在创建和发布该补丁到服务器之前花费大力气来复原这些修改。唯一需要的仅仅是切换回 master 分支。 不过在此之前，留心你的暂存区或者工作目录里，那些还没有提交的修改，它会和你即将检出的分支产生冲突从而阻止 Git 为你切换分支。切换分支的时候最好保持一个清洁的工作区域。稍后会介绍几个绕过这种问题的办法（分别叫做 stashing 和 commit amending）。目前已经提交了所有的修改，所以接下来可以正常转换到 master 分支：12$ git checkout masterSwitched to branch &apos;master&apos; 此时工作目录中的内容和你在解决问题 #53 之前一模一样，你可以集中精力进行紧急修补。这一点值得牢记：Git 会把工作目录的内容恢复为检出某分支时它所指向的那个提交对象的快照。它会自动添加、删除和修改文件以确保目录的内容和你当时提交时完全一样。 接下来，你得进行紧急修补。我们创建一个紧急修补分支 hotfix 来开展工作，直到搞定:123456$ git checkout -b hotfixSwitched to a new branch &apos;hotfix&apos;$ vim index.html$ git commit -a -m &apos;fixed the broken email address&apos;[hotfix 3a0874c] fixed the broken email address 1 files changed, 1 deletion(-) 有必要作些测试，确保修补是成功的，然后回到 master 分支并把它合并进来，然后发布到生产服务器。用 git merge 命令来进行合并：123456$ git checkout master$ git merge hotfixUpdating f42c576..3a0874cFast-forward README | 1 - 1 file changed, 1 deletion(-) 请注意，合并时出现了“Fast forward”的提示。由于当前 master 分支所在的提交对象是要并入的 hotfix 分支的直接上游，Git 只需把 master 分支指针直接右移。换句话说，如果顺着一个分支走下去可以到达另一个分支的话，那么 Git 在合并两者时，只会简单地把指针右移，因为这种单线的历史分支不存在任何需要解决的分歧，所以这种合并过程可以称为快进（Fast forward）。 现在最新的修改已经在当前 master 分支所指向的提交对象中了，可以部署到生产服务器上去了 在那个超级重要的修补发布以后，你想要回到被打扰之前的工作。由于当前 hotfix 分支和 master 都指向相同的提交对象，所以 hotfix 已经完成了历史使命，可以删掉了。使用 git branch 的 -d 选项执行删除操作：12$ git branch -d hotfixDeleted branch hotfix (was 3a0874c). 现在回到之前未完成的123456$ git checkout iss53Switched to branch &apos;iss53&apos;$ vim index.html$ git commit -a -m &apos;finished the new footer [issue 53]&apos;[iss53 ad82d7a] finished the new footer [issue 53] 1 file changed, 1 insertion(+) 值得注意的是之前 hotfix 分支的修改内容尚未包含到 iss53 中来。如果需要纳入此次修补，可以用 git merge master 把 master 分支合并到 iss53；或者等 iss53 完成之后，再将 iss53 分支中的更新并入 master。 分支的合并合并回 master 分支。实际操作同前面合并 hotfix 分支差不多，只需回到 master 分支，运行 git merge 命令指定要合并进来的分支：123456$ git checkout master$ git merge iss53Auto-merging READMEMerge made by the &apos;recursive&apos; strategy. README | 1 + 1 file changed, 1 insertion(+) 请注意，这次合并操作的底层实现，并不同于之前 hotfix 的并入方式。因为这次你的开发历史是从更早的地方开始分叉的。由于当前 master 分支所指向的提交对象（C4）并不是 iss53 分支的直接祖先，Git 不得不进行一些额外处理。就此例而言，Git 会用两个分支的末端（C4 和 C5）以及它们的共同祖先（C2）进行一次简单的三方合并计算。图 3-16 用红框标出了 Git 用于合并的三个提交对象：这次，Git 没有简单地把分支指针右移，而是对三方合并后的结果重新做一个新的快照，并自动创建一个指向它的提交对象（C6）（见图 3-17）。这个提交对象比较特殊，它有两个祖先（C4 和 C5）。 值得一提的是 Git 可以自己裁决哪个共同祖先才是最佳合并基础；这和 CVS 或 Subversion（1.5 以后的版本）不同，它们需要开发者手工指定合并基础。所以此特性让 Git 的合并操作比其他系统都要简单不少。既然之前的工作成果已经合并到 master 了，那么 iss53 也就没用了。你可以就此删除它，并在问题追踪系统里关闭该问题。1$ git branch -d iss53 ### 遇到冲突时的分支合并有时候合并操作并不会如此顺利。如果在不同的分支中都修改了同一个文件的同一部分，Git 就无法干净地把两者合到一起（译注：逻辑上说，这种问题只能由人来裁决。）。如果你在解决问题 #53 的过程中修改了 hotfix 中修改的部分，将得到类似下面的结果：1234$ git merge iss53Auto-merging index.htmlCONFLICT (content): Merge conflict in index.htmlAutomatic merge failed; fix conflicts and then commit the result. Git 作了合并，但没有提交，它会停下来等你解决冲突。要看看哪些文件在合并时发生冲突，可以用 git status 查阅：1234567891011$ git statusOn branch masterYou have unmerged paths. (fix conflicts and run &quot;git commit&quot;)Unmerged paths: (use &quot;git add &lt;file&gt;...&quot; to mark resolution) both modified: index.htmlno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 任何包含未解决冲突的文件都会以未合并（unmerged）的状态列出。Git 会在有冲突的文件里加入标准的冲突解决标记，可以通过它们来手工定位并解决这些冲突。可以看到此文件包含类似下面这样的部分：1234567&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD&lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt;=======&lt;div id=&quot;footer&quot;&gt; please contact us at support@github.com&lt;/div&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53 可以看到 ======= 隔开的上半部分，是 HEAD（即 master 分支，在运行 merge 命令时所切换到的分支）中的内容，下半部分是在 iss53 分支中的内容。解决冲突的办法无非是二者选其一或者由你亲自整合到一起。比如你可以通过把这段内容替换为下面这样来解决：123&lt;div id=&quot;footer&quot;&gt;please contact us at email.support@github.com&lt;/div&gt; 这个解决方案各采纳了两个分支中的一部分内容，而且我还删除了 &lt;&lt;&lt;&lt;&lt;&lt;&lt;，======= 和 &gt;&gt;&gt;&gt;&gt;&gt;&gt; 这些行。在解决了所有文件里的所有冲突后，运行 git add 将把它们标记为已解决状态（译注：实际上就是来一次快照保存到暂存区域。）。因为一旦暂存，就表示冲突已经解决。如果你想用一个有图形界面的工具来解决这些问题，不妨运行 git mergetool，它会调用一个可视化的合并工具并引导你解决所有冲突：12345678910111213$ git mergetoolThis message is displayed because &apos;merge.tool&apos; is not configured.See &apos;git mergetool --tool-help&apos; or &apos;git help config&apos; for more details.&apos;git mergetool&apos; will now attempt to use one of the following tools:opendiff kdiff3 tkdiff xxdiff meld tortoisemerge gvimdiff diffuse diffmerge ecmerge p4merge araxis bc3 codecompare vimdiff emergeMerging:index.htmlNormal merge conflict for &apos;index.html&apos;: &#123;local&#125;: modified file &#123;remote&#125;: modified fileHit return to start merge resolution tool (opendiff): 如果不想用默认的合并工具（Git 为我默认选择了 opendiff，因为我在 Mac 上运行了该命令），你可以在上方”merge tool candidates”里找到可用的合并工具列表，输入你想用的工具名。我们将在第七章讨论怎样改变环境中的默认值。 退出合并工具以后，Git 会询问你合并是否成功。如果回答是，它会为你把相关文件暂存起来，以表明状态为已解决。 再运行一次 git status 来确认所有冲突都已解决：123456$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: index.html 如果觉得满意了，并且确认所有冲突都已解决，也就是进入了暂存区，就可以用 git commit 来完成这次合并提交。提交的记录差不多是这样：12345678910Merge branch &apos;iss53&apos;Conflicts: index.html## It looks like you may be committing a merge.# If this is not correct, please remove the file# .git/MERGE_HEAD# and try again.# 如果想给将来看这次合并的人一些方便，可以修改该信息，提供更多合并细节。比如你都作了哪些改动，以及这么做的原因。有时候裁决冲突的理由并不直接或明显，有必要略加注解。]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 分支简介]]></title>
    <url>%2F2017%2F11%2F02%2Fgit-%E5%88%86%E6%94%AF%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。 在很多版本控制系统中，这是一个略微低效的过程——常常需要完全创建一个源代码目录的副本。对于大项目来说，这样的过程会耗费很多时间。 有人把 Git 的分支模型称为它的`‘必杀技特性’’，也正因为这一特性，使得 Git 从众多版本控制系统中脱颖而出。 为何 Git 的分支模型如此出众呢？ Git 处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。 与许多其它版本控制系统不同，Git 鼓励在工作流程中频繁地使用分支与合并，哪怕一天之内进行许多次。 理解和精通这一特性，你便会意识到 Git 是如此的强大而又独特，并且从此真正改变你的开发方式。 分支简介为了真正理解 Git 处理分支的方式，我们需要回顾一下 Git 是如何保存数据的。 或许你还记得 起步 的内容，Git 保存的不是文件的变化或者差异，而是一系列不同时刻的文件快照。在进行提交操作时，Git 会保存一个提交对象（commit object）。知道了 Git 保存数据的方式，我们可以很自然的想到——该提交对象会包含一个指向暂存内容快照的指针。 但不仅仅是这样，该提交对象还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针。首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象，而由多个分支合并产生的提交对象有多个父对象， 为了更加形象地说明，我们假设现在有一个工作目录，里面包含了三个将要被暂存和提交的文件。 暂存操作会为每一个文件计算校验和（使用我们在 起步 中提到的 SHA-1 哈希算法），然后会把当前版本的文件快照保存到 Git 仓库中（Git 使用 blob 对象来保存它们），最终将校验和加入到暂存区域等待提交：12$ git add README test.rb LICENSE$ git commit -m &apos;The initial commit of my project&apos; 当使用 git commit 进行提交操作时，Git 会先计算每一个子目录（本例中只有项目根目录）的校验和，然后在 Git 仓库中这些校验和保存为树对象。 随后，Git 便会创建一个提交对象，它除了包含上面提到的那些信息外，还包含指向这个树对象（项目根目录）的指针。如此一来，Git 就可以在需要的时候重现此次保存的快照。 现在，Git 仓库中有五个对象：三个 blob 对象（保存着文件快照）、一个树对象（记录着目录结构和 blob 对象索引）以及一个提交对象（包含着指向前述树对象的指针和所有提交信息）。 首次提交对象及其树结构做些修改后再次提交，那么这次产生提交对象会包含一个指向上次提交对象（父对象）的指针。 提交对象及其父对象Git 的分支，其实本质上仅仅是指向提对象的可变指针。 Git 的默认分支名字是 master。 在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 master 分支。 它会在每次的提交操作中自动向前移动。1Git 的 “master” 分支并不是一个特殊分支。 它就跟其它分支完全没有区别。 之所以几乎每一个仓库都有 master 分支，是因为 `git init` 命令默认创建它，并且大多数人都懒得去改动它。 分支创建Git 是怎么创建新分支的呢？ 很简单，它只是为你创建了一个可以移动的新的指针。 比如，创建一个 testing 分支， 你需要使用 git branch 命令：1$ git branch testing 这会在当前所在的提交对象上创建一个指针。 两个指向相同提交历史的分支那么，Git 又是怎么知道当前在哪一个分支上呢？ 也很简单，它有一个名为 HEAD 的特殊指针。 请注意它和许多其它版本控制系统（如 Subversion 或 CVS）里的 HEAD 概念完全不同。 在 Git 中，它是一个指针，指向当前所在的本地分支（译注：将 HEAD 想象为当前分支的别名）。 在本例中，你仍然在 master 分支上。 因为 git branch 命令仅仅 创建 一个新分支，并不会自动切换到新分支中去。 HEAD 指向当前所在的分支你可以简单地使用 git log 命令查看各个分支当前所指的对象。 提供这一功能的参数是 --decorate。 1234$ git log --oneline --decoratef30ab (HEAD, master, testing) add feature #32 - ability to add new34ac2 fixed bug #1328 - stack overflow under certain conditions98ca9 initial commit of my project 正如你所见，当前 “master” 和 “testing” 分支均指向校验和以 f30ab 开头的提交对象。 分支切换要切换到一个已存在的分支，你需要使用 git checkout 命令。 我们现在切换到新创建的 testing 分支去：1$ git checkout testing 这样 HEAD 就指向 testing 分支了。 HEAD 指向当前所在的分支那么，这样的实现方式会给我们带来什么好处呢？ 现在不妨再提交一次：12$ vim test.rb$ git commit -a -m &apos;made a change&apos; HEAD 分支随着提交操作自动向前移动如图所示，你的 testing 分支向前移动了，但是 master 分支却没有，它仍然指向运行 git checkout 时所指的对象。 这就有意思了，现在我们切换回 master 分支看看：1$ git checkout master 检出时 HEAD 随之移动这条命令做了两件事。 一是使 HEAD 指回 master 分支，二是将工作目录恢复成 master 分支所指向的快照内容。 也就是说，你现在做修改的话，项目将始于一个较旧的版本。 本质上来讲，这就是忽略 testing 分支所做的修改，以便于向另一个方向进行开发。12分支切换会改变你工作目录中的文件在切换分支时，一定要注意你工作目录里的文件会被改变。 如果是切换到一个较旧的分支，你的工作目录会恢复到该分支最后一次提交时的样子。 如果 Git 不能干净利落地完成这个任务，它将禁止切换分支。 我们不妨再稍微做些修改并提交：12$ vim test.rb$ git commit -a -m &apos;made other changes&apos; 现在，这个项目的提交历史已经产生了分叉（参见 项目分叉历史）。 因为刚才你创建了一个新分支，并切换过去进行了一些工作，随后又切换回 master 分支进行了另外一些工作。 上述两次改动针对的是不同分支：你可以在不同分支间不断地来回切换和工作，并在时机成熟时将它们合并起来。 而所有这些工作，你需要的命令只有 branch、checkout 和 commit。 项目分叉历史你可以简单地使用 git log 命令查看分叉历史。 运行 git log --oneline --decorate --graph --all ，它会输出你的提交历史、各个分支的指向以及项目的分支分叉情况。1234567$ git log --oneline --decorate --graph --all* c2b9e (HEAD, master) made other changes| * 87ab2 (testing) made a change|/* f30ab add feature #32 - ability to add new formats to the* 34ac2 fixed bug #1328 - stack overflow under certain conditions* 98ca9 initial commit of my project 由于 Git 的分支实质上仅是包含所指对象校验和（长度为 40 的 SHA-1 值字符串）的文件，所以它的创建和销毁都异常高效。 创建一个新分支就相当于往一个文件中写入 41 个字节（40 个字符和 1 个换行符），如此的简单能不快吗？ 这与过去大多数版本控制系统形成了鲜明的对比，它们在创建分支时，将所有的项目文件都复制一遍，并保存到一个特定的目录。 完成这样繁琐的过程通常需要好几秒钟，有时甚至需要好几分钟。所需时间的长短，完全取决于项目的规模。而在 Git 中，任何规模的项目都能在瞬间创建新分支。 同时，由于每次提交都会记录父对象，所以寻找恰当的合并基础（译注：即共同祖先）也是同样的简单和高效。 这些高效的特性使得 Git 鼓励开发人员频繁地创建和使用分支。 接下来，让我们看看你为什么应该这样做。]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 别名]]></title>
    <url>%2F2017%2F11%2F02%2Fgit-%E5%88%AB%E5%90%8D%2F</url>
    <content type="text"><![CDATA[Git 别名在我们结束本章 Git 基础之前，正好有一个小技巧可以使你的 Git 体验更简单、容易、熟悉：别名。 我们不会在之后的章节中引用到或假定你使用过它们，但是你大概应该知道如何使用它们。 Git 并不会在你输入部分命令时自动推断出你想要的命令。 如果不想每次都输入完整的 Git 命令，可以通过 git config 文件来轻松地为每一个命令设置一个别名。 这里有一些例子你可以试试：1234$ git config --global alias.co checkout$ git config --global alias.br branch$ git config --global alias.ci commit$ git config --global alias.st status 这意味着，当要输入 git commit 时，只需要输入 git ci。 随着你继续不断地使用 Git，可能也会经常使用其他命令，所以创建别名时不要犹豫。 在创建你认为应该存在的命令时这个技术会很有用。 例如，为了解决取消暂存文件的易用性问题，可以向 Git 中添加你自己的取消暂存别名：1$ git config --global alias.unstage &apos;reset HEAD --&apos; 这会使下面的两个命令等价：12it unstage fileA$ git reset HEAD -- fileA 这样看起来更清楚一些。 通常也会添加一个 last 命令，像这样：1$ git config --global alias.last &apos;log -1 HEAD&apos; 这样，可以轻松地看到最后一次提交：12345678t lastcommit 66938dae3329c7aebe598c2246a8e6af90d04646Author: Josh Goebel &lt;dreamer3@example.com&gt;Date: Tue Aug 26 19:48:51 2008 +0800 test for current head Signed-off-by: Scott Chacon &lt;schacon@example.com&gt; 以看出，Git 只是简单地将别名替换为对应的命令。 然而，你可能想要执行外部命令，而不是一个 Git 子命令。 如果是那样的话，可以在命令前面加入 ! 符号。 如果你自己要写一些与 Git 仓库协作的工具的话，那会很有用。 我们现在演示将 git visual 定义为 gitk 的别名：1git config --global alias.visual &apos;!gitk&apos;]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 打标签]]></title>
    <url>%2F2017%2F11%2F02%2Fgit-%E6%89%93%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[打标签像其他版本控制系统（VCS）一样，Git 可以给历史中的某一个提交打上标签，以示重要。 比较有代表性的是人们会使用这个功能来标记发布结点（v1.0 等等）。 在本节中，你将会学习如何列出已有的标签、如何创建新标签、以及不同类型的标签分别是什么。 列出标签在 Git 中列出已有的标签是非常简单直观的。 只需要输入 git tag：123$ git tagv0.1v1.3 这个命令以字母顺序列出标签；但是它们出现的顺序并不重要。你也可以使用特定的模式查找标签。 例如，Git 自身的源代码仓库包含标签的数量超过 500 个。 如果只对 1.8.5 系列感兴趣，可以运行：1234567891011$ git tag -l &apos;v1.8.5*&apos;v1.8.5v1.8.5-rc0v1.8.5-rc1v1.8.5-rc2v1.8.5-rc3v1.8.5.1v1.8.5.2v1.8.5.3v1.8.5.4v1.8.5.5 创建标签Git 使用两种主要类型的标签：轻量标签（lightweight）与附注标签（annotated）。 一个轻量标签很像一个不会改变的分支 - 它只是一个特定提交的引用。 然而，附注标签是存储在 Git 数据库中的一个完整对象。 它们是可以被校验的；其中包含打标签者的名字、电子邮件地址、日期时间；还有一个标签信息；并且可以使用 GNU Privacy Guard （GPG）签名与验证。 通常建议创建附注标签，这样你可以拥有以上所有信息；但是如果你只是想用一个临时的标签，或者因为某些原因不想要保存那些信息，轻量标签也是可用的。 附注标签在 Git 中创建一个附注标签是很简单的。 最简单的方式是当你在运行 tag 命令时指定 -a选项：12345$ git tag -a v1.4 -m &apos;my version 1.4&apos;$ git tagv0.1v1.3v1.4 -m 选项指定了一条将会存储在标签中的信息。 如果没有为附注标签指定一条信息，Git 会运行编辑器要求你输入信息。 通过使用 git show 命令可以看到标签信息与对应的提交信息：123456789101112$ git show v1.4tag v1.4Tagger: Ben Straub &lt;ben@straub.cc&gt;Date: Sat May 3 20:19:12 2014 -0700my version 1.4commit ca82a6dff817ec66f44342007202690a93763949Author: Scott Chacon &lt;schacon@gee-mail.com&gt;Date: Mon Mar 17 21:52:11 2008 -0700 changed the version number 输出显示了打标签者的信息、打标签的日期时间、附注信息，然后显示具体的提交信息。 轻量标签另一种给提交打标签的方式是使用轻量标签。 轻量标签本质上是将提交校验和存储到一个文件中 - 没有保存任何其他信息。 创建轻量标签，不需要使用 -a、-s 或 -m 选项，只需要提供标签名字：1234567$ git tag v1.4-lw$ git tagv0.1v1.3v1.4v1.4-lwv1.5 这时，如果在标签上运行 git show，你不会看到额外的标签信息。 命令只会显示出提交信息： 123456$ git show v1.4-lwcommit ca82a6dff817ec66f44342007202690a93763949Author: Scott Chacon &lt;schacon@gee-mail.com&gt;Date: Mon Mar 17 21:52:11 2008 -0700 changed the version number 后期打标签你也可以对过去的提交打标签。 假设提交历史是这样的：1234567891011$ git log --pretty=oneline15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch &apos;experiment&apos;a6b4c97498bd301d84096da251c98a07c7723e65 beginning write support0d52aaab4479697da7686c15f77a3d64d9165190 one more thing6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch &apos;experiment&apos;0b7434d86859cc7b8c3d5e1dddfed66ff742fcbc added a commit function4682c3261057305bdd616e23b64b0857d832627b added a todo file166ae0c4d3f420721acbb115cc33848dfcc2121a started write support9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme 现在，假设在 v1.2 时你忘记给项目打标签，也就是在 “updated rakefile” 提交。 你可以在之后补上标签。 要在那个提交上打标签，你需要在命令的末尾指定提交的校验和（或部分校验和）:1$ git tag -a v1.2 9fceb02 可以看到你已经在那次提交上打上标签了：1234567891011121314151617181920$ git tagv0.1v1.2v1.3v1.4v1.4-lwv1.5$ git show v1.2tag v1.2Tagger: Scott Chacon &lt;schacon@gee-mail.com&gt;Date: Mon Feb 9 15:32:16 2009 -0800version 1.2commit 9fceb02d0ae598e95dc970b74767f19372d61af8Author: Magnus Chacon &lt;mchacon@gee-mail.com&gt;Date: Sun Apr 27 20:43:35 2008 -0700 updated rakefile... 共享标签默认情况下，git push 命令并不会传送标签到远程仓库服务器上。 在创建完标签后你必须显式地推送标签到共享服务器上。 这个过程就像共享远程分支一样 - 你可以运行 git push origin [tagname]。12345678$ git push origin v1.5Counting objects: 14, done.Delta compression using up to 8 threads.Compressing objects: 100% (12/12), done.Writing objects: 100% (14/14), 2.05 KiB | 0 bytes/s, done.Total 14 (delta 3), reused 0 (delta 0)To git@github.com:schacon/simplegit.git * [new tag] v1.5 -&gt; v1.5 如果想要一次性推送很多标签，也可以使用带有 --tags 选项的 git push 命令。 这将会把所有不在远程仓库服务器上的标签全部传送到那里。1234567$ git push origin --tagsCounting objects: 1, done.Writing objects: 100% (1/1), 160 bytes | 0 bytes/s, done.Total 1 (delta 0), reused 0 (delta 0)To git@github.com:schacon/simplegit.git * [new tag] v1.4 -&gt; v1.4 * [new tag] v1.4-lw -&gt; v1.4-lw 现在，当其他人从仓库中克隆或拉取，他们也能得到你的那些标签。 检出标签在 Git 中你并不能真的检出一个标签，因为它们并不能像分支一样来回移动。 如果你想要工作目录与仓库中特定的标签版本完全一样，可以使用 git checkout -b [branchname] [tagname] 在特定的标签上创建一个新分支：12$ git checkout -b version2 v2.0.0Switched to a new branch &apos;version2&apos; 当然，如果在这之后又进行了一次提交，version2 分支会因为改动向前移动了，那么 version2 分支就会和 v2.0.0 标签稍微有些不同，这时就应该当心了。]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 远程创库的使用]]></title>
    <url>%2F2017%2F11%2F02%2Fgit-%E8%BF%9C%E7%A8%8B%E5%88%9B%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[远程仓库的使用为了能在任意 Git 项目上协作，你需要知道如何管理自己的远程仓库。 远程仓库是指托管在因特网或其他网络中的你的项目的版本库。 你可以有好几个远程仓库，通常有些仓库对你只读，有些则可以读写。 与他人协作涉及管理远程仓库以及根据需要推送或拉取数据。 管理远程仓库包括了解如何添加远程仓库、移除无效的远程仓库、管理不同的远程分支并定义它们是否被跟踪等等。 在本节中，我们将介绍一部分远程管理的技能。 查看远程仓库如果想查看你已经配置的远程仓库服务器，可以运行 git remote 命令。 它会列出你指定的每一个远程服务器的简写。 如果你已经克隆了自己的仓库，那么至少应该能看到 origin - 这是 Git 给你克隆的仓库服务器的默认名字：12345678910$ git clone https://github.com/schacon/ticgitCloning into &apos;ticgit&apos;...remote: Reusing existing pack: 1857, done.remote: Total 1857 (delta 0), reused 0 (delta 0)Receiving objects: 100% (1857/1857), 374.35 KiB | 268.00 KiB/s, done.Resolving deltas: 100% (772/772), done.Checking connectivity... done.$ cd ticgit$ git remoteorigin 你也可以指定选项 -v，会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。123$ git remote -vorigin https://github.com/schacon/ticgit (fetch)origin https://github.com/schacon/ticgit (push) 如果你的远程仓库不止一个，该命令会将它们全部列出。 例如，与几个协作者合作的，拥有多个远程仓库的仓库看起来像下面这样：123456789101112$ cd grit$ git remote -vbakkdoor https://github.com/bakkdoor/grit (fetch)bakkdoor https://github.com/bakkdoor/grit (push)cho45 https://github.com/cho45/grit (fetch)cho45 https://github.com/cho45/grit (push)defunkt https://github.com/defunkt/grit (fetch)defunkt https://github.com/defunkt/grit (push)koke git://github.com/koke/grit.git (fetch)koke git://github.com/koke/grit.git (push)origin git@github.com:mojombo/grit.git (fetch)origin git@github.com:mojombo/grit.git (push) 这样我们可以轻松拉取其中任何一个用户的贡献。 此外，我们大概还会有某些远程仓库的推送权限，虽然我们目前还不会在此介绍。 注意这些远程仓库使用了不同的协议；我们将会在 在服务器上搭建 Git 中了解关于它们的更多信息。 添加远程仓库我在之前的章节中已经提到并展示了如何添加远程仓库的示例，不过这里将告诉你如何明确地做到这一点。 运行 git remote add &lt;shortname&gt; &lt;url&gt; 添加一个新的远程 Git 仓库，同时指定一个你可以轻松引用的简写：12345678$ git remoteorigin$ git remote add pb https://github.com/paulboone/ticgit$ git remote -vorigin https://github.com/schacon/ticgit (fetch)origin https://github.com/schacon/ticgit (push)pb https://github.com/paulboone/ticgit (fetch)pb https://github.com/paulboone/ticgit (push) 现在你可以在命令行中使用字符串 pb 来代替整个 URL。 例如，如果你想拉取 Paul 的仓库中有但你没有的信息，可以运行 git fetch pb：12345678$ git fetch pbremote: Counting objects: 43, done.remote: Compressing objects: 100% (36/36), done.remote: Total 43 (delta 10), reused 31 (delta 5)Unpacking objects: 100% (43/43), done.From https://github.com/paulboone/ticgit * [new branch] master -&gt; pb/master * [new branch] ticgit -&gt; pb/ticgit 现在 Paul 的 master 分支可以在本地通过 pb/master 访问到 - 你可以将它合并到自己的某个分支中，或者如果你想要查看它的话，可以检出一个指向该点的本地分支。 （我们将会在 Git 分支 中详细介绍什么是分支以及如何使用分支。） 从远程仓库中抓取与拉取就如刚才所见，从远程仓库中获得数据，可以执行：1$ git fetch [remote-name] 这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。 如果你使用 clone 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。 所以，git fetch origin 会抓取克隆（或上一次抓取）后新推送的所有工作。 必须注意 git fetch 命令会将数据拉取到你的本地仓库 - 它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。 如果你有一个分支设置为跟踪一个远程分支（阅读下一节与 Git 分支 了解更多信息），可以使用 git pull 命令来自动的抓取然后合并远程分支到当前分支。 这对你来说可能是一个更简单或更舒服的工作流程；默认情况下，git clone命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支（或不管是什么名字的默认分支）。 运行 git pull 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。 ### 推送到远程仓库当你想分享你的项目时，必须将其推送到上游。 这个命令很简单：git push [remote-name] [branch-name]。 当你想要将 master 分支推送到 origin 服务器时（再次说明，克隆时通常会自动帮你设置好那两个名字），那么运行这个命令就可以将你所做的备份到服务器：1$ git push origin master 只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。 当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先将他们的工作拉取下来并将其合并进你的工作后才能推送。 阅读 Git 分支 了解如何推送到远程仓库服务器的详细信息。 查看远程仓库如果想要查看某一个远程仓库的更多信息，可以使用 git remote show [remote-name] 命令。 如果想以一个特定的缩写名运行这个命令，例如 origin，会得到像下面类似的信息：123456789101112$ git remote show origin* remote origin Fetch URL: https://github.com/schacon/ticgit Push URL: https://github.com/schacon/ticgit HEAD branch: master Remote branches: master tracked dev-branch tracked Local branch configured for &apos;git pull&apos;: master merges with remote master Local ref configured for &apos;git push&apos;: master pushes to master (up to date) 它同样会列出远程仓库的 URL 与跟踪分支的信息。 这些信息非常有用，它告诉你正处于 master 分支，并且如果运行 git pull，就会抓取所有的远程引用，然后将远程 master 分支合并到本地 master 分支。 它也会列出拉取到的所有远程引用。 这是一个经常遇到的简单例子。 如果你是 Git 的重度使用者，那么还可以通过 git remote show 看到更多的信息。1234567891011121314151617181920$ git remote show origin* remote origin URL: https://github.com/my-org/complex-project Fetch URL: https://github.com/my-org/complex-project Push URL: https://github.com/my-org/complex-project HEAD branch: master Remote branches: master tracked dev-branch tracked markdown-strip tracked issue-43 new (next fetch will store in remotes/origin) issue-45 new (next fetch will store in remotes/origin) refs/remotes/origin/issue-11 stale (use &apos;git remote prune&apos; to remove) Local branches configured for &apos;git pull&apos;: dev-branch merges with remote dev-branch master merges with remote master Local refs configured for &apos;git push&apos;: dev-branch pushes to dev-branch (up to date) markdown-strip pushes to markdown-strip (up to date) master pushes to master (up to date) 这个命令列出了当你在特定的分支上执行 git push 会自动地推送到哪一个远程分支。 它也同样地列出了哪些远程分支不在你的本地，哪些远程分支已经从服务器上移除了，还有当你执行 git pull 时哪些分支会自动合并。 远程仓库的移除与重命名如果想要重命名引用的名字可以运行 git remote rename 去修改一个远程仓库的简写名。 例如，想要将 pb 重命名为 paul，可以用 git remote rename 这样做：1234$ git remote rename pb paul$ git remoteoriginpaul 值得注意的是这同样也会修改你的远程分支名字。 那些过去引用 pb/master 的现在会引用 paul/master。 如果因为一些原因想要移除一个远程仓库 - 你已经从服务器上搬走了或不再想使用某一个特定的镜像了，又或者某一个贡献者不再贡献了 - 可以使用 git remote rm ：123$ git remote rm paul$ git remoteorigin]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 撤销操作]]></title>
    <url>%2F2017%2F11%2F02%2Fgit-%E6%92%A4%E9%94%80%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[撤消操作在任何一个阶段，你都有可能想要撤消某些操作。 这里，我们将会学习几个撤消你所做修改的基本工具。 注意，有些撤消操作是不可逆的。 这是在使用 Git 的过程中，会因为操作失误而导致之前的工作丢失的少有的几个地方之一。 有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 --amend 选项的提交命令尝试重新提交：1$ git commit --amend 这个命令会将暂存区中的文件提交。 如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令），那么快照会保持不变，而你所修改的只是提交信息。文本编辑器启动后，可以看到之前的提交信息。 编辑后保存会覆盖原来的提交信息。 例如，你提交后发现忘记了暂存某些需要的修改，可以像下面这样操作：123$ git commit -m &apos;initial commit&apos;$ git add forgotten_file$ git commit --amend 最终你只会有一个提交 - 第二次提交将代替第一次提交的结果。 取消暂存的文件接下来的两个小节演示如何操作暂存区域与工作目录中已修改的文件。 这些命令在修改文件状态的同时，也会提示如何撤消操作。 例如，你已经修改了两个文件并且想要将它们作为两次独立的修改提交，但是却意外地输入了 git add * 暂存了它们两个。 如何只取消暂存两个中的一个呢？ git status 命令提示了你：12345678$ git add *$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) renamed: README.md -&gt; README modified: CONTRIBUTING.md 在 “Changes to be committed” 文字正下方，提示使用 git reset HEAD &lt;file&gt;... 来取消暂存。 所以，我们可以这样来取消暂存 CONTRIBUTING.md 文件：123456789101112131415$ git reset HEAD CONTRIBUTING.mdUnstaged changes after reset:M CONTRIBUTING.md$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) renamed: README.md -&gt; READMEChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: CONTRIBUTING.md 这个命令有点儿奇怪，但是起作用了。 CONTRIBUTING.md 文件已经是修改未暂存的状态了。 note : 虽然在调用时加上 --hard 选项可以令 git reset 成为一个危险的命令（译注：可能导致工作目录中所有当前进度丢失！），但本例中工作目录内的文件并不会被修改。 不加选项地调用 git reset 并不危险 — 它只会修改暂存区域 到目前为止这个神奇的调用就是你需要对 git reset 命令了解的全部。我们将会在 重置揭密 中了解 reset 的更多细节以及如何掌握它做一些真正有趣的事。 撤消对文件的修改如果你并不想保留对 CONTRIBUTING.md 文件的修改怎么办？ 你该如何方便地撤消修改 - 将它还原成上次提交时的样子（或者刚克隆完的样子，或者刚把它放入工作目录时的样子）？ 幸运的是，git status 也告诉了你应该如何做。 在最后一个例子中，未暂存区域是这样：12345Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: CONTRIBUTING.md 它非常清楚地告诉了你如何撤消之前所做的修改。 让我们来按照提示执行：1234567$ git checkout -- CONTRIBUTING.md$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) renamed: README.md -&gt; README 可以看到那些修改已经被撤消了。 Important:你需要知道 git checkout -- [file] 是一个危险的命令，这很重要。 你对那个文件做的任何修改都会消失 - 你只是拷贝了另一个文件来覆盖它。 除非你确实清楚不想要那个文件了，否则不要使用这个命令。 如果你仍然想保留对那个文件做出的修改，但是现在仍然需要撤消，我们将会在 Git 分支 介绍保存进度与分支；这些通常是更好的做法。 记住，在 Git 中任何 已提交的 东西几乎总是可以恢复的。 甚至那些被删除的分支中的提交或使用 --amend 选项覆盖的提交也可以恢复（阅读 数据恢复 了解数据恢复）。 然而，任何你未提交的东西丢失后很可能再也找不到了。]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 查看提交历史]]></title>
    <url>%2F2017%2F11%2F01%2Fgit-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2%2F</url>
    <content type="text"><![CDATA[查看提交历史在提交了若干跟新，又或者克隆了某个项目之后，你也许会回顾下提交历史。完成这个任务最简单而又有效的工具是git log命令。 接下来的列子会用演示的simplegit项目，运行下面的命令获取该项目源代码:1git clone https://github.com/schacon/simplegit-progit 然后在此项目中运行 git log，应该会看到下面的输出：123456789101112131415161718$ git logcommit ca82a6dff817ec66f44342007202690a93763949Author: Scott Chacon &lt;schacon@gee-mail.com&gt;Date: Mon Mar 17 21:52:11 2008 -0700 changed the version numbercommit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7Author: Scott Chacon &lt;schacon@gee-mail.com&gt;Date: Sat Mar 15 16:40:33 2008 -0700 removed unnecessary testcommit a11bef06a3f659402fe7563abf99ad00de2209e6Author: Scott Chacon &lt;schacon@gee-mail.com&gt;Date: Sat Mar 15 10:31:28 2008 -0700 first commit 默认不用任何参数的话，git log 会按提交时间列出所有的更新，最近的更新排在最上面。 正如你所看到的，这个命令会列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明。 git log 有许多选项可以帮助你搜寻你所要找的提交， 接下来我们介绍些最常用的。 一个常用的选项是 -p，用来显示每次提交的内容差异。 你也可以加上 -2 来仅显示最近两次提交：1234567891011121314151617181920212223242526272829303132333435363738394041$ git log -p -2commit ca82a6dff817ec66f44342007202690a93763949Author: Scott Chacon &lt;schacon@gee-mail.com&gt;Date: Mon Mar 17 21:52:11 2008 -0700 changed the version numberdiff --git a/Rakefile b/Rakefileindex a874b73..8f94139 100644--- a/Rakefile+++ b/Rakefile@@ -5,7 +5,7 @@ require &apos;rake/gempackagetask&apos; spec = Gem::Specification.new do |s| s.platform = Gem::Platform::RUBY s.name = &quot;simplegit&quot;- s.version = &quot;0.1.0&quot;+ s.version = &quot;0.1.1&quot; s.author = &quot;Scott Chacon&quot; s.email = &quot;schacon@gee-mail.com&quot; s.summary = &quot;A simple gem for using Git in Ruby code.&quot;commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7Author: Scott Chacon &lt;schacon@gee-mail.com&gt;Date: Sat Mar 15 16:40:33 2008 -0700 removed unnecessary testdiff --git a/lib/simplegit.rb b/lib/simplegit.rbindex a0a60ae..47c6340 100644--- a/lib/simplegit.rb+++ b/lib/simplegit.rb@@ -18,8 +18,3 @@ class SimpleGit end end--if $0 == __FILE__- git = SimpleGit.new- puts git.show-end\ No newline at end of file 该选项除了显示基本信息之外，还附带了每次 commit 的变化。 当进行代码审查，或者快速浏览某个搭档提交的 commit 所带来的变化的时候，这个参数就非常有用了。 你也可以为 git log 附带一系列的总结性选项。 比如说，如果你想看到每次提交的简略的统计信息，你可以使用 --stat 选项：1234567891011121314151617181920212223242526272829$ git log --statcommit ca82a6dff817ec66f44342007202690a93763949Author: Scott Chacon &lt;schacon@gee-mail.com&gt;Date: Mon Mar 17 21:52:11 2008 -0700 changed the version number Rakefile | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-)commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7Author: Scott Chacon &lt;schacon@gee-mail.com&gt;Date: Sat Mar 15 16:40:33 2008 -0700 removed unnecessary test lib/simplegit.rb | 5 ----- 1 file changed, 5 deletions(-)commit a11bef06a3f659402fe7563abf99ad00de2209e6Author: Scott Chacon &lt;schacon@gee-mail.com&gt;Date: Sat Mar 15 10:31:28 2008 -0700 first commit README | 6 ++++++ Rakefile | 23 +++++++++++++++++++++++ lib/simplegit.rb | 25 +++++++++++++++++++++++++ 3 files changed, 54 insertions(+) 正如你所看到的，--stat 选项在每次提交的下面列出所有被修改过的文件、有多少文件被修改了以及被修改过的文件的哪些行被移除或是添加了。 在每次提交的最后还有一个总结。 另外一个常用的选项是 --pretty。 这个选项可以指定使用不同于默认格式的方式展示提交历史。 这个选项有一些内建的子选项供你使用。 比如用 oneline 将每个提交放在一行显示，查看的提交数很大时非常有用。 另外还有 short，full 和 fuller 可以用，展示的信息或多或少有些不同，请自己动手实践一下看看效果如何。1234$ git log --pretty=onelineca82a6dff817ec66f44342007202690a93763949 changed the version number085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 removed unnecessary testa11bef06a3f659402fe7563abf99ad00de2209e6 first commit 但最有意思的是 format，可以定制要显示的记录格式。 这样的输出对后期提取分析格外有用 — 因为你知道输出的格式不会随着 Git 的更新而发生改变：1234$ git log --pretty=format:&quot;%h - %an, %ar : %s&quot;ca82a6d - Scott Chacon, 6 years ago : changed the version number085bb3b - Scott Chacon, 6 years ago : removed unnecessary testa11bef0 - Scott Chacon, 6 years ago : first commit git log --pretty=format 常用的选项 列出了常用的格式占位符写法及其代表的意义。 git log --pretty=format 常用的选项 选项 说明 %H 提交对象（commit）的完整哈希字串 %h 提交对象的简短哈希字串 %T 树对象（tree）的完整哈希字串 %t 树对象的简短哈希字串 %P 父对象（parent）的完整哈希字串 %p 父对象的简短哈希字串 %an 作者（author）的名字 %ae 作者的电子邮件地址 %ad 作者修订日期（可以用 –date= 选项定制格式） %ar 作者修订日期，按多久以前的方式显示 %cn 提交者（committer）的名字 %ce 提交者的电子邮件地址 %cd 提交日期 %cr 提交日期，按多久以前的方式显示 %s 提交说明 你一定奇怪 作者 和 提交者 之间究竟有何差别， 其实作者指的是实际作出修改的人，提交者指的是最后将此工作成果提交到仓库的人。 所以，当你为某个项目发布补丁，然后某个核心成员将你的补丁并入项目时，你就是作者，而那个核心成员就是提交者。 我们会在 分布式 Git 再详细介绍两者之间的细微差别。 当 oneline 或 format 与另一个 log 选项 --graph 结合使用时尤其有用。 这个选项添加了一些ASCII字符串来形象地展示你的分支、合并历史：1234567891011$ git log --pretty=format:&quot;%h %s&quot; --graph* 2d3acf9 ignore errors from SIGCHLD on trap* 5e3ee11 Merge branch &apos;master&apos; of git://github.com/dustin/grit|\| * 420eac9 Added a method for getting the current branch.* | 30e367c timeout code and tests* | 5a09431 add timeout protection to grit* | e1193f8 support for heads with slashes in them|/* d6016bc require time for xmlschema* 11d191e Merge branch &apos;defunkt&apos; into local 这种输出类型会在我们下一章学完分支与合并以后变得更加有趣。 以上只是简单介绍了一些 git log 命令支持的选项。 git log 的常用选项 列出了我们目前涉及到的和没涉及到的选项，以及它们是如何影响 log 命令的输出的： git log 的常用选项 选项 说明 -p 按补丁格式显示每个更新之间的差异。 --stat 显示每次更新的文件修改统计信息。 --shortstat 只显示 –stat 中最后的行数修改添加移除统计。 --name-only 仅在提交信息后显示已修改的文件清单。 --name-status 显示新增、修改、删除的文件清单。 --abbrev-commit 仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。 --relative-date 使用较短的相对时间显示（比如，“2 weeks ago”）。 --graph 显示 ASCII 图形表示的分支合并历史。 retty 使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。 限制输出长度除了定制输出格式的选项之外，git log 还有许多非常实用的限制输出长度的选项，也就是只输出部分提交信息。 之前你已经看到过 -2 了，它只显示最近的两条提交， 实际上，这是 -&lt;n&gt; 选项的写法，其中的 n 可以是任何整数，表示仅显示最近的若干条提交。 不过实践中我们是不太用这个选项的，Git 在输出所有提交时会自动调用分页程序，所以你一次只会看到一页的内容。 另外还有按照时间作限制的选项，比如 --since 和 --until 也很有用。 例如，下面的命令列出所有最近两周内的提交：1$ git log --since=2.weeks 这个命令可以在多种格式下工作，比如说具体的某一天 &quot;2008-01-15&quot;，或者是相对地多久以前 &quot;2 years 1 day 3 minutes ago&quot;.还可以给出若干搜索条件，列出符合的提交。 用 --author 选项显示指定作者的提交，用 --grep 选项搜索提交说明中的关键字。 （请注意，如果要得到同时满足这两个选项搜索条件的提交，就必须用 --all-match 选项。否则，满足任意一个条件的提交都会被匹配出来） 另一个非常有用的筛选选项是 -S，可以列出那些添加或移除了某些字符串的提交。 比如说，你想找出添加或移除了某一个特定函数的引用的提交，你可以这样使用：1$ git log -Sfunction_name 最后一个很实用的 git log 选项是路径（path）， 如果只关心某些文件或者目录的历史提交，可以在 git log 选项的最后指定它们的路径。 因为是放在最后位置上的选项，所以用两个短划线（–）隔开之前的选项和后面限定的路径名。 在 限制 git log 输出的选项 中列出了常用的选项 限制 git log 输出的选项 选项 说明 --since, --after 仅显示最近的 n 条提交 -(n) 仅显示最近的 n 条提交 --until, --before 仅显示指定时间之前的提交。 --author 仅显示指定作者相关的提交。 --committer 仅显示指定提交者相关的提交。 --grep 仅显示含指定关键字的提交 -S 仅显示添加或移除了某个关键字的提交 来看一个实际的例子，如果要查看 Git 仓库中，2008 年 10 月期间，Junio Hamano 提交的但未合并的测试文件，可以用下面的查询命令：12345678$ git log --pretty=&quot;%h - %s&quot; --author=gitster --since=&quot;2008-10-01&quot; \ --before=&quot;2008-11-01&quot; --no-merges -- t/5610e3b - Fix testcase failure when extended attributes are in useacd3b9e - Enhance hold_lock_file_for_&#123;update,append&#125;() APIf563754 - demonstrate breakage of detached checkout with symbolic link HEADd1a43f2 - reset --hard/read-tree --reset -u: remove unmerged new paths51a94af - Fix &quot;checkout --track -b newbranch&quot; on detached HEADb0ad11e - pull: allow &quot;git pull origin $something:$current_branch&quot; into an unborn branch 在近 40000 条提交中，上面的输出仅列出了符合条件的 6 条记录。]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git基础]]></title>
    <url>%2F2017%2F10%2F26%2Fgit%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[获取 Git 仓库有两种方式获得git仓库的方法，第一种是现有项目或目录下导入所有文件到git中，第二种是从一个服务器克隆一个现有的git仓库 在现有的目录中初始化仓库如果你打算使用git来对现有的项目进行管理，你只需要进入目录并且输入：1git init 该命令将创建一个名为.git的子目录，这个子目录含有你初始化的git仓库中所有的必须文件，这些文件是git仓库的骨干。当时，这个时候，我们仅仅是做了一个初始化的操作，你的项目里的文件还没没有被跟踪。如果你是在一个已经存在文件的文件夹中初始化git仓库来进行版本控制的话，你应该开始跟踪这些文件并且提交。你可通过git add命令来实现对指定文件的跟踪，然后执行git commit提交：12git add *.*git commit -m &quot;提交的的信息&quot; 克隆现有的仓库如果你想获得一分已经存在了的git仓库的拷贝，这时就要用到git clone命令。如果你对其他的VCS系统(Subversion)很熟悉,请留心一下你所使用命令是clone而不是checkout。这是git区别于其他版本控制系统的一个重要特性，git克隆的是该git仓库服务器上的几乎所有数据，而不是仅仅复制完成你的工作所需要的文件。当你执行git clone命令的时候，默认配置下远程git仓库中每一个文件的每一个版本都将被拉下来。事实上，如果你的服务器的磁盘坏掉了，你通常可以使用任何一个克隆下来的用户端来重建服务器上的仓库克隆仓库的命令格式git colne [url],比如：1git clone https://github.com/isoot/isoot.github.io.git 这是就会在当前目录下传建一个名为”isoot.github.is”的目录，并在这个目录下初始化一个.git文件夹，从远程仓库拉取下所有的数据放入.git文件夹，然后从中读取最新版本的文件拷贝。如果你进入这个新建的isoot.github.io文件夹，你会发现所有的项目文件已经在里面了，准备就绪等待后续的开发和使用。如果你想在克隆远程仓库的时候，自定义本地仓库名字，你可以使用如下命令:1git clone https://github.com/isoot/isoot.github.io.git myFile 这将执行与上一个命令相同的操作，不过早本地创建一个仓库名字变为myFile git支持对中数据传输协议。上面的列子使用的是https://协议，不过你也可以使用git://协议或者使用SSH传输协议，比如user@server:path/to/repo.git 记录每次更新到仓库现在我们手上有了一个真实项目的git仓库，并从这个仓库中取出所有文件的工作拷贝。接下来，对这些文件做些修改，在完成了一个阶段的目标之后，提交本次跟新到仓库。请记住，你的工作目录下的每一个文件都不外乎两种状态：已跟踪或未跟踪。已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于未修改状态，已修改或已放入暂存区。工作目录中除已跟踪文件以外的所有其他文件都属于未跟踪文件，它们即不存在于上次快照的记录中，也没有放入暂缓区。初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态。编辑过某些文件之后，由于自上次提交后你对对它们作了修改，git将它们标记为已修改文件。我们逐步将这些修改过的文件放入暂缓区，然后提交所有暂缓了的修改，如痴反复。所以使用git时文件的生命周期如下: 检查当前文件状态要查看哪些文件处于什么状态，可以用命令git status命令。如果在克隆仓库后立即使用此命令，会看到类似这样的输出:123git statusOn branch masternothing to commit,working directory clean 这说明你现在的工作目录相当干净。换句话说，所有已跟踪文件在上次提交后都未被改过。此外，上面的信息还表明，当前目录没有出现任何处于跟踪状态的新文件，否则git会在这里列出来。最后，改命令还显示了当前所在的分支，并告诉你这个分支同远程服务器上对应的分支没有偏离。现在，分支名是“master”,这是默认的分支名。现在，让我们在项目下创建一个新的README文件。如果之前并不存在这个文件，请使用git status命令，你将看到一个新的未跟踪文件：123456789$ echo &apos;My Project&apos; &gt; README$ git statusOn branch masterUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) READMEnothing added to commit but untracked files present (use &quot;git add&quot; to track) 在状态报告中可以看到新建的README文件出现在Untracked files下面。未跟踪的文件意味着git在之前的快照(提交)中没有这些文件;git不会自动将之纳入跟踪范围，除非你明明白白地告诉它”我需要跟踪改文件”，这样的处理让你不必担心生成二进制文件或其它被跟踪的的文件包含进来。不过现有的列子中，我们确实要跟踪管理README这个文件。 跟踪新文件使用命令git add开始跟踪一个文件。所以，要跟踪README文件，运行:1git add README 此时再运行git status命令，会看到README文件已被跟踪，并处于暂存状态:123456$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: README 只要在Changes to be committed这一行下面的，就说明是已暂存状态。如果此时提交文件，那么该文件此时此刻的版本将被；留在历史记录中。你可能会想起之前我们使用git init后就运行了git add (files)命令，开始跟踪当前目录下的文件。git add命令使用文件或目录的路径最为参数；如果参数是目录的路径，该命令就递归地跟踪该目录下的所有文件。 暂存已修改文件现在我们来修改一个已被跟踪的文件。如果你修改了一个名为CONTRIBUTING.md的已经被跟踪的文件，然后运行git status命令，会看到下面内容：123456789101112$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: READMEChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: CONTRIBUTING.md 文件CONTRIBUTING.md出现在Changes not staged for commit这行下面，说明已跟踪文件的内容发生了变化了，但还没有放到暂存区。要暂存这次跟新，需要运行git add命令。这是一个多功能命令：可以用它开始跟踪新文件，或者吧已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。 将这个命令理解为“添加内容到下一次提交中”而不是“将一个文件添加到项目中”要更加合适。 现在让我们运行 git add 将”CONTRIBUTING.md”放到暂存区，然后再看看 git status 的输出：12345678$ git add CONTRIBUTING.md$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: README modified: CONTRIBUTING.md 现在两个文件都已暂存，下次提交时就会一并记录到仓库。 假设此时，你想要在 CONTRIBUTING.md 里再加条注释， 重新编辑存盘后，准备好提交。 不过且慢，再运行 git status 看看：1234567891011121314$ vim CONTRIBUTING.md$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: README modified: CONTRIBUTING.mdChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: CONTRIBUTING.md 怎么回事？ 现在 CONTRIBUTING.md 文件同时出现在暂存区和非暂存区。 这怎么可能呢？ 好吧，实际上 Git 只不过暂存了你运行 git add 命令时的版本， 如果你现在提交，CONTRIBUTING.md 的版本是你最后一次运行 git add 命令时的那个版本，而不是你运行 git commit 时，在工作目录中的当前版本。 所以，运行了 git add 之后又作了修订的文件，需要重新运行 git add 把最新版本重新暂存起来：12345678$ git add CONTRIBUTING.md$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: README modified: CONTRIBUTING.md 状态简览git status 命令的输出十分详细，但其用语有些繁琐。 如果你使用 git status -s 命令或 git status --short 命令，你将得到一种更为紧凑的格式输出。 运行 git status -s ，状态报告输出如下：123456$ git status -s M READMEMM RakefileA lib/git.rbM lib/simplegit.rb?? LICENSE.txt 新添加的未跟踪文件前面有 ?? 标记，新添加到暂存区中的文件前面有 A 标记，修改过的文件前面有 M 标记。 你可能注意到了 M 有两个可以出现的位置，出现在右边的 M 表示该文件被修改了但是还没放入暂存区，出现在靠左边的 M 表示该文件被修改了并放入了暂存区。 例如，上面的状态报告显示： README 文件在工作区被修改了但是还没有将修改后的文件放入暂存区,lib/simplegit.rb 文件被修改了并将修改后的文件放入了暂存区。 而 Rakefile 在工作区被修改并提交到暂存区后又在工作区中被修改了，所以在暂存区和工作区都有该文件被修改了的记录。 lib/simplegit.rb一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件模式。 来看一个实际的例子：123$ cat .gitignore*.[oa]*~ 第一行告诉 Git 忽略所有以 .o 或 .a 结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的。 第二行告诉 Git 忽略所有以波浪符（~）结尾的文件，许多文本编辑软件（比如 Emacs）都用这样的文件名保存副本。 此外，你可能还需要忽略 log，tmp 或者 pid 目录，以及自动生成的文档等等。 要养成一开始就设置好 .gitignore 文件的习惯，以免将来误提交这类无用的文件。文件 .gitignore 的格式规范如下： 所有空行或者以 ＃ 开头的行都会被 Git 忽略。 可以使用标准的 glob 模式匹配。 匹配模式可以以（/）开头防止递归。 匹配模式可以以（/）结尾指定目录。 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。 星号（*）匹配零个或多个任意字符；[abc] 匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；问号（?）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）。 使用两个星号(*) 表示匹配任意中间目录，比如a/**/z 可以匹配 a/z, a/b/z 或 a/b/c/z等。 我们再看一个 .gitignore 文件的例子： 1234567891011121314151617# no .a files*.a# but do track lib.a, even though you&apos;re ignoring .a files above!lib.a# only ignore the TODO file in the current directory, not subdir/TODO/TODO# ignore all files in the build/ directorybuild/# ignore doc/notes.txt, but not doc/server/arch.txtdoc/*.txt# ignore all .pdf files in the doc/ directorydoc/**/*.pdf 查看已暂存和未暂存的修改如果 git status 命令的输出对于你来说过于模糊，你想知道具体修改了什么地方，可以用 git diff 命令。 稍后我们会详细介绍 git diff，你可能通常会用它来回答这两个问题：当前做的哪些更新还没有暂存？ 有哪些更新已经暂存起来准备好了下次提交？ 尽管 git status 已经通过在相应栏下列出文件名的方式回答了这个问题，git diff 将通过文件补丁的格式显示具体哪些行发生了改变。 假如再次修改 README 文件后暂存，然后编辑 CONTRIBUTING.md 文件后先不暂存， 运行 status 命令将会看到：123456789101112$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: READMEChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: CONTRIBUTING.md 要查看尚未暂存的文件更新了哪些部分，不加参数直接输入 git diff：123456789101112131415$ git diffdiff --git a/CONTRIBUTING.md b/CONTRIBUTING.mdindex 8ebb991..643e24f 100644--- a/CONTRIBUTING.md+++ b/CONTRIBUTING.md@@ -65,7 +65,8 @@ branch directly, things can get messy. Please include a nice description of your changes when you submit your PR; if we have to read the whole diff to figure out why you&apos;re contributing in the first place, you&apos;re less likely to get feedback and have your change-merged in.+merged in. Also, split your changes into comprehensive chunks if your patch is+longer than a dozen lines. If you are starting to work on a particular area, feel free to submit a PR that highlights your work in progress (and note in the PR title that it&apos;s 此命令比较的是工作目录中当前文件和暂存区域快照之间的差异， 也就是修改之后还没有暂存起来的变化内容。 若要查看已暂存的将要添加到下次提交里的内容，可以用 git diff --cached 命令。（Git 1.6.1 及更高版本还允许使用 git diff --staged，效果是相同的，但更好记些。）12345678$ git diff --stageddiff --git a/README b/READMEnew file mode 100644index 0000000..03902a1--- /dev/null+++ b/README@@ -0,0 +1 @@+My Project 请注意，git diff 本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动。 所以有时候你一下子暂存了所有更新过的文件后，运行 git diff 后却什么也没有，就是这个原因。 像之前说的，暂存 CONTRIBUTING.md 后再编辑，运行 git status 会看到暂存前后的两个版本。 如果我们的环境（终端输出）看起来如下：1234567891011121314$ git add CONTRIBUTING.md$ echo &apos;# test line&apos; &gt;&gt; CONTRIBUTING.md$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: CONTRIBUTING.mdChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: CONTRIBUTING.md 现在运行 git diff 看暂存前后的变化：12345678910$ git diffdiff --git a/CONTRIBUTING.md b/CONTRIBUTING.mdindex 643e24f..87f08c8 100644--- a/CONTRIBUTING.md+++ b/CONTRIBUTING.md@@ -119,3 +119,4 @@ at the ## Starter Projects See our [projects list](https://github.com/libgit2/libgit2/blob/development/PROJECTS.md).+# test line 然后用 git diff --cached 查看已经暂存起来的变化：（–staged 和 –cached 是同义词）123456789101112131415$ git diff --cacheddiff --git a/CONTRIBUTING.md b/CONTRIBUTING.mdindex 8ebb991..643e24f 100644--- a/CONTRIBUTING.md+++ b/CONTRIBUTING.md@@ -65,7 +65,8 @@ branch directly, things can get messy. Please include a nice description of your changes when you submit your PR; if we have to read the whole diff to figure out why you&apos;re contributing in the first place, you&apos;re less likely to get feedback and have your change-merged in.+merged in. Also, split your changes into comprehensive chunks if your patch is+longer than a dozen lines. If you are starting to work on a particular area, feel free to submit a PR that highlights your work in progress (and note in the PR title that it&apos;s 提交更新现在的暂存区域已经准备妥当可以提交了。 在此之前，请一定要确认还有什么修改过的或新建的文件还没有 git add 过，否则提交的时候不会记录这些还没暂存起来的变化。 这些修改过的文件只保留在本地磁盘。 所以，每次准备提交前，先用 git status 看下，是不是都已暂存起来了， 然后再运行提交命令 git commit：1$ git commit 这种方式会启动文本编辑器以便输入本次提交的说明。 (默认会启用 shell 的环境变量 $EDITOR 所指定的软件，一般都是 vim 或 emacs。当然也可以按照 起步 介绍的方式，使用 git config --global core.editor 命令设定你喜欢的编辑软件。）编辑器会显示类似下面的文本信息（本例选用 Vim 的屏显方式展示）：1234567891011# Please enter the commit message for your changes. Lines starting# with &apos;#&apos; will be ignored, and an empty message aborts the commit.# On branch master# Changes to be committed:# new file: README# modified: CONTRIBUTING.md#~~~&quot;.git/COMMIT_EDITMSG&quot; 9L, 283C 可以看到，默认的提交消息包含最后一次运行 git status 的输出，放在注释行里，另外开头还有一空行，供你输入提交说明。 你完全可以去掉这些注释行，不过留着也没关系，多少能帮你回想起这次更新的内容有哪些。 (如果想要更详细的对修改了哪些内容的提示，可以用 -v 选项，这会将你所做的改变的 diff 输出放到编辑器中从而使你知道本次提交具体做了哪些修改。） 退出编辑器时，Git 会丢掉注释行，用你输入提交附带信息生成一次提交。 另外，你也可以在 commit 命令后添加 -m 选项，将提交信息与命令放在同一行，如下所示：1234$ git commit -m &quot;Story 182: Fix benchmarks for speed&quot;[master 463dc4f] Story 182: Fix benchmarks for speed 2 files changed, 2 insertions(+) create mode 100644 README 好，现在你已经创建了第一个提交！可以看到，提交之后他会告诉，当前在那个分支(master)提交的，本次提交的完整SHA-1校验值是什么(463dc4f),以及本次提交中，对少文件修订过，多少行添加和删除过。请记住，提交是记录的放在暂存区域的快照。任何还未暂存的仍然保持已修改状态，可在下次提交时纳入版本管理。每一次运行提交操作，都是对你项目做一次快照，以后可以回到这个状态，或者进行比较。 跳过使用暂存区域尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。git提供了一个跳过使用暂存区域的方式，只要在提交的时候，给git commit加上-a选项，git就会自动把所有已经跟踪过得文件咱存起来一并提交，从而跳过git add步骤：123456789101112$ git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: CONTRIBUTING.mdno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)$ git commit -a -m &apos;added new benchmarks&apos;[master 83e38c7] added new benchmarks 1 file changed, 5 insertions(+), 0 deletions(-) 看到了吗？提交之前不再需要git add文件 移除文件要从git中移除某个文件，就必须要从已跟踪文件清单中移除(确切滴说，是从暂存区域移除)，然后提交。可以用git rm命令完成此项工作，并连带从工作目录删除指定文件，这昂以后就不会出现在未跟踪文件清单中了， 如果只是简单地从工作目录中手工删除文件，运行git status时就会在Changes not staged for commit部分(也就是 未暂存清单)看到:1234567891011$ rm PROJECTS.md$ git statusOn branch masterYour branch is up-to-date with &apos;origin/master&apos;.Changes not staged for commit: (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) deleted: PROJECTS.mdno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 然后在运行git rm记录此次移除文件的操作：12345678$ git rm PROJECTS.mdrm &apos;PROJECTS.md&apos;$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) deleted: PROJECTS.md 下一次提交时，该文件就不再纳入版本管理了。如果删除之前修改过并且已经放在暂存区域的话，则必须要用强制删除选项-f(译注:即force的首字母).这是一种安全特性，用于防止误删还没有添加到快照的数据，这样的数据不能被git恢复。另外一种情况，我们想要把文件从git仓库中删除(亦即从暂存区域移除)，但仍然希望保留在当前工作目录中。换句话说，你想让文件保留在磁盘，danshibingbuxiangranggit继续跟踪。当你忘记添加.gitignore文件，不小心吧一个很大的日志文件或一对.a这样的编译生成文件添加到暂存区时，这一做法尤其有用。未到达这一目的，使用--cached选项：1$ git rm --cached README git rm命令后面可以列出文件或者目录的名字，也可以使用glob模式。比方说:1$ git rm log/\*.log 主意到星号*之前的反斜杠\，因为git有他自己的文件模式扩展匹配方式，说以我们不用shell来帮忙暂开。此命令删除log/目录下扩展名为.log的所有文件。类似的比如:1$ git rm \*~ 该命令为删除以~结尾的所所有文件. 移动文件不想其他的VCS系统，git并不显示跟踪文件移动操作。如果在git中重命名了某个文件，仓库中暂存的元数据并不会体现出这是一次改名操作。不过git非常聪明，他会推断出究竟发生了什么，至于具体是如何做到的，我们稍后再谈。既然如此，当你看到git的mv命令时一定会困惑不已。要在git中对文件改名，可以这么做:1$ git mv file_from file_to 他会恰如预期般正常工作。实际上，即便如此查看状态信息，也会明白无误地拉姆岛关于重命名操作的说明:1234567$ git mv README.md README$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) renamed: README.md -&gt; README 其实，运行git mv就相当于运行了下面三条命令:123$ mv README.md README$ git rm README.md$ git add README 如此分开操作，git也会意识到这是一次改名，所有不管任何方式结果都市一样。两种唯区别是，mv是一条命令而另外一种方式需要三条命令，直接用git mv轻便很多。不过有时候其他工具批处理改名的话，要记得在提交前删除老的文件名，再添加新的文件名。]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[title]]></title>
    <url>%2F2017%2F10%2F25%2Ftitle%2F</url>
    <content type="text"><![CDATA[欢迎您的到来！ 前些日子我在网上了解到利用github+hexo+markdown做自己的博客网站(当然这是静态的网站)，手痒自己在公司就开始按照步骤开始了我的github博客之旅。我打算把我的技术博客放置到这里还有其他一些人生感悟的，同时也谢谢您们的支持和帮助，]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
</search>
